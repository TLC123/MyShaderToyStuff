{
 "userName": "TLC123",
 "date": "2021-01-19T16:32:48.923Z",
 "numShaders": 56,
 "shaders": [
  {
   "ver": "0.1",
   "info": {
    "id": "WddSzr",
    "date": "1571333620",
    "viewed": 11,
    "name": " Fork of \"Voronoi Shader with ma",
    "description": "// Fork of \"Voronoi Shader with max 8 player\" by wouter140. https://shadertoy.com/view/wst3zX\n\nadded blurry edges. and color averaging of bgr color when  two get close\n\n\n",
    "likes": 0,
    "published": "Unlisted",
    "usePreview": 0,
    "tags": [
     "mainsplitscreendemo"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Voronoi Shader with max 8 player\" by wouter140. https://shadertoy.com/view/wst3zX\n// 2019-10-17 17:30:02\n\n// Screen coords:\n//   vec2 in \"screen units\" relative to the center of viewport\n//   y axis pointing up, x axis pointing to the right\n//   screen units are chosen so that a square [-1, 1] x [-1, 1] fits into the screen\n// World coords: vec2 in units.\n// Cameras: vec3, .xy is world coords of the center of the camera, .z is \"zoom\" (in screen units per world unit)\n\n\n#define PI 3.1415926535897932384626433832795\n\n#define CAMERA_ZOOM_MIN 0.6\n#define CAMERA_ZOOM_MAX 1.0\n\n#define N_PLAYERS 3\n\nvec3 playersColor[N_PLAYERS];\nvec3 playersBgColor[N_PLAYERS];\n\n\n// Inputs of the shader.\nvec2 playersPos[N_PLAYERS];  // player positions in world coordinates\nvec3 globalCam;             // global camera (zoomed out camera that sees all players)\nvec3 playersCam[N_PLAYERS];  // positions of cameras for each player\n\n\n// *****************************************************\n//  Utility functions\n// *****************************************************\n\nfloat atan2(float y, float x) {\n\t// For some reason GLSL's atan doesn't work as atan2\n    // and only returns angles [0, PI).\n    if (y > 0.0) {\n        return atan(y, x);\n    } else {\n        return PI + atan(-y, -x);\n    }\n}\n\nvec2 camScreen2World(vec3 cam, vec2 screenCoord) {\n    return cam.xy + screenCoord / cam.z;\n}\n\nfloat camScreen2World(vec3 cam, float screenLength) {\n    return screenLength / cam.z;\n}\n\nvec2 camWorld2Screen(vec3 cam, vec2 worldCoord) {\n    return (worldCoord - cam.xy) * cam.z;\n}\n\nfloat camWorld2Screen(vec3 cam, float worldLength) {\n    return worldLength * cam.z;\n}\n\nfloat screen2px(float x) {\n    return x * 0.5 * min(iResolution.x, iResolution.y);\n}\n\nfloat camWorld2Px(vec3 cam, float worldLength) {\n    return screen2px(camWorld2Screen(cam, worldLength));\n}\n\n// Weighted aggregation of the color information for overlapping objects on the same layer.\n// The resulting color is a weighted average of all aggreageted colors.\nvoid aggregateColorSiblings(inout vec4 aggColor, inout float aggWeight, vec4 addedColor) {\n    if (addedColor.w > 0.0001) {\n        float opacity = max(aggColor.w, addedColor.w);        \n        aggWeight += addedColor.w;\n        aggColor = vec4(mix(aggColor.xyz, addedColor.xyz, addedColor.w / aggWeight), opacity);\n    }    \n}\n\n// *****************************************************\n//  Scene rendering (demo vesion)\n// *****************************************************\n\nvec3 renderBackgroundRadialChecker(vec3 cam, vec2 screenCoord) {\n    vec2 worldCoord = camScreen2World(cam, screenCoord);\n    \n    float radius = length(worldCoord.xy);\n    float angularD = atan2(worldCoord.y, worldCoord.x) * radius;\n    \n    const float rowWidthGrowthPow = 2.5;    \n    const float rowRadiusScale = 100.0;\n    // index of a radial checker row.\n    float row = ceil(pow(radius * rowRadiusScale, 1.0 / rowWidthGrowthPow));\n    \n    float rowOuterRadius = pow(row, rowWidthGrowthPow) / rowRadiusScale;    \n    float radialBorderD = abs(radius - rowOuterRadius);\n    float columns = 10.0;\n    const float minRow = 2.0;\n    if (row < minRow + 0.1) {\n        row = minRow;\n        columns = 4.0;\n    } else {\n  \t\tfloat rowInnerRadius = pow(row - 1.0, rowWidthGrowthPow) / rowRadiusScale;\n        radialBorderD = min(radialBorderD, abs(radius - rowInnerRadius));\n        \n        columns = 10.0;        \n    }\n    \n    // index of a concentric checker column.\n    float columnWidth = (radius * 2.0 * PI) / columns;\n    float col = ceil(angularD / columnWidth);\n    \n    float concentricBorderD = abs(mod(angularD / columnWidth + 0.5, 1.0) - 0.5) * columnWidth;\n    \n    \n    const vec3 white = vec3(1.0);\n    const vec3 black = vec3(0.0);\n    vec3 midColor = 0.5 * (black + white);\n    \n    vec3 color;\n    if (mod(row + col, 2.0) > 0.5) {\n        color = white;\n    } else {\n        color = black;\n    }\n    \n    float borderDPx = camWorld2Px(cam, min(radialBorderD, concentricBorderD));\n    float aaColorWeight = smoothstep(0.0, 0.6, borderDPx);\n    \n    return mix(midColor, color, aaColorWeight);\n}\n\nvec4 renderPlayers(vec3 cam, vec2 screenCoord) {\n    vec2 worldCoord = camScreen2World(cam, screenCoord);\n    \n    // Player is a 10px at furthest possible zoom and gets bigger when gets closer.\n    float radiusPx = 10.0 * max(cam.z, CAMERA_ZOOM_MIN) / CAMERA_ZOOM_MIN;\n    const float radiusAaPx = 1.0;\n    \n    vec4 color = vec4(0.0);\n    float weight = 0.0;\n    for(int i = 0; i < N_PLAYERS; i++) {\n    \tfloat distPx = camWorld2Px(cam, length(worldCoord - playersPos[i]));\n        \n        float playerWeight = 1.0 - smoothstep(radiusPx, radiusPx + radiusAaPx, distPx);\n        vec4 playerColor = vec4(playersColor[i], playerWeight);\n        aggregateColorSiblings(color, weight, playerColor);\n  \t}    \n    return color;\n}\n\nvec3 renderScene(vec3 cam, vec2 screenCoord) {\n    vec3 color = renderBackgroundRadialChecker(cam, screenCoord);\n    vec4 playersColor = renderPlayers(cam, screenCoord);\n    color = mix(color, playersColor.xyz, playersColor.w);\n    \n    return color;\n}\n\n// *****************************************************\n//  Screen partitioning\n// *****************************************************\n\n// Returns a number that is guaranteed to be higher than any\n// of the distances within Global Camera.\nfloat maxGlobalDist() {\n    return camScreen2World(globalCam, 100.0);\n}\n\nvec2 closestPlayer(vec2 screenCoord) {\n    vec2 worldCoord = camScreen2World(globalCam, screenCoord);\n\n    \n    \n    int minPlayer = 0;\n    float minDist = maxGlobalDist();\n    \n    for(int i = 0; i < N_PLAYERS; i++) {\n    \tfloat dist = length(worldCoord - playersPos[i]);\n        \n        if (dist < minDist) {\n            minDist = dist;\n            minPlayer = i;\n        }\n  \t}\n    \n   \n \n    return vec2(float(minPlayer),minDist);\n}\n\nvec3 secondClosestPlayer(vec2 screenCoord) {\n    vec2 worldCoord = camScreen2World(globalCam, screenCoord);\n\n    \n    \n    int minPlayer = 0;\n    float minDist = maxGlobalDist();\n    vec2 minplayersPos;\n    vec2 secondMinplayersPos;\n    for(int i = 0; i < N_PLAYERS; i++) {\n    \tfloat dist = length(worldCoord - playersPos[i]);\n        \n        if (dist < minDist) {\n            minDist = dist;\n            minPlayer = i;\n            minplayersPos=playersPos[i] ;\n        }\n  \t}\n    \n        int secondMinPlayer = 0;\n    float secondMinDist = maxGlobalDist();\n    \n    for(int i = 0; i < N_PLAYERS; i++) {\n    \tfloat secondDist = length(worldCoord - playersPos[i]);\n        \n        if (secondDist < secondMinDist && i!=minPlayer) {\n            secondMinDist = secondDist;\n            secondMinPlayer = i;\n                        secondMinplayersPos=playersPos[i] ;\n\n        }\n  \t}\n \n    return       vec3(float(secondMinPlayer),secondMinDist,length(secondMinplayersPos-minplayersPos));\n \n}\n\n// *****************************************************\n//  Faking inputs\n// *****************************************************\n\nvec2 initPlayerPos(vec2 basePos, float radius, float basePhase, float timeC) {\n    vec2 center = basePos - radius * vec2(cos(basePhase), sin(basePhase));\n    float phase = basePhase + iTime * timeC;\n    return center + radius * vec2(cos(phase), sin(phase));\n}\n\nvoid fakePlayers() {\n    const float timeScale = 0.2;\n    \n    for(int i = 0; i < N_PLAYERS; i++) {\n        switch(i) {\n            case 0:\n            playersColor[i] = vec3(0.957, 0.263, 0.212);  // red\n            playersPos[i] = initPlayerPos(vec2(0.2, 0.1), 2.0, PI, 1.0 * timeScale);\n            break;\n            \n            case 1:\n            playersColor[i] = vec3(0.129, 0.588, 0.953);  // blue\n            playersPos[i] = initPlayerPos(vec2(-0.2, 0.1), 1.0, 3.0 * PI * 0.5, 3.0 * timeScale);\n            break;\n            \n            case 2:\n            playersColor[i] = vec3(0.298, 0.686, 0.314);  // green\n            playersPos[i] = initPlayerPos(vec2(-0.2, -0.1), 3.0, 0.0, 0.5 * timeScale);\n            break;\n            \n            case 3:\n            playersColor[i] = vec3(0.612, 0.153, 0.69);   // purple\n            playersPos[i] = initPlayerPos(vec2(0.2, -0.1), 2.0, 3.0 * PI / 4.0, 1.0 * timeScale);\n            break;\n            \n            \n            case 4:\n            playersColor[i] = vec3(1, 0.153, 0.69);   \n            playersPos[i] = initPlayerPos(vec2(0.2, -0.1), 2.0, 3.0 * PI / 5.0, 1.0 * timeScale);\n            break;\n            \n            case 5:\n            playersColor[i] = vec3(0.612, 1, 0.69);   \n            playersPos[i] = initPlayerPos(vec2(0.2, -0.1), 1.0, 3.0 * PI / 10.0, 1.0 * timeScale);\n            break;\n            \n            case 6:\n            playersColor[i] = vec3(0.612, 0.153, 1);   \n            playersPos[i] = initPlayerPos(vec2(0.2, -0.1), 3.0, 3.0 * PI / 14.0, 1.0 * timeScale);\n            break;\n            \n            case 7:\n            playersColor[i] = vec3(0.612, 0.553, 1);   \n            playersPos[i] = initPlayerPos(vec2(0.2, -0.1), 2.0, 3.0 * PI / 34.0, 1.0 * timeScale);\n            break;\n            \n            \n            case 8:\n            playersColor[i] = vec3(0.957, 0.263, 0.212);  // red\n            playersPos[i] = initPlayerPos(vec2(0.8, 0.5), 2.0, PI, 1.0 * timeScale);\n            break;\n            \n            case 9:\n            playersColor[i] = vec3(0.129, 0.588, 0.953);  // blue\n            playersPos[i] = initPlayerPos(vec2(-0.8, -0.1), 1.0, -3.0 * PI * 0.5, 3.0 * timeScale);\n            break;\n            \n            case 10:\n            playersColor[i] = vec3(0.298, 0.686, 0.314);  // green\n            playersPos[i] = initPlayerPos(vec2(-0.3, 0.1), 3.0, 0.0, 0.5 * timeScale);\n            break;\n            \n            case 11:\n            playersColor[i] = vec3(0.612, 0.153, 0.69);   // purple\n            playersPos[i] = initPlayerPos(vec2(-0.4, 0.1), 2.0, 3.0 * PI / -4.0, 1.0 * timeScale);\n            break;\n            \n            case 12:\n            playersColor[i] = vec3(1, 0.153, 0.69);   \n            playersPos[i] = initPlayerPos(vec2(0.3, -0.7), 2.0, -3.0 * PI / 5.0, 1.0 * timeScale);\n            break;\n            \n            case 13:\n            playersColor[i] = vec3(0.612, 1, 0.69);   \n            playersPos[i] = initPlayerPos(vec2(-0.92, -0.1), 1.0, -3.0 * PI / -10.0, 1.0 * timeScale);\n            break;\n            \n            case 14:\n            playersColor[i] = vec3(0.612, 0.153, 1);   \n            playersPos[i] = initPlayerPos(vec2(0.29, 0.1), 3.0, 3.0 * PI / -4.0, 1.0 * timeScale);\n            break;\n            \n            case 15:\n            playersColor[i] = vec3(0.612, 0.553, 1);   \n            playersPos[i] = initPlayerPos(vec2(0.62, -0.31), 2.0, 3.0 * PI / 44.0, 1.0 * timeScale);\n            break;\n        }\n    }\n}\n\n\nvoid fakeGlobalCamera() {\n    vec2 minPlayerCoord = playersPos[0];\n    vec2 maxPlayerCoord = playersPos[0];\n    for(int i = 1; i < N_PLAYERS; i++) {\n        minPlayerCoord = min(minPlayerCoord, playersPos[i]);\n        maxPlayerCoord = max(maxPlayerCoord, playersPos[i]);\n  \t}\n    const float cameraMarginScreen = 0.4;\n    // (maxPlayerCoord.x - minPlayerCoord.x) * zoom + 2.0 * cameraMarginScreen = iResolution.x / screen2px(1.0);\n    vec2 zoom = (iResolution.xy / screen2px(1.0) - 2.0 * cameraMarginScreen) / (maxPlayerCoord - minPlayerCoord);\n\tglobalCam = vec3((minPlayerCoord + maxPlayerCoord) * 0.5, min(min(zoom.x, zoom.y), CAMERA_ZOOM_MAX));\n}\n\nvoid fakePlayerCameras() {\n    if (globalCam.z > CAMERA_ZOOM_MIN) {\n        for(int i = 0; i < N_PLAYERS; i++) {\n            playersCam[i] = globalCam;\n        }\n    } else {\n        for(int i = 0; i < N_PLAYERS; i++) {\n            vec2 playerPosScreen = camWorld2Screen(globalCam, playersPos[i]);\n            playersCam[i] = vec3(playersPos[i] - playerPosScreen / CAMERA_ZOOM_MIN, CAMERA_ZOOM_MIN);\n        }\n    }\n}\n\nvoid adjustPlayerCameras(float uniformCamZoom) {\n    \n    for(int i = 0; i < N_PLAYERS; i++) {\n        playersBgColor[i] = playersColor[i];\n    }\n    float mergeDistMin = 0.6 * CAMERA_ZOOM_MIN;\n    float mergeDistMax = 0.8 * CAMERA_ZOOM_MIN;\n    for (int k = 0; k < 2; k++) {\n        // Moving cameras closer to each other.\n        for(int i = 0; i < N_PLAYERS; i++) {\n            for(int j = 0; j < N_PLAYERS; j++) {\n                if (i < j) {\n                    vec2 camPosI = playersCam[i].xy;\n                    vec2 camPosJ = playersCam[j].xy;\n                    float camDistScreen = length(camPosI - camPosJ) * uniformCamZoom;\n                    float mergeWeight = 0.5 * (1.0 - pow(smoothstep(mergeDistMin, mergeDistMax, camDistScreen), 4.0));\n                    playersCam[i].xy = mix(camPosI, camPosJ, mergeWeight);\n                    playersCam[j].xy = mix(camPosJ, camPosI, mergeWeight);\n\n                    vec3 bgColorI = playersBgColor[i];\n                    vec3 bgColorJ = playersBgColor[j];\n                    playersBgColor[i] = mix(bgColorI, bgColorJ, mergeWeight);\n                    playersBgColor[j] = mix(bgColorJ, bgColorI, mergeWeight);\n                }            \n            }\n        }\n        mergeDistMin *= 0.5;\n        mergeDistMax *= 0.5;\n    }\n}\n\n// *****************************************************\n//  Demos\n// *****************************************************\n\nvec4 mainSimpleDemo(vec2 screenCoord) {\n    fakePlayers();    \n    \n    float zoom = (CAMERA_ZOOM_MAX + CAMERA_ZOOM_MIN) * 0.5; // x axis spans [-10, 10]\n    zoom = zoom - (CAMERA_ZOOM_MAX - CAMERA_ZOOM_MIN) * 0.5 * cos(iTime * 0.3);  // animate zoom\n    const float camRadius = 0.2;\n\tvec3 camera = vec3(camRadius * cos(iTime), camRadius * sin(iTime), zoom);\n    \n    return vec4(renderScene(camera, screenCoord), 1.0);\n}\n\nvec4 mainGlobalCameraDemo(vec2 screenCoord) {\n    fakePlayers();    \n    fakeGlobalCamera();\n    \n    vec3 color = renderScene(globalCam, screenCoord);\n    int player = int(closestPlayer(screenCoord)[0]);\n    for(int i = 0; i < N_PLAYERS; i++) {\n        if (player == i) {\n        \tcolor = mix(color, playersColor[i], 0.4);\n        }\n    }\n    \n    return vec4(color, 1.0);\n}\n\nvec4 mainSplitScreenDemo(vec2 screenCoord) {\n    fakePlayers();    \n    fakeGlobalCamera();\n    fakePlayerCameras();\n\n    // We assume that all player cams have the same zoom.\n    float uniformCamZoom = playersCam[0].z;\n    adjustPlayerCameras(uniformCamZoom);\n    \n    vec2 res = closestPlayer(screenCoord);\n    int i= int(res[0]);\n    vec3 res2 = secondClosestPlayer(screenCoord);\n    int i2= int(res2[0]);\n\n    \n    float dist=res[1];\n    float sumDist=(res[1]+res2[1]);\n    float pairmix=dist/sumDist;\n    float pairDist=res2[2];\n    float bgmix=smoothstep(0.,.9, min(1.,1./pairDist));\n    vec3 closecolor=(playersBgColor[i ]+playersBgColor[i2 ])/2.;\n    \n    vec3 color;\n        \n   {\n        \tcolor = renderScene(playersCam[i], screenCoord);\n\t               vec3 bgcolor = mix( playersBgColor[i ]  ,closecolor,bgmix);\n                   \tcolor  = mix(color , bgcolor, 0.4);        }\n     \n     \n\n    vec3 color2;\n        \n   {\n        \tcolor2 = renderScene(playersCam[i2], screenCoord);\n        \t vec3 bgcolor = mix( playersBgColor[i2 ]  ,closecolor,bgmix);\n                   \tcolor2 = mix(color2, bgcolor, 0.4);\n\n        }\n \n    \n      \n\n    \n    color=mix(color,color2,smoothstep(0.49,.51, pairmix) );\n    \n    \n    return vec4(color, 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCoord = (fragCoord.xy - 0.5 * iResolution.xy) / screen2px(1.0);\n    // vec4 color = mainSimpleDemo(screenCoord);\n    // vec4 color = mainGlobalCameraDemo(screenCoord);\n    vec4 color = mainSplitScreenDemo(screenCoord);\n\tfragColor = vec4(color.xyz, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "lt3czs",
    "date": "1533667243",
    "viewed": 202,
    "name": " [SH18] Adonis Bob",
    "description": "Hambone mit node xyz scaling: variation of conecapsule",
    "likes": 11,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "3d",
     "human",
     "sh18",
     "conecapsule",
     "hambone"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4sXGzn",
       "filepath": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define TAU 6.28318530718\n//Procedural animation. What a horrable mess i made.  \n// 2018 shadertoy competition entry.\n\n\n struct mdt { vec3 pos; vec3 scale; }; \nvec3 walkbob(float t){  return vec3(0.,0.,sin ( smoothstep(0.,1. , mod(t,1.0))*TAU));} \nvec3 swing(float t){  return vec3(0.,sin (smoothstep(0.,1. , mod(t,1.0))*TAU),0.);} \nvec3 sway(float t){  return vec3(    sin ( smoothstep(0.,1. ,mod(t,1.0))*TAU),0.,0.);} \n \nconst mdt[] v1= mdt[] ( \n    mdt(vec3(0, -2, 33),vec3(8,8,12)),mdt(vec3(0,-3, 50),vec3(14,14,15)),\n    mdt(vec3(0,-2, 85),vec3(14,10, 14)),mdt(vec3(0, 0,100),vec3(5,5,5)), \n    mdt(vec3(0,-15,117),vec3(12,10,14)),mdt(vec3(0, 5,140),vec3(17,17,17)));\nconst mdt[] v2= mdt[]  ( \n    mdt(vec3( 5, 0,96),vec3(5,6,4)),mdt(vec3(20,  2,95),vec3(7,7,6)),\n    mdt(vec3(40,  0,60),vec3(4,5,4)),mdt(vec3(35,-21,30),vec3(2,3,2)),\n    mdt(vec3(35,-25,10),vec3(8,4,8)),mdt(vec3(35,-20,-5),vec3(3,4,3)));\nconst mdt[] v3= mdt[]  ( \n    mdt(vec3(  -5, 0,96),vec3(5,6,4)),mdt(vec3(-20,  2,95),vec3(7,7,6)),\n    mdt(vec3(-40,  0,60),vec3(4,5,4)),mdt(vec3(-35,-21,30),vec3(2,3,2)),\n    mdt(vec3(-35,-25,10),vec3(8,4,8)),mdt(vec3(-35,-20,-5),vec3(3,4,3)));\n\n\n\nfloat  synmin(float a,float  b,float  r  ) {\n    // drop-in function for smin  \n\t \n        float  e =   max(r*0.02,(abs(a-b)/r) );\n        return min (a,b)- max(0.01,(r*10.1*e*(exp(1.0-(e*0.6 ))))/max(a,b)*0.5)\n \n            ;}\n// rotm sphere  credit to Inigo Quilez\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;}\nfloat smin( float a, float b, float k )\n{    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);}\n\nfloat conecapsule (vec3 p, vec3 p1 ,vec3 p2 ,vec3 r1,vec3 r2 ) {\n// eats vec4 (x,y,z,r) X 2\n    p1=vec3(p1.x,p1.y,max(-85.,p1.z));\n    p2=vec3(p2.x,p2.y,max(-85.,p2.z));\nvec3 a=mix(p1,p2,0.05);\nvec3 b=mix(p1,p2,0.85);;\nvec3 n1=pow(abs(normalize(p-a)),vec3(1.36));\nvec3 n2=pow(abs(normalize(p-b)),vec3(1.36)); \nfloat\t\td1= length  ( vec3(r1.x*n1.x, r1.y*n1.y,r1.z*n1.z));\nfloat\t\td2= length (vec3(r2.x*n2.x, r2.y*n2.y,r2.z*n2.z)); \nvec3\t\tba = b - a;\nvec3\t\tpa = p - a;\n    float v= dot(pa,ba) / dot(ba,ba);\nfloat\t\th = clamp(  v,   0.0,   1.0);\nfloat\t\t\td=mix(d1,d2,  smoothstep(0.0,1.0,   h));\n     float r= d ;// / 2.0;\n \n            return length (pa - ba*h) - r;\n\n}\n\nvec4 map(vec4 r0)\n{  vec3 p=r0.xyz ;\n \nfloat myTime= iTime*2.1 ;\n \n \n  mdt[] v4= mdt[]  ( \n    mdt(vec3( 1, 0, 30)+walkbob(myTime)*8.,vec3(4,4,6)), \n      mdt(vec3(13,  5, 30)+walkbob(myTime)*3.+walkbob(myTime/2.+0.5)*3.,vec3(10,10,11)),\n    mdt(vec3(20,-15,-20)+walkbob(myTime/2.+0.5)*8.+swing(myTime/2.+0.0)*20.+sway(myTime/4. )*2.,vec3(7,7,7)), \n      mdt(vec3(15,  1,-84)+walkbob(myTime/2.+0.5)*8.+sway(myTime/4.+0.25+0.5)*6.,vec3(5,6,4)),\n    mdt(vec3(22, -10,-81)+walkbob(myTime/2.+0.5)*8.+sway(myTime/4.+0.25+0.5)*6.,vec3(8,7,5)),\n      mdt(vec3(25,-20,-84)+walkbob(myTime/2.+0.5)*8.+sway(myTime/4.+0.25+0.5)*8.,vec3(4,6,4)));\n  mdt[] v5= mdt[]  ( \n    mdt(vec3(  -1, 0, 30)+walkbob(myTime)*8.,vec3(4,4,6)),\n      mdt(vec3(-13,  5, 30)+walkbob(myTime)*3.+walkbob(myTime/2.)*3.,vec3(10,10,11)),\n    mdt(vec3(-20,-15,-20)+walkbob(myTime/2.)*8.+swing(myTime/2.+0.5)*20.+sway(myTime/4. +0.5)*2.,vec3(7,7,7)),\n      mdt(vec3(-15,  1,-84)+walkbob(myTime/2.)*8. +sway(myTime/4.+0.35)*6.,vec3(5,6,4)),\n    mdt(vec3(-22, -10,-81)+walkbob(myTime/2.)*8. +sway(myTime/4.+0.35)*6.,vec3(8,7,5)),\n      mdt(vec3(-25,-20,-84)+walkbob(myTime/2.)*8. +sway(myTime/4.+0.35)*8.,vec3(4,6,4))); \n\n \n \n \n \n // make a few points\nfloat d1=1000000000.;\nfloat d2=d1;\nfloat d3=d1;\nfloat d4=d1;\nfloat d5=d1;\n \n for( int i=0; i<5; i++ ){\n  d1= synmin(d1,conecapsule( p -walkbob(myTime)*6.+swing(myTime/2.+0.5)*2.\n                            +vec3(0,-4,0)+sway(myTime/4.+0.5)*2.\n                            ,  v1[i].pos , v1[i+1].pos ,v1[i].scale,v1[i+1].scale ),2.);\n  d2= synmin(d2,conecapsule( p-walkbob(myTime)*4.+walkbob(myTime+0.25)*2.,  v2[i].pos , v2[i+1].pos ,v2[i].scale,v2[i+1].scale ),1.);\n  d3= synmin(d3,conecapsule( p-walkbob(myTime)*4.+walkbob(myTime-0.25)*2.,  v3[i].pos , v3[i+1].pos ,v3[i].scale,v3[i+1].scale ),1.);\n  d4= synmin(d4,conecapsule( p,  v4[i].pos , v4[i+1].pos ,v4[i].scale,v4[i+1].scale ),1.);\n  d5= synmin(d5,conecapsule( p,  v5[i].pos , v5[i+1].pos ,v5[i].scale,v5[i+1].scale ),1.);\n }\n float d=synmin(d1,min(  min(d3,d2), smin(d4,d5,1.0)),3.0);\n float z=p.z+93.;\n  \n float c1= mod( \n        mod (floor(p.x/30.),2.)+\n        mod (floor(p.y/30.),2.)+\n        mod (floor(p.z/30.),2.) ,2.);\n vec3 c2= vec3(0.9,  0.9, 0.8);\n vec3 c= d<z?c2:vec3(c1);\n return vec4(min(d,z) ,c)\n               ;\n\n }\n\n\nconst vec3 bbox_min = vec3(-7.363703305156273,-7.363703305156273,-7.363703305156273);\nconst vec3 bbox_max = vec3(7.363703305156273,7.363703305156273,7.363703305156273);\n// ray marching. ro is ray origin, rd is ray direction (unit vector).\n// result is (t,r,g,b), where\n//  * t is the distance that we marched,\n//  * r,g,b is the colour of the distance field at the point we ended up at.\n//    (-1,-1,-1) means no object was hit.\nvec4 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 700.0;\n   \n    float t = tmin;\n    vec3 c = vec3(-1.0,-1.0,-1.0);\n    for (int i=0; i<200; i++) {\n        float precis = 0.0005*t;\n        vec4 res = map( vec4(ro+rd*t,iTime) );\n        if (res.x < precis) {\n            c = res.yzw;\n            break;\n        }\n        t += res.x;\n        if (t > tmax) break;\n    }\n    return vec4( t, c );\n}\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( vec4(pos + e.xyy,iTime) ).x + \n                      e.yyx*map( vec4(pos + e.yyx,iTime) ).x + \n                      e.yxy*map( vec4(pos + e.yxy,iTime) ).x + \n                      e.xxx*map( vec4(pos + e.xxx,iTime) ).x );\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( vec4(aopos,iTime) ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n// in ro: ray origin\n// in rd: ray direction\n// out: rgb colour\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    //vec3 col = vec3(0.7, 0.9, 1.0) +rd.z*0.8;\n    //vec3 col = vec3(0.8, 0.9, 1.0);\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    vec4 res = castRay(ro,rd);\n    float t = res.x;\n    vec3 c = res.yzw;\n    if( c.x>=0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = mix(c,normalize(c),0.42);\n\n        // lighting        \n        float occ = calcAO( pos, nor );\n        vec3  lig = normalize( ro +vec3(0,10,10) );\n        float amb = clamp( 0.5+0.5*nor.z, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,lig.y,0.0))), 0.0, 1.0 )*clamp( 1.0-pos.z,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.z );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        vec3 lin = vec3(0.0);\n       lin += 1.30*dif*vec3(1.00,0.80,0.55);\n         lin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        //lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        // lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.35,0.35,0.35)*occ;\n        // lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n        vec3 iqcol = col*lin;\n\n        //col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n        col = mix(col,iqcol, 0.6);\n    }\n\n    return vec3( clamp(col,0.0,1.0) );\n}\n// Create a matrix to transform coordinates to look towards a given point.\n// * `eye` is the position of the camera.\n// * `centre` is the position to look towards.\n// * `up` is the 'up' direction.\nmat3 look_at(vec3 eye, vec3 centre, vec3 up)\n{\n    vec3 ww = normalize(centre - eye);\n    vec3 uu = normalize(cross(ww, up));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n// Generate a ray direction for ray-casting.\n// * `camera` is the camera look-at matrix.\n// * `pos` is the screen position, normally in the range -1..1\n// * `lens` is the lens length of the camera (encodes field-of-view).\n//   0 is very wide, and 2 is a good default.\nvec3 ray_direction(mat3 camera, vec2 pos, float lens)\n{\n    return normalize(camera * vec3(pos, lens));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 mo = (iMouse.xy/iResolution.xy);\n\n    const vec3 origin = (bbox_min + bbox_max) / 2.0 +vec3 (0,0,10);\n    const vec3 radius = (bbox_max - bbox_min) / 2.0;\n    float r = max(radius.x, max(radius.y, radius.z)) / 1.0;\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n      vec2 mouse = iMouse.xy / iResolution.xy;\n    //  vec3 eye = vec3 (cos (4. * mouse.x) * 67., sin (4. * mouse.x) *sin (4. * mouse.y) * 67., -cos (4. * mouse.y) * 67.);\n     //   vec3 ro =  vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.0*sin(0.1*time + 6.0*mo.x) );\n\n    vec3 eye = vec3(sin(iTime/1.2+6.*mo.x)*290., cos(iTime/1.43+6.*mo.x)*290., cos(iTime/3.+6.*mo.y)*126. +100.);\n    vec3 centre = vec3(0.0, 0.0, cos(iTime/2.1)*50. +50.0);\n    vec3 up = eye+ vec3(0.0, 0.0, 10.0);\n \n    mat3 camera = look_at(eye, centre, up);\n    vec3 dir = ray_direction(camera, p, 2.5);\n\n    vec3 col = render( eye, dir );\n    \n    // convert linear RGB to sRGB\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XttyDj",
    "date": "1534116851",
    "viewed": 104,
    "name": " smin3 - three way smin demo ",
    "description": "Slight expansion of https://www.shadertoy.com/view/4sSyRy\n1  To the left: regular nested smin, asymmetric result. (Thanks Doug for pointing this example out.)\n2  Middle: smin3 sorted nested smin acending order, rounded result\n3  Right:  -||- ..decending",
    "likes": 1,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "2d",
     "sort",
     "smin",
     "3way",
     "threeway"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define time iTime\n#define tau 6.28318530718\n\n//  Slight expansion of https://www.shadertoy.com/view/4sSyRy\n//  Symetric multi smin\n\n//  Expandable to any n distances if efficient sorting can be found.\n//  Really only the smallest 3-4 distances needs to be found to cover most cases. \n\n//  To the left: regular nested smin, asymmetric result. (Thanks Doug for pointing this example out.)\n//  Middle: smin3 sorted nested smin acending order, expected rounded result\n//  Right: smin3 sorted nested smin decending order, Blended but sharp result\n\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp(.5 + .5*(a-b)/k, 0., 1.);\n\treturn mix(a, b, h) - k*h*(1.-h);\n}\nfloat smin3maxfirst(float a, float b, float c, float k)\n{\n    float mini=min(a,min(b,c));\n    float maxi=max(a,max(b,c));\n\tfloat medi=(a+b+c)-(mini+maxi);\n    return smin( mini,smin(maxi, medi, k), k);  // combined from max to min \n    //return smin( maxi,smin(mini, medi, k), k); // gives diffrent result than from min to max\n    //return smin( a,smin(b,c, k), k); // Bad 3 way smin \n    \n}\nfloat smin3(float a, float b, float c, float k)\n{\n    float mini=min(a,min(b,c));\n    float maxi=max(a,max(b,c));\n\tfloat medi=(a+b+c)-(mini+maxi);\n   // return smin( mini,smin(maxi, medi, k), k);  // combined from max to min \n    return smin( maxi,smin(mini, medi, k), k); // gives diffrent result than from min to max\n    //return smin( a,smin(b,c, k), k); // Bad 3 way smin \n    \n}\nfloat smin3bad(float a, float b, float c, float k)\n{\n   // float mini=min(a,min(b,c));\n   // float maxi=max(a,max(b,c));\n   // float medi=(a+b+c)-(mini+maxi);\n   // return smin( mini,smin(maxi, medi, k), k);  // combined from max to min \n    //return smin( maxi,smin(mini, medi, k), k); // gives diffrent result than from min to max\n    return smin( a,smin(b,c, k), k); // Bad 3 way smin \n    \n}\n\n\n\nfloat map(vec2 uv)\n{float rs=0.75;\n    float rv=.125*rs;float rr=.5;\nfloat r=(abs(sin(time+3.) )*0.35+0.5)*rs;\n\tfloat ac0 = length(uv-vec2(0.,0.25)-vec2( r*rr*sin(1.*time),\t-r*rr*cos(1.*time)\t))-rv;\n\tfloat ac1 = length(uv-vec2(0.,0.25)-vec2( r*rr*sin(1.*time+tau/3.),\t-r*rr*cos(1.*time+tau/3.)\t))-rv;\n\tfloat ac2 = length(uv-vec2(0.,0.25)-vec2( r*rr*sin(1.*time+tau*2./3.),\t-r*rr*cos(1.*time+tau*2./3.)\t))-rv;\n\tfloat bc0 = length(uv-vec2(.75,-0.25)-vec2( r*rr*sin(1.*time),\tr*rr*cos(1.*time)\t))-rv;\n\tfloat bc1 = length(uv-vec2(.75,-0.25)-vec2( r*rr*sin(1.*time+tau/3.),\tr*rr*cos(1.*time+tau/3.)\t))-rv;\n\tfloat bc2 = length(uv-vec2(.75,-0.25)-vec2( r*rr*sin(1.*time+tau*2./3.),\tr*rr*cos(1.*time+tau*2./3.)\t))-.1;\n\tfloat cc0 = length(uv-vec2(-.75,-0.25)-vec2( r*rr*sin(1.*time),\tr*rr*cos(1.*time)\t))-rv;\n\tfloat cc1 = length(uv-vec2(-.75,-0.25)-vec2( r*rr*sin(1.*time+tau/3.),\tr*rr*cos(1.*time+tau/3.)\t))-rv;\n\tfloat cc2 = length(uv-vec2(-.75,-0.25)-vec2( r*rr*sin(1.*time+tau*2./3.),\tr*rr*cos(1.*time+tau*2./3.)\t))-rv;\nfloat prop1= smin3( ac0,ac1,ac2,.75*rs);\nfloat propmax= smin3maxfirst( bc0,bc1,bc2,.75*rs);\nfloat propbad= smin3bad( cc0,cc1,cc2,.75*rs);\n    return smin3(prop1,propmax,propbad,0.025);\n   // return prop1;\n}\n\nvec3 draw_line(float d, float thickness) {\n  const float aa = 3.0;\n  return vec3(smoothstep(0.0, aa / iResolution.y, max(0.0, abs(d) - thickness)));\n}\n\nvec3 draw_line(float d) {\n  return draw_line(d, 0.0025);\n}\n\nfloat draw_solid(float d) {\n  return smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));\n}\n\nvec3 draw_distance(float d) {\n  float t = clamp(d * 0.85, 0.0, 1.0);\n  vec3 grad = mix(vec3(1, 0.8, 0.5), vec3(0.3, 0.8, 1), t);\n\n  float d0 = abs(1.0 - draw_line(mod(d + 0.1, 0.2) - 0.1).x);\n  float d1 = abs(1.0 - draw_line(mod(d + 0.025, 0.05) - 0.025).x);\n  float d2 = abs(1.0 - draw_line(d).x);\n  vec3 rim = vec3(max(d2 * 0.85, max(d0 * 0.25, d1 * 0.06125)));\n\n  grad -= rim;\n  grad -= mix(vec3(0.05, 0.35, 0.35), vec3(0.0), draw_solid(d));\n\n  return grad;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((2.*fragCoord.xy-iResolution.xy)/iResolution.y)/1.4;\n\tfloat t = 1./iResolution.y;\n float d=map(uv);\n\tfloat c = smoothstep(-t,t,d)-length(uv)/8.;\n    \tfloat c1 = d;//smoothstep(-1.,1.,d)-length(uv)/8.;\n\t\tfragColor = mix(vec4(  c),vec4(   vec2(cos(c1*150.)),sign(d),1.),sin(iTime*.2)-.25);\n\n\t //fragColor =  vec4(   draw_distance(  d*2.),0.  );\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XltyWf",
    "date": "1543982346",
    "viewed": 101,
    "name": " synmin3 - three way symin demo ",
    "description": " some issues wit internal distances",
    "likes": 3,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "2d",
     "sort",
     "smin",
     "3way",
     "threeway"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \" smin3 - three way smin demo \" by TLC123. https://shadertoy.com/view/XttyDj\n// 2018-08-16 16:38:36\n\n#define time iTime\n#define tau 6.28318530718\n\n//  Slight expansion of https://www.shadertoy.com/view/4sSyRy\n//  Symetric multi smin\n\n//  Expandable to any n distances if efficient sorting can be found.\n//  Really only the smallest 3-4 distances needs to be found to cover most cases. \n\n//  To the left: regular nested smin, asymmetric result. (Thanks Doug for pointing this example out.)\n//  Middle: smin3 sorted nested smin acending order, expected rounded result\n//  Right: smin3 sorted nested smin decending order, Blended but sharp result\n\n\n//float smin(float a, float b, float k)\n//{\n//\tfloat h = clamp(.5 + .5*(a-b)/k, 0., 1.);\n//\treturn mix(a, b, h) - k*h*(1.-h);\n//}\nfloat  synmin(float a,float  b,float  r  ) {\n    // drop-in function for smin  \n\t float height=1.;\n     float width=1./18.;\n     float valleytreshold=0.4;\n        float  e =   max(valleytreshold,(abs(a-b)/r) );\n        return min (a,b)- max(width,   (r*height*e*(exp(1.0-(e*.25  ))))/max(a,b)*0.15)\n      \n \n            ;}\n \n \nfloat synmin3(float a, float b, float c, float k)\n{\n    float mini=min(a,min(b,c));\n    float maxi=max(a,max(b,c));\n\tfloat medi=(a+b+c)-(mini+maxi);\n   // return smin( mini,smin(maxi, medi, k), k);  // combined from max to min \n    return synmin( medi,  mini , k); // gives diffrent result than from min to max\n    //return smin( a,smin(b,c, k), k); // Bad 3 way smin \n    \n}\n \nfloat smin( float a, float b, float k )\n{    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);}\n\n \n\nfloat smin3maxfirst(float a, float b, float c, float k)\n{\n    float mini=min(a,min(b,c));\n    float maxi=max(a,max(b,c));\n\tfloat medi=(a+b+c)-(mini+maxi);\n    return smin( mini, (  maxi ), k);  // combined from max to min \n    //return smin( maxi,smin(mini, medi, k), k); // gives diffrent result than from min to max\n    //return smin( a,smin(b,c, k), k); // Bad 3 way smin \n    \n}\nfloat smin3(float a, float b, float c, float k)\n{\n    float mini=min(a,min(b,c));\n    float maxi=max(a,max(b,c));\n\tfloat medi=(a+b+c)-(mini+maxi);\n   // return smin( mini,smin(maxi, medi, k), k);  // combined from max to min \n    return smin( medi,  mini , k); // gives diffrent result than from min to max\n    //return smin( a,smin(b,c, k), k); // Bad 3 way smin \n    \n}\nfloat smin3bad(float a, float b, float c, float k)\n{\n   // float mini=min(a,min(b,c));\n   // float maxi=max(a,max(b,c));\n   // float medi=(a+b+c)-(mini+maxi);\n   // return smin( mini,smin(maxi, medi, k), k);  // combined from max to min \n    //return smin( maxi,smin(mini, medi, k), k); // gives diffrent result than from min to max\n    return smin( a,smin(b,c, k), k); // Bad 3 way smin \n    \n}\n\n \n\nfloat map(vec2 uv)\n{float rs=.65;\n    float rv=.125*rs;    float rrv=.25*rs;float rr=.5;float rrr=.25;\nfloat r1=(abs(sin(time+3.) )*0.35+0.5)*rs;\nfloat r2=(abs(sin(time+3.3) )*0.35+0.5)*rs;\nfloat r3=(abs(sin(time+3.9) )*0.35+0.5)*rs;\n\tfloat ac0 = length(uv-vec2(0.,0.29)-vec2( r1*rrr*sin(2.*-time),         \t-r1*rrr*cos(2.*-time)\t))-rrv;\n\tfloat ac1 = length(uv-vec2(0.,0.29)-vec2( r1*rrr*sin(2.*-time+tau/3.),\t    -r1*rrr*cos(2.*-time+tau/3.)\t))-rrv;\n\tfloat ac2 = length(uv-vec2(0.,0.29)-vec2( r1*rrr*sin(2.*-time+tau*2./3.),\t-r1*rrr*cos(2.*-time+tau*2./3.)\t))-rrv;\n\tfloat bc0 = length(uv-vec2(.5,-0.29)-vec2( r2*rr*sin(1.*time),\t             r2*rr*cos(1.*time)\t))-rv;\n\tfloat bc1 = length(uv-vec2(.5,-0.29)-vec2( r2*rr*sin(1.*time+tau/3.),\t     r2*rr*cos(1.*time+tau/3.)\t))-rv;\n\tfloat bc2 = length(uv-vec2(.5,-0.29)-vec2( r2*rr*sin(1.*time+tau*2./3.),\t r2*rr*cos(1.*time+tau*2./3.)\t))-.1;\n\tfloat cc0 = length(uv-vec2(-.5,-0.29)-vec2( r3*rr*sin(1.*time),\t             r3*rr*cos(1.*time)\t))-rv;\n\tfloat cc1 = length(uv-vec2(-.5,-0.29)-vec2( r3*rr*sin(1.*time+tau/3.),\t     r3*rr*cos(1.*time+tau/3.)\t))-rv;\n\tfloat cc2 = length(uv-vec2(-.5,-0.29)-vec2( r3*rr*sin(1.*time+tau*2./3.),\t r3*rr*cos(1.*time+tau*2./3.)\t))-rv;\nfloat prop1= min( min(ac0,ac1),ac2)-(sin(iTime/3.32)*0.5+.5)*0.09;\nfloat prop2= min( min(bc0,bc1),bc2)-(sin(iTime/7.2)*0.5+.5)*0.09;\nfloat prop3= min( min(cc0,cc1),cc2)-(sin(iTime/5.43)*0.5+.5)*0.09;\n    return synmin3(prop1,prop2,prop3,0.026);\n   // return prop1;\n}\n\nvec3 draw_line(float d, float thickness) {\n  const float aa = 3.0;\n  return vec3(smoothstep(0.0, aa / iResolution.y, max(0.0, abs(d) - thickness)));\n}\n\nvec3 draw_line(float d) {\n  return draw_line(d, 0.0025);\n}\n\nfloat draw_solid(float d) {\n  return smoothstep(0.0, 3.0 / iResolution.y, max(0.0, d));\n}\n\nvec3 draw_distance(float d) {\n  float t = clamp(d * 0.85, 0.0, 1.0);\n  vec3 grad = mix(vec3(1, 0.8, 0.5), vec3(0.3, 0.8, 1), t);\n\n  float d0 = abs(1.0 - draw_line(mod(d + 0.1, 0.2) - 0.1).x);\n  float d1 = abs(1.0 - draw_line(mod(d + 0.025, 0.05) - 0.025).x);\n  float d2 = abs(1.0 - draw_line(d).x);\n  vec3 rim = vec3(max(d2 * 0.85, max(d0 * 0.25, d1 * 0.06125)));\n\n  grad -= rim;\n  grad -= mix(vec3(0.05, 0.35, 0.35), vec3(0.0), draw_solid(d));\n\n  return grad;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = ((2.*fragCoord.xy-iResolution.xy)/iResolution.y)/1.4;\n\tfloat t = 1./iResolution.y;\n float d=map(uv);\n\tfloat c = smoothstep(-t,t,d)-length(uv)/8.;\n    \tfloat c1 = d;//smoothstep(-1.,1.,d)-length(uv)/8.;\n     float len = c1*1.5;\n    vec3 col = vec3(1.);\n\n        //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n        col = vec3(1.0) - sign(len) * vec3(0.1, 0.4, 0.7);\n        col *= 1.0 - exp(-iResolution.y * 0.008 * abs(len));\n        col *= 0.8 + 0.2 * cos(iResolution.y * 0.3 * abs(len));\n        col = mix(col, vec3(1.0), max(1.0 - abs(len) * iResolution.y * 0.2, 0.0));\n \n        fragColor = vec4(col  , 1.0);\n\t //fragColor =  vec4(   draw_distance(  d*2.),0.  );\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MlyfRW",
    "date": "1541954609",
    "viewed": 249,
    "name": "2 * 2d -> 3d  ",
    "description": "\nsweep one 2d shape on one other\nfor a combined  3d object ( X , Y , Z )\nuse one 2d SDF to find a 2D dist of  say ( X , Y )  then use that  with remaining axis Z to look up another 2d SDF  (dist , Z) \n",
    "likes": 20,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "2d",
     "sdf",
     "shape"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"The Walking Raymarcher\" by xorxor. https://shadertoy.com/view/Mt3XWH\n// 2018-11-11 15:37:21\n\n\n// tracer from  https://shadertoy.com/view/Mt3XWH\n// sdPentagon from https://www.shadertoy.com/view/llVyWW\n// roundrect forked fromm https://www.shadertoy.com/view/4sjyRz\n \nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return  (max(d.x,d.y) );\n}\n\n float sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528); // pi/5: cos, sin, tan\n\n    // reflections\n    p.y = -p.y;\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    \n\t// side of polygon\n    return length(p-vec2(clamp(p.x,-r*k.z,r*k.z),r))*sign(p.y-r);\n}\n\nfloat smin( float a, float b )\n{\n    const float k = .21;\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n    \n}\n\nfloat smax( float d1, float d2 ,float k ) {\n \n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\n\nfloat roundrect(vec2 p, vec2 c, vec2 r) {\n    \n    p = abs(p) - c +r ;\n\tif (p.x >= 0.0 && p.y >= 0.0)\n        return length(p)-r.x;\n    else\n        return max(p.x, p.y)-r.x;\n}\n\nfloat shape1(vec2 p){\n\nfloat d= sdPentagon(p-vec2(-2.+-2.*sin(iTime*4.),0),1.3);\n      d=smin(d, sdPentagon(p-vec2(2,0.+2.*sin(iTime*2.) ),1.3) );\n\n    d=smin(d,sdBox(p-vec2(0,-6),vec2(3) ) );\n\n    return (d );\n    }\nfloat shape2(vec2 p){\np=p+vec2(0.2+sin(iTime*3.)*2.,0);\n\nfloat d= roundrect(p-vec2(1.75,0),vec2(2.7,1.),vec2(.2));\n    \n    \n    d=min(d,roundrect(p-vec2(2.2,0),vec2(3.3,0.5),vec2(.2))  );\n    \n    \n    d=min(d,roundrect(p-vec2(-0.0,14),vec2(0.8,1),vec2(.3)));\n    d=min(d,roundrect(p-vec2(-0,7), vec2(1,7.),vec2(.6)));\n    d=min(d, length(p-vec2(1,1))-1.1);\n    d=smax(  (length(p-vec2(1.2,8))-.7),d,0.23);\n    d=smin(d, (length(p-vec2(1.0,5))-.6));\n      d=smax((length(p-vec2(3.1,11))-2.7),d,0.24);\n\n    \n    \n    return(d );\n        }\n\n\nvec2 map( vec3 p )\n{\n    float plane = abs( p.y + 0.9 );\n\n \n\n     \n   float w =  shape1(    p.xz);\n   float d =  shape2(vec2(w,p.y));\n    \n \n    return ( d < plane ) ? vec2( d, 1.0 ) : vec2( plane, 2.0 );\n}\n\nfloat calcShadow( vec3 ro, vec3 rd, float mint, float maxt )\n{\n    float t = mint;\n    float res = 1.0;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float h = map( ro + rd * t ).x;\n        res = min( res, 1.1 * h / t );\n        t += h;\n        if ( ( h < 0.001 ) || ( t > maxt ) )\n        {\n            break;\n        }\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec2 trace( vec3 ro, vec3 rd )\n{\n    const float kTMin = 0.01;\n    const float kTMax = 200.0;\n    const float kEps = 0.001;\n\n    float t = kTMin;\n    vec2 res;\n    for ( int i = 0; i < 70; i++ )\n    {\n        vec3 pos = ro + rd * t;\n        res = map( pos );\n        if ( ( res.x < kEps ) || ( t > kTMax ) )\n        {\n            break;\n        }\n        t += res.x * 0.5;\n    }\n\n    if ( t < kTMax )\n    {\n        return vec2( t, res.y );\n    }\n    else\n    {\n        return vec2( -1.0 );\n    }\n}\n\nvec3 calcNormal( vec3 p )\n{\n    const vec2 e = vec2( 0.005, 0 );\n    float dp = map( p ).x;\n    return normalize( vec3( dp - map( p - e.xyy ).x,\n                            dp - map( p - e.yxy ).x,\n                            dp - map( p - e.yyx ).x ) );\n}\n\nmat3 calcCamera( vec3 eye, vec3 target )\n{\n    vec3 cw = normalize( target - eye );\n    vec3 cu = cross( cw, vec3( 0, 1, 0 ) );\n    vec3 cv = cross( cu, cw );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n    vec2 mo = vec2( 0.95, -0.2 );\n    if ( iMouse.z > 0.5 )\n    {\n        mo = 10.0 * iMouse.xy / iResolution.xy - 1.0;\n        mo *= 3.14159 * vec2( 0.4, 0.1 );\n    }\n    mo += 3.14159 * 2.5;\n\n    vec3 eye = vec3( 40.0 * cos( mo.x ), 30.0 + 20.0 * cos( mo.y ), 40.0 * sin( mo.x ) );\n    vec3 target = vec3( 0.0, 6.0, 0.0 );\n    \n    mat3 cam = calcCamera( eye, target );\n\n \tvec2 uv = ( fragCoord.xy - 0.5 * iResolution.xy ) / iResolution.y;\n    vec3 rd = cam * normalize( vec3( uv, 2.0 ) );\n\n    vec3 col = vec3( 1.0 );\n    \n    vec2 res = trace( eye, rd );\n    if ( res.x > 0.0 )\n    {\n        vec3 pos = eye + rd * res.x;\n        vec3 nor = calcNormal( pos );\n        vec3 ldir = normalize( vec3( -10.5, 20.8, 24.0 ) );\n        \n        if ( res.y < 1.5 )\n        {\n        \tcol = 0.5 + 0.5 * nor;\n            float dif = max( dot( nor, ldir ), 0.0 );\n            vec3 ref = reflect( rd, nor );\n            float spe = pow( clamp( dot( ref, ldir ), 0.0, 1.0 ), 15.0 );\n\n            col *= ( 0.3 + 0.7 * dif );\n            float edge = pow( 1.0 - dot( -rd, nor ), 1.1 );\n        \tcol += 0.8 * edge + spe;\n        }\n      \n        float sh = calcShadow( pos, ldir, 0.1, 30.0 );\n        col *= ( 0.5 + sh );\n    }\n    \n    \n    \n    \n    if (fract(iTime/10.)<0.33) {\n       // col=vec3( shape1(uv*20.-vec2(0,4))>0. )\n            \n                float len = shape1(uv*20.-vec2(0,4))/10.;\n    \n    //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n       col = vec3(1.0) - sign(len)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-iResolution.y*0.008*abs(len));\n\tcol *= 0.8 + 0.2*cos(iResolution.y*0.3*abs(len));\n\tcol = mix( col, vec3(1.0), max(1.0-abs(len)*iResolution.y*0.2,0.0));\n\tfragColor = vec4(col*col, 1.0);\n            }\n    if (fract(iTime/10.)<0.165) {\n          // col=vec3( shape2(uv*20.-vec2(0,-8))>0. );\n\n            float len = shape2(uv*20.-vec2(0,-7))/10.;\n    \n    //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n       col = vec3(1.0) - sign(len)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-iResolution.y*0.008*abs(len));\n\tcol *= 0.8 + 0.2*cos(iResolution.y*0.3*abs(len));\n\tcol = mix( col, vec3(1.0), max(1.0-abs(len)*iResolution.y*0.2,0.0));\n\t\tif (abs(uv.x)<0.005)col=vec3(1.);\n\n\tfragColor = vec4(col*col, 1.0);   \n    }\n    fragColor = vec4( col, 1.0 );\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4t3fDf",
    "date": "0",
    "viewed": 0,
    "name": "2D Patterns",
    "description": "Pattern Lab",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "2d"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define PI2 6.28318530718\n#define N(v) (v.yx*vec2(1,-1))\n#define CS(x) sin(x+vec2(PI2/4.,0))\n\n\nvec2 horizontalflip (vec2 p);\nbool mirrorstamp (vec2 p);\nvec2 verticalflip (vec2 p);\nvec2 slashdiagonalflip (vec2 p);\nvec2 backslashdiagonalflip (vec2 p);\nvec2 slashmirror (vec2 p);\n vec2 backslashmirror (vec2 p);\nbool  backslash (vec2 p);\n\nbool tresholdRound (float value, float treshold);\nbool stamp (bool a , bool b);\nbool banding (float value, float bandWidth ,float parting);\nbool unitmask (vec2 p,bool v);\nbool horizontalBand(vec2 p);\nbool verticalBand(vec2 p);\nbool triChess(vec2 p) ;\nbool harlequin(vec2 p);\nbool chess(vec2 p);\nbool twodots(vec2 p);\nbool square(vec2 p);\nbool bandSquare(vec2 p);\nbool circle(vec2 p,float r);\nbool bandcircle(vec2 p);\nvec2 xReflect (vec2 p);\nvec2 yReflect (vec2 p);\nvec2 xyReflect (vec2 p);\nvec2 xyRepeat (vec2 p,vec2 spacing);\nvec2 xRepeat (vec2 p,  float spacing);\nvec2 xRepeatmirror (vec2 p,  float spacing);\nvec3 map(vec2 p);\n\n \n\n\n\nbool tresholdRound (float value, float treshold) {return (value>=treshold);}\n\nbool stamp (bool a , bool b)\n{ return a&&b; }\n\nbool banding (float value, float bandWidth ,float parting) \n{return tresholdRound (  mod(value,bandWidth) ,   parting*bandWidth) ;}\n\nbool unitmask (vec2 p,bool v)\n{\n    return  (p==clamp(p,0.,1.)?v:true); \n}\n\nbool horizontalBand(vec2 p){return banding( p.x,1.0,0.5);}\n \nbool verticalBand(vec2 p)  {return banding( p.y,1.0,0.5);}\n  \n\n//  triange patterns\n bool triChess(vec2 p)   \n{\n  vec2 d = vec2(p.x,p.y * 0.866 + p.x * 0.5);\n   return (fract(d.y) > fract(d.x)?true:false);\n} \n\nbool harlequin(vec2 p)   \n{\n  vec2 d = vec2(p.x * 0.866 + p.y * 0.5,p.y);\n   return (fract(d.y) > fract(d.x)^^(mod(d.y,2. )>= 1.)?true:false);\n}\n  \n\n//  hexgonal patterns\n\n\n//unit square patterns\n    \nbool mirrorstamp (vec2 p)\n{\nreturn   (\n    twodots(p)\n    //&& twodots( horizontalflip ( p ) )\n    //&& twodots(  slashdiagonalflip (horizontalflip ( p ) )  )\n    && twodots(    ( backslashdiagonalflip (p ) )  )\n   // && twodots(  backslashdiagonalflip ( slashdiagonalflip (p ) )  )\n   // &&twodots( horizontalflip (verticalflip (p ) ))\n);\n}\n\n \n    \n \nbool chess(vec2 p){ return  bool(\n    tresholdRound(fract(p.x),0.5)^^\n    tresholdRound(fract(p.y),0.5));}\n\nbool twodots(vec2 p){return\n     (\n     circle(p-vec2(0.40,0.45),.12)\n     &&circle(p-vec2(0.10,0.23),.15)    \n     &&circle(p-vec2(0.37,0.15),.10)    \n    );}\n\nbool square(vec2 p){ return  bool(\ntresholdRound (max(abs(p.x-0.5),abs(p.y-0.5)),0.5) );}\n\nbool bandSquare(vec2 p){ \n    bool b=  bool(    banding(max(abs(p.x-0.5),abs(p.y-0.5)),0.1,0.5) );\n    \n    return unitmask(p,b)  \n    ;}\n\nbool circle(vec2 p,float r){ return  \n    tresholdRound(length(p),r) ;}\n\nbool bandcircle(vec2 p){ return  \n    banding(length(p-vec2(0.5)),0.10,0.5) ;}\n\n\n\n\nvec2 horizontalflip (vec2 p){\n    vec2 v = vec2(-(p.x-0.5)+0.5,p.y);\n    return v ;\n}\n\nvec2 verticalflip (vec2 p){\n    vec2 v = vec2(p.x,-(p.y-0.5)+0.5 );\n    return v ;\n}\n\nvec2 slashdiagonalflip (vec2 p){\n    vec2 v = vec2((p.y-0.5)+0.5,(p.x-0.5)+0.5);\n    return v ;\n}\n\nvec2 backslashdiagonalflip (vec2 p){\n    vec2 v = vec2(-(p.y-0.5)+0.5,-(p.x-0.5)+0.5);\n    return v ;\n}\n\nvec2 slashmirror (vec2 p)\n{\nreturn p.x>p.y?p:p.yx;\n\n}\n\n vec2 backslashmirror (vec2 p)\n{\n return  (p.x  >  1. - p.y)? vec2(1.-p.y ,   1.-p.x ) :p;\n\n} \nbool backslash  (vec2 p)\n{\nreturn  p.x>-p.y?true:false;\n\n}\n\nvec2 xReflect (vec2 p){\n    vec2 v = vec2(-abs(p.x-0.5)+.5,p.y);\n    return v ;\n}\nvec2 yReflect (vec2 p){\n    vec2 v = vec2(p.x,abs(p.y));\n    return v ;\n}\nvec2 xyReflect (vec2 p){\n    vec2 v = vec2(\n       -abs(p.x-0.5)+.5,\n        -abs(p.y-0.5)+.5\n    )\n        \n        ;\n    return v ;\n}\nvec2 xyRepeat (vec2 p,vec2 spacing){\n    vec2 v = vec2 ( fract(p.x/spacing.x)*spacing.x,fract(p.y/spacing.y)*spacing.y);\n    return v ;\n}\nvec2 xRepeatmirror (vec2 p,  float spacing){\n    vec2 v = vec2 ( min(\n    fract(p.x/(spacing*2.))*(spacing*2.), \n    (spacing*2.)-fract(p.x/(spacing*2.))*(spacing*2.)\n      ) , \n       \n        (p.y ));\n    return v ;\n}\n\n\nvec2 xyRepeatmirror (vec2 p,  vec2 spacing){\n    vec2 v = vec2 ( min(\n    fract(p.x/(spacing.x*2.))*(spacing.x*2.), \n    (spacing.x*2.)-fract(p.x/(spacing.x*2.))*(spacing.x*2.)\n      ) , \n       \n        min(\n     fract(p.y/(spacing.y*2.))*(spacing.y*2.), \n    2.-fract(p.y/(spacing.y*2.))*(spacing.y*2.)\n      )   );\n    return v ;\n}\n\n\n\nvec3 map(vec2 p)\n{\n   // p= xRepeat (p, vec2(3.,2.));\n    p= xyRepeatmirror (p,  vec2(1.1  ,1.1));\n  return \n        vec3(    unitmask(p,      \n   twodots(slashmirror(xReflect( backslashmirror(p)))) \n         //&&   chess(backslashmirror(yReflect(p))                    )\n                         ) \n            \n            );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 Res=iResolution.xy;\n        float gscale=.6;\n\n      float mspeed=.5;\n   // fragCoord = (fragCoord-Res*.5)*gscale-Res*.5;\n    vec2 cs = CS(sin(iTime*mspeed*.13));\n    //fragCoord = mat2(cs,N(cs))*(fragCoord-Res*.5);\n    \n    //fragCoord+=100.*sin(vec2(0,1.6)+.33*iTime*mspeed);\n    //fragCoord+=70.*iTime*mspeed;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.y*5.;\n\n    // Time varying pixel color\n    vec3 col = map(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n ",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "ltGfD1",
    "date": "0",
    "viewed": 0,
    "name": "2D Patterns 30",
    "description": "Pattern Lab",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "2d"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//https://www.shadertoy.com/view/MlKcDD\n//https://www.shadertoy.com/view/4ldXzf\n//https://www.shadertoy.com/view/MtjGz3\n\n\n#define PI2 6.28318530718\n#define N(v) (v.yx*vec2(1,-1))\n#define CS(x) sin(x+vec2(PI2/4.,0))\n// signed distance to a quadratic bezier\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C)\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\nvec2 fan(  vec2 pos,   float q) \n{\n    q = q / 180. * 3.14159265;\n    float ang = atan(pos.x, pos.y),\n    len = length(pos.xy);\n    ang = mod(ang + q/2., q) - q/2.;\n    pos.xy = len * vec2(sin(ang), cos(ang));\n    return pos;\n}\n\n/** repeat the position in 'pos' every 'q' units */\nvec2 repeat(  vec2 pos,   vec2 q) \n{\n    pos.xy = mod(pos.xy + q/2., q) - q/2.;\n    return pos;\n}\n\nvec2 mirror( vec2 p, vec2 v1, vec2 v2 )\n{\n \tvec2   s = v2-v1 ,\n           n = normalize(vec2( s.y, -s.x )) ;\n    float  d = dot(p-v1,n) ;\n    \n    return p-max(0.0,2.0*d)*n ;\n}\n\n\nvec3 map(vec2 p)\n{      \n\n    p=repeat( p,  vec2(9)); \n    p=mirror( p, vec2 (0,4), vec2 (1,4)); \n    \n    \n      p=repeat( p,  vec2(3)); \n    p=mirror( p, vec2 (0,0), vec2 (1,1)); \n    \n      p=repeat( p,  vec2(1.5)); \n    p=fan( p, 60.); \n    \n    \n//p=fan( p ,  (30.)); \n\n //  p=repeat( p,  vec2(2.5,2)); \n//   p=fan( p ,  (120.));       \n\n \n    //  p=mirror( p, vec2 (0,0), vec2 (sin(30.),cos(30.) )); \n\n // p=mirror( p, vec2 (-.3,0), vec2 (0,-2) ); \n//  p=mirror( p, vec2 (0,0), vec2 (1,0) ); \n\n    \n    vec2 A=vec2(0.1,0.3);\n    vec2 B=vec2(0.0,0.8);\n    vec2 C=vec2(0.4,0.8);\n float   d=  sdBezier(p,   A,   B,  C);\n       return vec3( trunc (d+0.9));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 Res=iResolution.xy;\n        float gscale=.1;\n\n      float mspeed=.5;\n   // fragCoord = (fragCoord-Res*.5)*gscale-Res*.5;\n    vec2 cs = CS(sin(iTime*mspeed*.13));\n    //fragCoord = mat2(cs,N(cs))*(fragCoord-Res*.5);\n    \n    //fragCoord+=100.*sin(vec2(0,1.6)+.33*iTime*mspeed);\n    //fragCoord+=70.*iTime*mspeed;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.y*15.;\n\n    // Time varying pixel color\n    vec3 col = map(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n ",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XtyBzD",
    "date": "0",
    "viewed": 0,
    "name": "2D Patterns right",
    "description": "Pattern Lab",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "2d"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"2D Patterns\" by None. https://shadertoy.com/view/-1\n// 2018-11-11 11:37:51\n\n#define PI2 6.28318530718\n#define N(v) (v.yx*vec2(1,-1))\n#define CS(x) sin(x+vec2(PI2/4.,0))\n\n\nvec2 horizontalflip (vec2 p);\nbool mirrorstamp (vec2 p);\nvec2 verticalflip (vec2 p);\nvec2 slashdiagonalflip (vec2 p);\nvec2 backslashdiagonalflip (vec2 p);\nvec2 slashmirror (vec2 p);\n vec2 backslashmirror (vec2 p);\nbool  backslash (vec2 p);\n\nbool tresholdRound (float value, float treshold);\nbool stamp (bool a , bool b);\nbool banding (float value, float bandWidth ,float parting);\nbool unitmask (vec2 p,bool v);\nbool horizontalBand(vec2 p);\nbool verticalBand(vec2 p);\nbool triChess(vec2 p) ;\nbool harlequin(vec2 p);\nbool chess(vec2 p);\nbool twodots(vec2 p);\nbool square(vec2 p);\nbool bandSquare(vec2 p);\nbool circle(vec2 p,float r);\nbool bandcircle(vec2 p);\nvec2 xReflect (vec2 p);\nvec2 yReflect (vec2 p);\nvec2 xyReflect (vec2 p);\nvec2 xyRepeat (vec2 p,vec2 spacing);\nvec2 xRepeat (vec2 p,  float spacing);\nvec2 xRepeatmirror (vec2 p,  float spacing);\nvec3 map(vec2 p);\n\n \n\n\n\nbool tresholdRound (float value, float treshold) {return (value>=treshold);}\n\nbool stamp (bool a , bool b)\n{ return a&&b; }\n\nbool banding (float value, float bandWidth ,float parting) \n{return tresholdRound (  mod(value,bandWidth) ,   parting*bandWidth) ;}\n\nbool unitmask (vec2 p,bool v)\n{\n    return  (p==clamp(p,0.,1.)?v:true); \n}\n\nbool horizontalBand(vec2 p){return banding( p.x,1.0,0.5);}\n \nbool verticalBand(vec2 p)  {return banding( p.y,1.0,0.5);}\n  \n\n//  triange patterns\n bool triChess(vec2 p)   \n{\n  vec2 d = vec2(p.x,p.y * 0.866 + p.x * 0.5);\n   return (fract(d.y) > fract(d.x)?true:false);\n} \n\nbool harlequin(vec2 p)   \n{\n  vec2 d = vec2(p.x * 0.866 + p.y * 0.5,p.y);\n   return (fract(d.y) > fract(d.x)^^(mod(d.y,2. )>= 1.)?true:false);\n}\n  \n\n//  hexgonal patterns\n\n\n//unit square patterns\n    \nbool mirrorstamp (vec2 p)\n{\nreturn   (\n    twodots(p)\n    //&& twodots( horizontalflip ( p ) )\n    //&& twodots(  slashdiagonalflip (horizontalflip ( p ) )  )\n    && twodots(    ( backslashdiagonalflip (p ) )  )\n   // && twodots(  backslashdiagonalflip ( slashdiagonalflip (p ) )  )\n   // &&twodots( horizontalflip (verticalflip (p ) ))\n);\n}\n\n \n    \n \nbool chess(vec2 p){ return  bool(\n    tresholdRound(fract(p.x),0.5)^^\n    tresholdRound(fract(p.y),0.5));}\n\nbool twodots(vec2 p){return\n     (\n     circle(p-vec2(0.40,0.45),.12)\n     &&circle(p-vec2(0.10,0.23),.15)    \n     &&circle(p-vec2(0.37,0.15),.10)    \n    );}\n\nbool square(vec2 p){ return  bool(\ntresholdRound (max(abs(p.x-0.5),abs(p.y-0.5)),0.5) );}\n\nbool bandSquare(vec2 p){ \n    bool b=  bool(    banding(max(abs(p.x-0.5),abs(p.y-0.5)),0.1,0.5) );\n    \n    return unitmask(p,b)  \n    ;}\n\nbool circle(vec2 p,float r){ return  \n    tresholdRound(length(p),r) ;}\n\nbool bandcircle(vec2 p){ return  \n    banding(length(p-vec2(0.5)),0.10,0.5) ;}\n\n\n\n\nvec2 horizontalflip (vec2 p){\n    vec2 v = vec2(-(p.x-0.5)+0.5,p.y);\n    return v ;\n}\n\nvec2 verticalflip (vec2 p){\n    vec2 v = vec2(p.x,-(p.y-0.5)+0.5 );\n    return v ;\n}\n\nvec2 slashdiagonalflip (vec2 p){\n    vec2 v = vec2((p.y-0.5)+0.5,(p.x-0.5)+0.5);\n    return v ;\n}\n\nvec2 backslashdiagonalflip (vec2 p){\n    vec2 v = vec2(-(p.y-0.5)+0.5,-(p.x-0.5)+0.5);\n    return v ;\n}\n\nvec2 slashmirror (vec2 p)\n{\nreturn p.x>p.y?p:p.yx;\n\n}\n\n vec2 backslashmirror (vec2 p)\n{\n return  (p.x  >  1. - p.y)? vec2(1.-p.y ,   1.-p.x ) :p;\n\n} \nbool backslash  (vec2 p)\n{\nreturn  p.x>-p.y?true:false;\n\n}\n\nvec2 xReflect (vec2 p){\n    vec2 v = vec2(-abs(p.x-0.5)+.5,p.y);\n    return v ;\n}\nvec2 yReflect (vec2 p){\n    vec2 v = vec2(p.x,abs(p.y));\n    return v ;\n}\nvec2 xyReflect (vec2 p){\n    vec2 v = vec2(\n       -abs(p.x-0.5)+.5,\n        -abs(p.y-0.5)+.5\n    )\n        \n        ;\n    return v ;\n}\nvec2 xyRepeat (vec2 p,vec2 spacing){\n    vec2 v = vec2 ( fract(p.x/spacing.x)*spacing.x,fract(p.y/spacing.y)*spacing.y);\n    return v ;\n}\nvec2 xRepeatmirror (vec2 p,  float spacing){\n    vec2 v = vec2 ( min(\n    fract(p.x/(spacing*2.))*(spacing*2.), \n    (spacing*2.)-fract(p.x/(spacing*2.))*(spacing*2.)\n      ) , \n       \n        (p.y ));\n    return v ;\n}\n\n\nvec2 xyRepeatmirror (vec2 p,  vec2 spacing){\n    vec2 v = vec2 ( min(\n    fract(p.x/(spacing.x*2.))*(spacing.x*2.), \n    (spacing.x*2.)-fract(p.x/(spacing.x*2.))*(spacing.x*2.)\n      ) , \n       \n        min(\n     fract(p.y/(spacing.y*2.))*(spacing.y*2.), \n    2.-fract(p.y/(spacing.y*2.))*(spacing.y*2.)\n      )   );\n    return v ;\n}\n\n\n\nvec3 map(vec2 p)\n{\n  \n       return vec3(tresholdRound(fract(max(fract(p.x+p.y),fract(-p.x+p.y))*3.3),0.53)  );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 Res=iResolution.xy;\n        float gscale=.6;\n\n      float mspeed=.5;\n   // fragCoord = (fragCoord-Res*.5)*gscale-Res*.5;\n    vec2 cs = CS(sin(iTime*mspeed*.13));\n    //fragCoord = mat2(cs,N(cs))*(fragCoord-Res*.5);\n    \n    //fragCoord+=100.*sin(vec2(0,1.6)+.33*iTime*mspeed);\n    //fragCoord+=70.*iTime*mspeed;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-(iResolution.xy/2.))/iResolution.y*5.;\n\n    // Time varying pixel color\n    vec3 col = map(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n ",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tlXXWs",
    "date": "1564602936",
    "viewed": 347,
    "name": "2d  grass texture with a twist",
    "description": "2d texture from https://www.shadertoy.com/view/WsSGWd \tCreated by BynaryCobweb\n Strand directionality and length is determined by the angle between the ground and ray direction\nSome rotor wash artifacts on closeup and obviously nothing on the ridges. \n\n\n",
    "likes": 10,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "2d",
     "texture",
     "grass"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Procedural walk animation\" by None. https://shadertoy.com/view/-1\n// 2019-07-31 19:07:24\n\n \n\n#define AA 1\n# define PI 3.14159265359\n# define PHI 1.618033988749895\n# define TAU 6.283185307179586\n \n# define PLOTPATH 0\n \nvec2 UV;\n//------------------------------------------------------------------\nfloat sdPlane(vec3 p) {\n    return p.y;}\n \n\nfloat pathterrain(float x,float z){\n    // Common height function for path and terrain\n    return (\n        abs(sin(x*.5 )*1.+cos(z*.3 )*0.6)\n        +abs(cos(x*3.+z )*0.1+sin(x-z*.2 )*0.4))*.7\n         ;}\n vec3 timefly(float t) {\n    // main path Called from many places\n    t*=.80;\n\tt += (.125 + sin(t * .125));\n\tvec3 v =\n\tvec3(sin(t / 50.) * 20., 0., cos(t / 25.) * 24.) +\n\t\tvec3(sin(t / 17.1) * 07., 0., cos(t / 17.1) * 05.) +\n\t\tvec3(sin(t / 8.1) * 6., 0., cos(t / 8.1) * 8.) +\n\t\tvec3(cos(t / 3.) * 3.,0., sin(t / 3.) * 2.)\n        +vec3(cos(t  )*2.,0., sin(t  )*2. );\n    v.y=pathterrain(v.x,v.z);\n    return v        ;\n} \n \n\n\nfloat lpnorm(vec3 p, float s) {\n\treturn pow(\n\t\t(\n\t\t\tpow(abs(p.x), s) +\n\t\t\tpow(abs(p.y), s) +\n\t\t\tpow(abs(p.z), s)),\n\t\t1.0 / s);\n}\n\n \n//------------------------------------------------------------------\n \n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r) {\n    return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat TTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\nfloat sdPlane(vec3 p, vec4 n) {\n    // n must be normalized\n    return dot(p, n.xyz) + n.w;\n}\nfloat opSubtraction(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat opOnion( in float sdf, in float thickness) {\n    return abs(sdf) - thickness;\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n//----------------------------------------------------------------------\n\n//----------------------------------------------------------------------\n\n \n        \n\nfloat plant( in vec3 pos, vec4 type) {\n    float l =  length(pos.xz)*max(1.,abs( 4.* pos.y-1.)) ;\n    pos=pos\n        +vec3(l,0,l)*(0.2+sin(pos.x+pos.y+iTime*0.6)*0.2)\n        +vec3(0,l,0)*(0.1+sin(pos.y+iTime*1.6)*0.1)\n                     ;\n    float d, di, plane, lay;\n    d = l;\n    if ((l - type.w) < 0.) {\n\n        for (float i = 0.3; i < 0.28+type.w*0.5; i += +(.101*1./3.)) {\n\n            di = sdTorus(pos + vec3(0, -i * type.z*0.6, 0), vec2(0.18 * type.w + i * type.y, i * 1.5*type.z * type.w));\n\n            di = opOnion(di, type.x * 0.125 * type.w);\n            lay = i * (23.416 * 1.7);\n            plane = sdPlane(vec3(pos.x, pos.y, pos.z), vec4(sin(lay), 0, cos(lay), (-0.5+fract(lay*10.))*0.5*type.x));\n            di = opIntersection(di,\n\n                abs(plane)   -  ( sin(clamp( (min(l,type.w)/type.w )*7.28,.3,6.28) ))*type.x);\n\n            d = min(d, di);\n            if(d<0.01)break;\n\n        }\n        d = opIntersection(d, sdSphere(pos + vec3(0, -type.w * 0.9, 0), type.w));\n\n    }\n\n    return d;\n}\n//-------------------------------------------\nvec2 foliage( in vec3 pos) {\n    \n    pos.y=pos.y-pathterrain(pos.x,pos.z);\n    \n    float Strand, Spread, Lift, Size;\n    float sqr = 1.;\n    float d = length(pos.xz)+1.;\n    vec3 pfract = fract(pos / sqr) * sqr;\n    vec3 pround = round(pos / sqr) * sqr + vec3(sqr * 0.5, 0, sqr * 0.5);\n    vec3 mos = vec3(pfract.x, pos.y, pfract.z);\n\n    float i = (pos - pfract).x;\n    float j = (pos - pfract).z;\n\n    Strand = 0.01 + fract( sin(i * 12. + j*9.9) * 9.219869) * 0.0325;\n    Spread = 0. + fract( sin (i * 12. + j*9.9) * 99.24927) * .3;\n    Lift = .2 + fract(  sin(i * 42. + j*32.9) * 199.210930) * .5;\n    Size = .2 + fract( sin (i * 2. + j) * 99.) * .7;\n\n    d = min(d, plant(mos - vec3(sqr * 0.5, 0., sqr * 0.5), vec4(Strand, Spread * 1.1, Lift, Size)));\n\n      d = max(d, -(length(pfract.xz - vec3(sqr * 0.5, 0., sqr * 0.5).xz) -0.01));\n\n    return vec2(d, 3);\n\n} \n \nvec2 map( in vec3 pos) {\n\tvec2 res = vec2(pos.y-pathterrain(pos.x,pos.z), 1.0);\n\t//vec2 bush =  foliage(pos);\n    //res=res.x<bush.x?res:bush;\n    \n \treturn res;\n}\n\n\n\n\n\n\nvec2 castRay( in vec3 ro, in vec3 rd) {\n\tfloat tmin = .10;\n\tfloat tmax = 50.0;\n\tfloat t = tmin;\n\tfloat m = -1.0;\n\tfor (int i = 0; i < 80; i++) {\n\t\tfloat precis = 0.0001 * t;\n\t\tvec2 res = map(ro + rd * t);\n\t\tif (res.x < precis || t > tmax) break;\n\t\tt += res.x * .7;\n\t\tm = res.y;\n\t}\n\tif (t > tmax) m = -1.0;\n\treturn vec2(t, m);\n}\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor (int i = 0; i < 32; i++) {\n\t\tfloat h = map(ro + rd * t).x;\n\t\tres = min(res, 8.0 * h / t);\n\t\tt += clamp(h, 0.02, 0.10);\n\t\tif (res < 0.005 || t > tmax) break;\n\t}\n\treturn clamp(res, 0.0, 1.0);\n}\nvec3 calcNormal( in vec3 pos) {\n\tvec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n\treturn normalize(e.xyy * map(pos + e.xyy).x +\n\t\te.yyx * map(pos + e.yyx).x +\n\t\te.yxy * map(pos + e.yxy).x +\n\t\te.xxx * map(pos + e.xxx).x);\n}\nfloat calcAO( in vec3 pos, in vec3 nor) {\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n\t\tfloat hr = 0.01 + 0.12 * float(i) / 4.0;\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = map(aopos).x;\n\t\tocc += -(dd - hr) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n \n//------------------------------------------------------------------\n// 2d Grass texture from https://www.shadertoy.com/view/WsSGWd \tCreated by BynaryCobweb\n//------------------------------------------------------------------\n\n\n\n#define BLADES_SPACING 0.003\n#define JITTER_MAX 0.004\n// depends on size of grass blades in pixels\n#define LOOKUP_DIST 5\n\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\n \n//----------------------------------------------------------------------------------------\n// Hash without Sine  https://www.shadertoy.com/view/4djSRW\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n\n\n\n//----------------------------------------------------------------------------------------\n//// Created by inigo quilez - iq/2014\n//----------------------------------------------------------------------------------------\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat noise13( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( \n        mix(\n                mix( hash13( i + vec3(0.0,0.0,0.0) ), \n                     hash13( i + vec3(1.0,0.0,0.0) ), u.x),\n                mix( hash13( i + vec3(0.0,1.0,0.0) ), \n                     hash13( i + vec3(1.0,1.0,0.0) ), u.x)\n               , u.y),\n              mix(\n                mix( hash13( i + vec3(0.0,0.0,1.0) ), \n                     hash13( i + vec3(1.0,0.0,1.0) ), u.x),\n                mix( hash13( i + vec3(0.0,1.0,1.0) ), \n                     hash13( i + vec3(1.0,1.0,1.0) ), u.x)\n               , u.y)\n        \n         , u.z)\n        ;\n}\n\nvec3 noise33(  vec3 p )\n{\n    p=p+10000.;\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u;\n    u.x = f.x*f.x*(3.0-2.0*f.x);\n    u.y = f.y*f.y*(3.0-2.0*f.y);\n    u.z = f.z*f.z*(3.0-2.0*f.z);\n\n    return mix( \n        mix(\n                mix( hash33( i + vec3(0.0,0.0,0.0) ), \n                     hash33( i + vec3(1.0,0.0,0.0) ), u.x),\n                mix( hash33( i + vec3(0.0,1.0,0.0) ), \n                     hash33( i + vec3(1.0,1.0,0.0) ), u.x)\n               , u.y),\n              mix(\n                mix( hash33( i + vec3(0.0,0.0,1.0) ), \n                     hash33( i + vec3(1.0,0.0,1.0) ), u.x),\n                mix( hash33( i + vec3(0.0,1.0,1.0) ), \n                     hash33( i + vec3(1.0,1.0,1.0) ), u.x)\n               , u.y)\n        \n         , u.z)\n        ;\n}\nvec3 fbm33( vec3 p )\n{\n   \n     mat3 m = mat3(vec3(0.80,  0.60, -0.6).xyz,\n                    vec3(0.80,  0.60, -0.6).yzx,\n                    vec3(0.80,  0.60, -0.6).zxy);\n    vec3 f = vec3(0.0);\n    f += 0.5000*noise33( p ); p = m*p*2.02;\n    f += 0.2500*noise33( p ); p = m*p*2.03;\n    f += 0.1250*noise33( p ); p = m*p*2.01;\n    f += 0.0625*noise33( p );\n    return f/0.9375;\n}\n\nvec3 getGrassColor(float x) {\n     vec3 a = vec3(0.3, 0.3, 0.3);\n    vec3 b = vec3(0.4, 0.5, 0.2);\n    vec3 c = vec3(0.2, 0.4, 0.2);\n    vec3 d = vec3(0.66, 0.77, 0.33);\n    vec3 col = a + b * cos(2. * PI * (c * x + d));\n    return col;\n}\n\nfloat getGrassBlade(in vec2 position, in vec2 grassPos, out vec4 color) {\n    \n       // grassPos+= abs(noise33(vec3(grassPos*.41,0.)*vec3(3,.0,1)).xy-0.5 )*.5;\n\n    \n\t// between {-1, -1, -1} and {1, 1, 1}\n    vec3 grassVector3 = hash32(grassPos * 123512.41) * 2.0 - vec3(1);\n    // keep grass z between 0 and 0.4\n    grassVector3.z = grassVector3.z * 0.2 + 0.2;\n    vec2 grassVector2 = normalize (\n     //vec2(sin( 1.5+iTime*0.1),cos(1.5+iTime*0.1))*2.\n     (UV)  *1.5 \n        \n    +   grassVector3.xy*.6\n    )     ;\n\n    float grassLength = noise13(vec3(grassPos*1.5,10.)) * 0.01 + 0.012*length(UV) ;\n\n    // take coordinates in grass blade frame\n    vec2 gv = position - grassPos;\n    float gx = dot(grassVector2, gv);\n    float gy = dot(vec2(-grassVector2.y, grassVector2.x), gv);\n    float gxn = gx / grassLength;\n\n    // TODO make gy depends to gx\n    if (gxn >= 0.0 && gxn <= 1.0 && abs(gy) <= 0.0015 * (1. - gxn * gxn)) {\n        \n        vec3 thisGrassColor = \n            getGrassColor(hash12(grassPos * 2631.6));\n        color =\n            vec4(thisGrassColor * (0.2 + 0.8 * gxn) \n            + (fbm33(vec3(position*1.1,0.)*vec3(1,3,1))-0.5 )*.2\n            + (fbm33(vec3(position*10.1,0.)*vec3(5,1,1))-0.5 )*.2\n                 , 1.0);\n        \n     \treturn grassVector3.z * gxn;\n    }\n    else {\n        color = vec4(0., 0., 0., 1.);\n        return -1.0;\n    }\n}\n\nfloat getPoint(in vec2 position, out vec4 color) {\n   \tint xcount = int(1. / BLADES_SPACING);\n    int ycount = int(1. / BLADES_SPACING);\n    int ox = int(position.x * float(xcount));\n    int oy = int(position.y * float(ycount));\n\n    float maxz = 0.0;\n            vec4 tempColor =vec4(vec3(0.1,0.35,0)+fbm33(vec3(position*129.,0.)-.5),0.)*.1;\n\n    for (int i = -LOOKUP_DIST; i < LOOKUP_DIST; ++i) {\n        for (int j = -LOOKUP_DIST; j < LOOKUP_DIST; ++j) {\n            vec2 upos = vec2(ox + i, oy + j);\n            vec2 grassPos = (BLADES_SPACING+0.005*BLADES_SPACING*fbm33(vec3(upos*179.,0.)-.5)).x*  (upos \n                             + 4.5* (noise33(vec3(upos*50.,upos.x+upos.y)).xy-.5) );\n \n            float z = getGrassBlade(position, grassPos, tempColor);\n\n            if (z > maxz) {\n                maxz = z;\n                color = mix(color, tempColor,0.85);\n            }\n        }\n    }\n    if (maxz == 0.0) {\n        color = vec4(vec3(0.1,0.35,0)+fbm33(vec3(position*129.,0.)-.5),0.)*.12;;\n    }\n\n    return maxz;\n}\n\n//------------------------------------------------------------------\n// \n//------------------------------------------------------------------\n\n\nvec3 render( in vec3 ro, in vec3 rd) {\n\tvec3 col = vec3(.8, .9, 1.0) + rd.y * 0.8;\n\tvec2 res = castRay(ro, rd);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\tif (m > -0.5) {\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect(rd, nor);\n        \n        vec4 grasscolor;\n        vec4 grasscolor2;\n\t\t// material        \n\t\n        if (m < 1.5) {\n            \tcol = 0.45 + 0.35 * sin(vec3(0.05, 0.08, 0.10) * (m - 1.0));\n\t\t    vec2 position=pos.zx;\n            grasscolor2=  vec4(0.6*getGrassColor(hash13(pos)) * (0.2 + 0.8 * 0.5) \n            + (fbm33(vec3(position*1.1,0.)*vec3(1,3,1))-0.5 )*.2\n            + (fbm33(vec3(position*10.1,0.)*vec3(5,1,1))-0.5 )*.2\n                 , 1.0);if \n                \n            (t<13.){\n\t\t\tfloat f = getPoint( vec2(pos.xz*.1),grasscolor);\n            }\n            else {\n            grasscolor=grasscolor2;\n            }\n            \n            \n            col = mix(grasscolor.rgb,grasscolor2.rgb,smoothstep(10.,13.,t) );\n\t\t}\n\t\tif (m >= 2.0) {\n\t\t\tcol = vec3(0.6);\n\t\t}\n\t\tif (m >= 3.0) {\n\t\t\tcol = vec3(0.07);\n\t\t}\n\t\t// lighting        \n\t\tfloat occ = calcAO(pos, nor);\n\t\tvec3 lig = normalize(vec3(0.2, 0.7, 0.6));\n\t\tvec3 hal = normalize(lig - rd);\n\t\tfloat amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n\t\tfloat dif = clamp(dot(nor, lig), 0.0, 1.0);\n\t\tfloat bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0);\n\t\tfloat dom = smoothstep(-0.1, 0.1, ref.y);\n\t\tfloat fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n\t\tdif *= calcSoftshadow(pos, lig, 0.02, 2.5);\n\t\tdom *= calcSoftshadow(pos, ref, 0.02, 2.5);\n\t\tfloat spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 16.0) *\n\t\t\tdif *\n\t\t\t(0.04 + 0.96 * pow(clamp(1.0 + dot(hal, rd), 0.0, 1.0), 5.0));\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 1.30 * dif * vec3(1.00, 0.80, 0.55);\n\t\tlin += 0.20 * amb * vec3(0.40, 0.60, 1.00) * occ;\n\t\tlin += 0.20 * dom * vec3(0.40, 0.60, 1.00) * occ;\n\t\tlin += 0.30 * bac * vec3(0.25, 0.25, 0.25) * occ;\n\t\t//lin += 0.35 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\t\tcol = col * lin;\n\t\t//col += 10.00 * spe * vec3(1.00, 0.90, 0.70);\n        col=mix(col,vec3((col.x+col.y+col.z)/3.)*vec3(1,1.5,1),0.3);\n\t\tcol = mix(col, vec3(0.8, 0.9, 1.0), 1.0 - exp(-0.00005 * t * t * t  ));\n        \n\t}\n\treturn vec3(clamp(col, 0.0, 1.0));\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\n\n\n\n\nvoid setup() {\n }\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tsetup();\n\tvec2 mo = iMouse.xy / iResolution.xy;\n\tfloat time = .0 + iTime;\n\tvec3 tot = vec3(0.0);\n #\tif AA > 1\n\tfor (int m = 0; m < AA; m++)\n\t\tfor (int n = 0; n < AA; n++) {\n\t\t\t// pixel coordinates\n\t\t\tvec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n\t\t\tvec2 p = (-iResolution.xy + 2.0 * (fragCoord + o)) / iResolution.y;\n # else\n\t\t\t\tvec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n # endif\n\t\t\t// camera\t\n\t\t\tvec3 ta = timefly(time)  ;\n\t\t\tvec3 ro = vec3(0,1,0)+timefly(time-1.) \n                + vec3(-0.5 + 3.5 * cos(  6.0 * mo.x),\n\t\t\t\t1.0 + 2.0 * mo.y,\n\t\t\t\t0.5 + 4.0 * sin( 6.0 * mo.x))*(2.*(sin(iTime*.2)+1.2));\n\t\t\t// camera-to-world transformation\n\t\t\tmat3 ca = setCamera(ro, ta, 0.0);\n\t\t\t// ray direction\n  \n\n\t\t\tvec3 rd = ca * normalize(vec3(p.xy, 2.5));\n            \n                        vec3 centerray=normalize(ca * normalize(vec3(0,0, 2.5)));\n                  float uppness=( abs(dot(mix(rd,centerray,-0.1),vec3(0,1,0))));\n            uppness*=uppness;\n \n            uppness=1.-uppness; \n                UV= centerray.xz*uppness*1.1;\n\t\t\t// render\t\n\t\t\tvec3 col = render(ro, rd);\n\t\t\t// gamma\n\t\t\tcol = pow(col, vec3(0.4545));\n\t\t\ttot += col;\n # if AA > 1\n\t\t}\n\ttot /= float(AA * AA);\n #\tendif\n\tfragColor = vec4(tot, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WdXcDs",
    "date": "1585812327",
    "viewed": 34,
    "name": "6 Neighbor Voronoi  - (failed)",
    "description": "\nA cell in a square grid borders 8 other cells. in a hex grid there is only six bordering cells to check.",
    "likes": 1,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "2d",
     "voronoi",
     "worley"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Voronoi - basic\" by iq. https://shadertoy.com/view/MslGD8\n// 2020-04-02 06:34:14\n\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nvec2 hash( vec2 p ) { p=vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))); return fract(sin(p)*18.5453); }\n\n// return distance, and cell id\nvec2 voronoi( in vec2 p )\n{\n    vec2 n = floor( p ) ;\n    vec2 f = fract( p ) ;\n\n\tvec3 m = vec3( 8.0 ); \n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<= 1        -abs(j)\n        ; i++ )\n    {\n        vec2  g = vec2( float(i) , float(j) ) ;\n        vec2  o =   hash( n + g +vec2(floor(mod(p.y  +float(j) ,2.))*.5,0.5 ) )  ;\n     vec2  r = g - f \n          +vec2(1.-floor(mod(p.y  +float(j) ,2.))*.5,0.5)\n         \n          + o\n         ;\n \t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/max(iResolution.x,iResolution.y);\n    vec2 asp =   iResolution.xy/max(iResolution.x,iResolution.y) ;\n    p=p-(asp*0.5);\n    // computer voronoi patterm\n    vec2 c = voronoi( (14.0+6.0*sin(0.2*iTime))*p );\n\n    // colorize\n    vec3 col = 0.5 + 0.5*cos( c.y*6.2831 + vec3(0.0,1.0,2.0) );\t\n    col *= clamp(1.0 - 0.4*c.x*c.x,0.0,1.0);\n    col -= (1.0-smoothstep( 0.08, 0.09, c.x));\n\t\n    fragColor = vec4( col, 1.0 );\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XtccDr",
    "date": "1532174929",
    "viewed": 142,
    "name": "Ant",
    "description": "exoskeleton wit special blend and normal driven noise bumps.\nvery low fps - dropped the bump texture\nI wish it was black",
    "likes": 7,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "bug",
     "ant"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//Raycaster code credit to Inigo Quilez\n\n vec4 NormQuat(vec4 q)\n{\n    float lenSQ = dot(q, q);\n    float invLenSQ = 1./lenSQ;\n    return q*invLenSQ;\n}\n\nvec4 BuildQuat(vec3 axis, float angle)\n{\n    angle *= 0.5;\n    float s = sin(angle);\n    return NormQuat(vec4(axis*s, cos(angle)));\n}\n\nvec4 MulQuat(vec4 q1, vec4 q2)\n{\n    vec4 res = vec4(0.);\n    res.w   = q1.w*q2.w - dot(q1.xyz, q2.xyz);\n    res.xyz = q1.w*q2.xyz + q2.w*q1.xyz + cross(q1.xyz, q2.xyz);\n    return NormQuat(res);\n}\n\n \n    \nvec3 Rotate(vec4 q, vec3 v)\n{\n    vec3 t = 2.*cross(q.xyz, v);\n    return v + q.w*t + cross(q.xyz, t);\n}\n\n\n\nfloat fromTo(vec3 p,vec3 q)\n{\nreturn acos(dot(p,q));\n\n}\n\nvec4 quatLookAt(vec3 forward,vec3 up){\n    forward=normalize(forward);\n    up=normalize(up);\nreturn BuildQuat(cross(forward,up),fromTo(forward,up));\n}\n\n\nfloat   arandom (float aseed) {return mod( mod(aseed*43758.5453123, 1.9)+aseed* 78.233 ,1.0);}\n\nfloat value_at (float x,float y,float z) {return arandom(arandom(arandom(x)+y)+z);}\n\n\nfloat noise3d(vec3 p) {\n\t  float  px= floor (p.x); \t   float    py= floor (p.y); \t   float    pz= floor (p.z);\n  \t\tfloat\tlbx= smoothstep(0.0,1.0,p.x-px);\t\n  \t\tfloat  lby= smoothstep(0.0,1.0,p.y-py);\t \n \t\t float  lbz= smoothstep(0.0,1.0,p.z-pz);\n\t  \t  float    p0 = value_at (px,  py,  pz);    float    p1 = value_at (px+1.0,py,  pz);\n      \t  float    p2 = value_at (px+1.0,py+1.0,pz);    float    p3 = value_at (px,  py+1.0,pz);\t\t\n      \t  float    p4 = value_at (px,  py,  pz+1.0);  float      p5 = value_at (px+1.0,py,  pz+1.0);\n      \t  float    p6 = value_at (px+1.0,py+1.0,pz+1.0);  float      p7 = value_at (px,  py+1.0,pz+1.0);   \t     \n          float  p01 =mix(p0,p1,lbx);\t\t\t  float  p32 =mix(p3,p2,lbx);\n    \t  float  \tp45 =mix(p4,p5,lbx);\t\t  float  \tp76 =mix(p7,p6,lbx);\n\t\t  float  \tp0132=mix(p01,p32,lby);\t\t  float  \tp4576=mix(p45,p76,lby);  \t \n    float   c1=mix(p0132,p4576,lbz);\n    return    (c1);}\n\n\n\nfloat  synmin(float a,float  b,float  r) {\n\t \n        float  e =   max(r*0.02,(abs(a-b)/r) );\n        return min (a,b)- max(0.01,(r*e*0.75*(exp(1.0-(e*2.5 ))))/max(a,b)*0.5)\n \n            ;}\n\nfloat conecapsule (vec3 p, vec4 p1 ,vec4 p2,float w,float z ) {\nvec3 a=mix(p1.xyz,p2.xyz,0.1);\nvec3 b=mix(p1.xyz,p2.xyz,0.9);\nfloat\t\td1=p1.w;\nfloat\t\td2=p2.w*0.9;\nvec3\t\tba = b - a;\nvec3\t\tpa = p - a;\n    float v= dot(pa,ba) / dot(ba,ba);\nfloat\t\th = clamp(  v,   0.0,   1.0);\nfloat\t\t\td=mix(d1,d2,  smoothstep(0.0,1.0,   h));\n     float r= d ;// / 2.0;\n \n            return length (pa - ba*h) - r;\n\n}\n\n//float conecapsule (vec3 p, vec4 p1 ,vec4 p2 ,float w, float z) {\n\n    \n    \n     // vec3 n=normalize(vec3 (\n     // conecapsule2(p,p1,p2)-conecapsule2(p+vec3(0.001,0.0,0.0) ,p1,p2),\n    //  conecapsule2(p,p1,p2)-conecapsule2(p+vec3(0.0,0.001,0.0),p1,p2 ),\n   //   conecapsule2(p,p1,p2)-conecapsule2(p+vec3(0.0,0.0,0.001),p1,p2 )\n           //   ));\n \n    \n //float bumpb=noise3d(n*w)*z;\n     \n//return conecapsule2 (p,p1,p2) \n //   ; \n//}\n\nfloat antbody(vec3 p)\n{\n    \n    //body defines as basically a string of sticks and spheres. little more to it ofc\nvec4[] body= vec4[](vec4(-5,0,0,1),vec4(-4,0,1,2),vec4(-2,0,2,3),vec4(0,0,2,3),vec4(3,0,2,1),vec4(4,0,1,1),vec4(7,0,4,3),vec4(9,0,5,3),vec4(12,0,4,1),vec4(14,0.5,4,3),vec4(15,2,2,1),vec4(16,0.7,-0.5,0.5));\n\n    \n float oddbod=   \n            min(conecapsule (p, body[1] , body[2] ,2.0,0.125  ),\n            min(conecapsule (p, body[3] , body[4] ,2.0,0.125),\n            min(conecapsule (p, body[5] , body[6] ,2.0,0.125),\n                     min(conecapsule (p, body[9] , body[10] ,2.0,0.125),\n            conecapsule (p, body[7] , body[8] ,2.0,0.25) \n  ))))         ; \n     float evebod=  \n           min(conecapsule (p, body[0] , body[1] ,2.0,0.125),\n            min(conecapsule (p, body[2] , body[3] ,2.0,0.125),\n            min(conecapsule (p, body[4] , body[5] ,2.0,0.125),\n            min(conecapsule (p, body[6] , body[7] ,2.0,0.125),\n            min(conecapsule (p, body[8] , body[9] ,2.0,0.125),\n       \n\n              conecapsule (p, body[10] , body[11] ,2.0,0.125)\n  )))))        ; \n    \n return synmin (oddbod,evebod,0.60);\n\n}\n\n\nfloat antenna(vec3 p)\n{\nvec4[] ant1= vec4[](vec4(14.4062,0.35,5.21244,0.525),vec4(16.4468,1.52811,7.89352,0.49),vec4(18.9311,2.96244,8.66218,0.525),vec4(20.728,3.99987,6.65596,0.525),vec4(21.4749,4.43109,5.34974,0.52));\n float oddant1=   \n            min(conecapsule (p, ant1[1] , ant1[2] ,1.0,0.06),\n             (conecapsule (p, ant1[3] , ant1[4] ,1.0,0.06)\n       ))         ; \n     float eveant1=  \n           min(conecapsule (p, ant1[0] , ant1[1] ,1.0,0.06),\n             (conecapsule (p, ant1[2] , ant1[3] ,1.0,0.06) \n  ))        ; \n    \n    \n\n  return  synmin  (oddant1,eveant1,0.30);\n}\n\nfloat antleg1(vec3 p)\n{\nvec4[] leg1= vec4[](vec4(5.5,0.0,2.5,0.5),vec4(7.03209,1.28558,0.5,0.75),vec4(11.8623,6.49951,2.0,1.0),vec4(11.8623,4.49951,-3.5,0.75),vec4(13.944,5.78509,-5.75,0.65),vec4(15,6.42788,-6,0.5));\n float oddleg1=   \n            min(conecapsule (p, leg1[1] , leg1[2] ,3.0,0.135 ),\n             (conecapsule (p, leg1[3] , leg1[4] ,3.0,0.135 )\n       ))         ; \n     float eveleg1=  \n           min(conecapsule (p, leg1[0] , leg1[1] ,3.0,0.135 ),\n           min(conecapsule (p, leg1[2] , leg1[3] ,3.0,0.135 ),\n             (conecapsule (p, leg1[4] , leg1[5] ,3.0,0.135 ) \n  )))        ; \n    \n    \n\n  return  synmin  (oddleg1,eveleg1,0.50);\n}\nfloat antleg2(vec3 p)\n{\nvec4[] leg1= vec4[](vec4(4.75,0,1.75,0.5),vec4(4.75,2.31691,0.127681,0.75),vec4(4.75,6.89365,2.96554,1),vec4(4.75,7.93554,-2.94331,0.75),vec4(4.75,10.4261,-5.55044,0.75),vec4(4.75,11.4977,-5.86919,0.5));\n float oddleg1=   \n            min(conecapsule (p, leg1[1] , leg1[2] ,3.0,0.135 ),\n             (conecapsule (p, leg1[3] , leg1[4] ,3.0,0.135 )\n       ))         ; \n     float eveleg1=  \n           min(conecapsule (p, leg1[0] , leg1[1] ,3.0,0.135 ),\n           min(conecapsule (p, leg1[2] , leg1[3] ,3.0,0.135 ),\n             (conecapsule (p, leg1[4] , leg1[5] ,3.0,0.135 ) \n  )))        ; \n    \n    \n\n  return  synmin  (oddleg1,eveleg1,0.50);\n}\nfloat antleg3(vec3 p)\n{\nvec4[] leg1= vec4[](vec4(3.5,0.2,0.25,0.5),vec4(1.72499,3.691,-0.26813,0.75),vec4(-3.8651,6.7605,2.8302,1),vec4(-4.66323,6.43022,-3.07865,0.75),vec4(-7.02376,8.41093,-5.58159,0.75),vec4(-8.071,9.28967,-5.84825,0.5));\n float oddleg1=   \n            min(conecapsule (p, leg1[1] , leg1[2] ,3.0,0.135 ),\n             (conecapsule (p, leg1[3] , leg1[4] ,3.0,0.135 )\n       ))         ; \n     float eveleg1=  \n           min(conecapsule (p, leg1[0] , leg1[1] ,3.0,0.135 ),\n           min(conecapsule (p, leg1[2] , leg1[3] ,3.0,0.135 ),\n             (conecapsule (p, leg1[4] , leg1[5] ,3.0,0.135 ) \n  )))        ; \n    \n    \n\n  return  synmin  (oddleg1,eveleg1,0.50);\n}\n\n\nfloat legasm(vec3 p)\n{\n\nreturn\n    min(antenna(p),\n    min(antleg1(p),\n    min(antleg2(p),\n           antleg3(p)\n          \n          )));\n\n}\n        \n\nfloat ant(vec3 p)\n{\n    p=vec3(p.x,abs(p.y),p.z);\n  \n\n      \n    return synmin(antbody(p) ,legasm(p) ,0.60);\n    \n} \n\nvec4 map(vec4 r0)\n{  \n    vec3 p=r0.xyz ;\n    vec4 Q1 = quatLookAt(vec3(sin(iTime),1.,cos(iTime)),vec3(0,1,0));    \n    vec4 Q2 =quatLookAt(vec3(sin(2.*iTime),1.,cos(3.*iTime)),vec3(0,1,0));    \n    vec4 Q=MulQuat(Q1,Q2);\n    p=Rotate(Q, p);\n    \n    \n\n    //  vec3 n=normalize(vec3 (\n      //ant(p )-ant(p+vec3(0.001,0.0,0.0)  ),\n      //ant(p )-ant(p+vec3(0.0,0.001,0.0) ),\n    //ant(p )-ant(p+vec3(0.0,0.0,0.001)  )\n        //     ));\n \n    float bumpb=noise3d(p.yzx*4.5)*0.1;\n    return vec4(ant(p)\n                +abs(bumpb)\n                ,0.047/max( 1.,abs(p.z/4.)), 0.037/max( 1.,abs(p.z/3.)), 0.032/max( 1.,abs(p.x/2.)));\n }\n\n\n\n//Raycaster code credit to Inigo Quilez\n\n\nconst vec3 bbox_min = vec3(-7.363703305156273,-7.363703305156273,-7.363703305156273);\nconst vec3 bbox_max = vec3(7.363703305156273,7.363703305156273,7.363703305156273);\n// ray marching. ro is ray origin, rd is ray direction (unit vector).\n// result is (t,r,g,b), where\n//  * t is the distance that we marched,\n//  * r,g,b is the colour of the distance field at the point we ended up at.\n//    (-1,-1,-1) means no object was hit.\nvec4 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 100.0;\n   \n    float t = tmin;\n    vec3 c = vec3(-1.0,-1.0,-1.0);\n    for (int i=0; i<200; i++) {\n        float precis = 0.0005*t;\n        vec4 res = map( vec4(ro+rd*t,iTime) );\n        if (res.x < precis) {\n            c = res.yzw;\n            break;\n        }\n        t += res.x;\n        if (t > tmax) break;\n    }\n    return vec4( t, c );\n}\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( vec4(pos + e.xyy,iTime) ).x + \n                      e.yyx*map( vec4(pos + e.yyx,iTime) ).x + \n                      e.yxy*map( vec4(pos + e.yxy,iTime) ).x + \n                      e.xxx*map( vec4(pos + e.xxx,iTime) ).x );\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( vec4(aopos,iTime) ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n// in ro: ray origin\n// in rd: ray direction\n// out: rgb colour\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    //vec3 col = vec3(0.7, 0.9, 1.0) +rd.z*0.8;\n    //vec3 col = vec3(0.8, 0.9, 1.0);\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    vec4 res = castRay(ro,rd);\n    float t = res.x;\n    vec3 c = res.yzw;\n    if( c.x>=0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = mix(c,normalize(c),0.12)*0.34;\n\n        // lighting        \n        float occ = calcAO( pos, nor );\n        vec3  lig1 = normalize( vec3(-0.8, 0.3, 0.5) );\n        vec3  lig2 = normalize( vec3(0.8, 0.3, 0.5) );\n        float amb = clamp( 0.5+0.5*nor.z, 0.0, 1.0 );\n        float dif1 = clamp( dot( nor, lig1 ), 0.0, 1.0 );\n        float dif2 = clamp( dot( nor, lig2 ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig1.x,lig1.y,0.0))), 0.0, 1.0 )*clamp( 1.0-pos.z,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.z );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float spe1 = pow(clamp( dot( ref, lig1 ), 0.0, 1.0 ),32.0);\n        float spe2 = pow(clamp( dot( ref, lig2 ), 0.0, 1.0 ),32.0);\n        \n        vec3 lin = vec3(0.0);\n        lin += 4.30*dif1*vec3(1.00,0.80,0.55);\n        lin += 4.30*dif2*vec3(1.00,0.80,0.55);\n        lin += 14.00*spe1*vec3(1.00,0.90,0.70)*dif1;\n        lin += 14.00*spe2*vec3(0.50,0.90,1.0)*dif2;\n        lin += 0.9*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.20*bac*vec3(0.935,0.935,0.935)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n        vec3 iqcol = col*lin;\n\n        //col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n        col = mix(col,iqcol, 0.64);\n    }\n\n    return vec3( clamp(col,0.0,1.0) );\n}\n// Create a matrix to transform coordinates to look towards a given point.\n// * `eye` is the position of the camera.\n// * `centre` is the position to look towards.\n// * `up` is the 'up' direction.\nmat3 look_at(vec3 eye, vec3 centre, vec3 up)\n{\n    vec3 ww = normalize(centre - eye);\n    vec3 uu = normalize(cross(ww, up));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n// Generate a ray direction for ray-casting.\n// * `camera` is the camera look-at matrix.\n// * `pos` is the screen position, normally in the range -1..1\n// * `lens` is the lens length of the camera (encodes field-of-view).\n//   0 is very wide, and 2 is a good default.\nvec3 ray_direction(mat3 camera, vec2 pos, float lens)\n{\n    return normalize(camera * vec3(pos, lens));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 origin = (bbox_min + bbox_max) / 2.0 +vec3 (0,0,10);\n    const vec3 radius = (bbox_max - bbox_min) / 2.0;\n    float r = max(radius.x, max(radius.y, radius.z)) / 1.0;\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n \n      vec2 mouse = iMouse.xy / iResolution.xy;\n      //  vec3 eye = vec3 (cos (4. * mouse.x) * 67., sin (4. * mouse.x) *sin (4. * mouse.y) * 67., -cos (4. * mouse.y) * 67.);\nvec3 eye = vec3(sin( 2.)*26., cos( 3.)*20., cos( 5.)*4.+4.);\n    vec3 centre = vec3(-1.0, 0.0, 1.0);\n    vec3 up = eye+ vec3(0.0, 0.0, 1.0);\n\t \n \n    mat3 camera = look_at(eye, centre, up);\n    vec3 dir = ray_direction(camera, p, 2.5);\n\n    vec3 col = render( eye, dir );\n    \n    // convert linear RGB to sRGB\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wdl3DN",
    "date": "1546350984",
    "viewed": 94,
    "name": "Architectural Volute",
    "description": " Still work in progress\n I intended to define it as  two points, each with a curl number, a filament width and some overall swirl radius for each point.  \nI guess some of the shapes are nice.",
    "likes": 5,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "volute"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Swirly Gabor noise\" by TLC123. https://shadertoy.com/view/WdlGDr\n// 2019-01-01 12:09:36\n\n \n#define OCTAVES 2\n#define PI 3.14159265359\n \n \n\nvec2 hash2( vec2 p ) \n{  \t\t\t\t\t\t\n\tp = vec2(dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)));\n    \n\treturn -1.0 + 2.0 * fract(sin(p + 20.0) * 53758.5453123);\n}\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\t\t\t\t   \n\treturn fract(sin(q)*43758.5453);\n}\n\n\n  \n\nfloat gauss(float x, float s) {\n    return exp(-.5*(x*x)/(s*s)); \n}\nfloat gauss(float x) {\n    return exp(-.5*x*x); \n}\nfloat gauss(float s,vec2 D) {\n\tfloat d = dot(D,D)/(s*s);\n\treturn exp(-.5*d); \n}\n\n#define SQR(x) ((x)*(x))\n\n\n \nfloat swirlgabor(vec2 pos, vec2 k, float gaussF, float phi) {\n    float p=  length(pos) ;\n    float g = gauss(p, 1./gaussF);\n    float a=  atan(k.y,k.x)+(2.+sin(phi))*1.2*6.28*smoothstep(gaussF*0.65, -2.,p) ;\n    vec2 k2=vec2(sin(a),cos(a))*length(k);\n    float s = clamp ( -1.,1.,.5* sin(2.*PI*dot(pos,k2)  ));\n \n\n\treturn  (g* s);\n}\n\nfloat polargabor(vec2 pos, vec2 k, float gaussF, float phi) {\n\tfloat g = gauss(length(pos), 1./gaussF);\n    float s = clamp ( -1.,1., sin( length(pos)*2.*PI*  max(k.x,k.y) - phi) );\n \n\treturn  (g* s);\n}\n\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.1, .9 );\n    return length( pa - ba*h );\n}\n\n\nfloat sdvoluteLine( in vec2 p, in vec2 a, in vec2 b ,float curla ,float curlb )\n{\n    float gaussF=   length(b-a)  ;\n    vec2 pa=p-a, ba = b-a, pb=p-b;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), -0., 1. );\n\n    float pal=  length(pa) ;\n    float pbl=  length(pb) ;\n    float bal=  length(ba) ;\n    \n    float ga = gauss(pal,  (bal*0.5)/gaussF)*gaussF;\n    float gb = gauss(pbl,  (bal*0.5)/gaussF)*gaussF;\n    \n    float tha= 1.57  +  atan(pa.y,pa.x)       + curla*6.28*   ga        ;    \n    float thb= 1.57  +  atan(pb.y,pb.x)       + curlb*6.28*   gb         ;\n    \n    vec2 pap=vec2( sin(tha),cos(tha) )*pal+a;\n    vec2 pbp=vec2( sin(thb),cos(thb) )*pbl+b;\n    \n    \n    return sdLine(  mix(pap,pbp,( h)),   a,   b );\n}\n\n\n\n\nfloat Remap( float _f, float _min, float _max )\n{\n    return (_f - _min)/ (_max - _min);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \tvec2 uv = (fragCoord.xy-iResolution.xy*0.5) / iResolution.xx;\n\n \n    float  freq = 10. ;\n     \n \n    \n    \n\n//float Gabornoise( in vec2 point, float Freq, float GAUSS_F ,float SCALE,float ANGLE,float Phi, float Spread)\n\n          float  len =  0.25*  sdvoluteLine( uv*freq, vec2 (-2.+sin(iTime*0.7),-.4), vec2 (2.-sin(iTime*0.7),0.4), sin(iTime*0.3)*0.75 , sin(iTime*0.5)*0.75 )-.12;\n\n    //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n      vec3 col = vec3(1.0) - sign(len)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-iResolution.y*0.08*abs(len));\n\tcol *= 0.8 + 0.2*cos(iResolution.y*0.3*abs(len));\n\tcol = mix( col, vec3(1.0), max(1.0-abs(len)*iResolution.y*0.2,0.0));\n\t\n\tfragColor = vec4(col*col, 1.0);   \n \n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3ss3W7",
    "date": "1546546741",
    "viewed": 116,
    "name": "Architectural Volute II",
    "description": " Still work in progress\n I intended to define it as  two points, each with a curl number, a filament width and some overall swirl radius for each point.  \nI guess some of the shapes are nice.",
    "likes": 7,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "volute"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"2 * 2d -> 3d  \" by TLC123. https://shadertoy.com/view/MlyfRW\n// 2019-01-04 13:16:32\n\n// Fork of \"The Walking Raymarcher\" by xorxor. https://shadertoy.com/view/Mt3XWH\n// 2018-11-11 15:37:21\n\n//https://swiftcoder.wordpress.com/2010/06/21/logarithmic-spiral-distance-field/\n\n\n// tracer from  https://shadertoy.com/view/Mt3XWH\n// sdPentagon from https://www.shadertoy.com/view/llVyWW\n// roundrect forked fromm https://www.shadertoy.com/view/4sjyRz\n#define E 2.71828\n\nconst float PI = acos(-1.0);\n\nfloat smin(float a, float b) {\n    const float k = 1.921;\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n\n}\n\nfloat smax(float d1, float d2, float k) {\n\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\nfloat spiral(vec2 p, float a, float b, float w, float angle, float rmax) {\n    //https://swiftcoder.wordpress.com/2010/06/21/logarithmic-spiral-distance-field/\n    //# calculate the target radius and theta\n    float r = length(p);\n    float t = atan(p.y, p.x) + angle;\n\n    //# early exit if the point requested is the origin itself\n    //# to avoid taking the logarithm of zero in the next step\n    if (r == 0.)\n        return 0.;\n\n    //# calculate the floating point approximation for n\n    //# calculate n\n    float n = floor((log(r / a) / b - t) / (2.0 * PI));\n\n    //# find the two possible radii for the closest point\n    float lower_r = a * exp(b * (t + 2.0 * PI * n));\n    float upper_r = lower_r * exp(2.0 * PI * b);\n\n    //# return the minimum distance to the target point\n    return\n    max((r - rmax),\n        (min(abs(upper_r - r), abs(r - lower_r)) - w)\n    );\n\n}\n\n\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba * h);\n}\n\n\n\nfloat sdvolute( in vec2 p, in vec2 a, in vec2 b, float curla, float curlb) {\n    vec2 pa = p - a, ba = b - a, pb = p - b;\n    float bal = length(ba);\n    float pal = length(pa);\n    float pbl = length(pb);\n    float h = clamp(dot(pa, ba) / dot(ba, ba), -0., 1.);\n    float theta = atan(ba.y, ba.x);\n\n    float d1 = spiral(pa, 1., .5, 0.75, PI + .9, 6.);\n    float d2 = spiral(pb, 1., .5, 0.75, .9, 6.);\n\n    //float   dl=abs(sdLine( p, a, b )-bal*0.5)+1.;\n    // float d12mix=mix(d1,d2,smoothstep(0.,1.,smoothstep(0.,1.,smoothstep(0.,1.,h))));\n    return smin(d1, d2);\n}\n\n\n\n \n\n \n\n\n\n\nfloat roundrect(vec2 p, vec2 c, vec2 r) {\n\n    p = abs(p) - c + r;\n    if (p.x >= 0.0 && p.y >= 0.0)\n        return length(p) - r.x;\n    else\n        return max(p.x, p.y) - r.x;\n}\n\nfloat shape1(vec2 p) {\n\n    float d = 0.25 * sdvolute(p * 1.,\n        vec2(-4. + sin(iTime * 0.7) * 0.5, 1.8 + 1. * cos(iTime * 0.5)),\n        vec2(4. - sin(iTime * 0.7) * 0.5, -1.8 - 1. * cos(iTime * 0.5)),\n        sin(iTime * 0.3) * 0.75,\n        sin(iTime * 0.5) * 0.75);\n\n\n    return (d);\n}\nfloat shape2(vec2 p) {\n\n    float d = roundrect(p - vec2(-4.1, 0), vec2(4., .6), vec2(.05));\n\n\n    d = min(d, roundrect(p - vec2(-.085, 0.), vec2(.025, .8), vec2(.03)));\n    d = min(d, roundrect(p - vec2(-.185, 0.), vec2(.025, .7), vec2(.03)));\n    d = min(d, length(p - vec2(-.36, 0.)) - .4);\n\n\n\n\n    return (d);\n}\n\n\nvec2 map(vec3 p) {\n\n    p = vec3((fract(p.x / 28.)) * 28., p.y, (fract(p.z / 28.)) * 28.); // repeat\n    p = p - vec3(14, 0, 9); //translate\n\n    //p=p-vec3(10,0,10);\n\n    p.xz = abs(p.xz); //mirror\n    p = p - vec3(3.5, 0, 3.5);\n\n    //p=p-vec3(10,0,5);\n\n    float an = .66; //additional angle\n    p = vec3((p.x * cos(an) - p.z * sin(an)), p.y, (p.z * cos(an) + p.x * sin(an)));\n    float plane = abs(p.y + 6.6);//making geound floor\n\n    p = p.yxz; // orienting upright\n    p.x = -p.x; //flip\n    p.z = -p.z; //flip\n\n    float w = shape1(p.xz); //building shape on shape\n    float d = shape2(vec2(w, p.y));\n\n\n    return (d < plane) ? vec2(d, 1.0) : vec2(plane, 2.0);\n}\n\nfloat calcShadow(vec3 ro, vec3 rd, float mint, float maxt) {\n    float t = mint;\n    float res = 1.0;\n    for (int i = 0; i < 10; i++) {\n        float h = map(ro + rd * t).x;\n        res = min(res, 1.1 * h / t);\n        t += h;\n        if ((h < 0.001) || (t > maxt)) {\n            break;\n        }\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec2 trace(vec3 ro, vec3 rd) {\n    const float kTMin = 0.01;\n    const float kTMax = 200.0;\n    const float kEps = 0.001;\n\n    float t = kTMin;\n    vec2 res;\n    for (int i = 0; i < 170; i++) {\n        vec3 pos = ro + rd * t;\n        res = map(pos);\n        if ((res.x < kEps) || (t > kTMax)) {\n            break;\n        }\n        t += res.x * 0.5;\n\n    }\n\n    if (t < kTMax) {\n        return vec2(t, res.y);\n    } else {\n        return vec2(-1.0);\n    }\n}\n\nvec3 calcNormal(vec3 p) {\n    const vec2 e = vec2(0.005, 0);\n    float dp = map(p).x;\n    return normalize(vec3(dp - map(p - e.xyy).x,\n        dp - map(p - e.yxy).x,\n        dp - map(p - e.yyx).x));\n}\n\nmat3 calcCamera(vec3 eye, vec3 target) {\n    vec3 cw = normalize(target - eye);\n    vec3 cu = cross(cw, vec3(0, 1, 0));\n    vec3 cv = cross(cu, cw);\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\n    vec2 mo = vec2(0.95, -0.2);\n    if (iMouse.z > 0.5) {\n        mo = 10.0 * iMouse.xy / iResolution.xy - 1.0;\n        mo *= 3.14159 * vec2(0.4, 0.1);\n    }\n    mo += 3.14159 * 2.5;\n\n    vec3 eye = vec3(-50.0 * cos(mo.x + iTime * .13), 20.0 + 20.0 * cos(mo.y), 60.0 * sin(mo.x + iTime * .3));\n    vec3 target = vec3(0.0, 3.0, 0.0);\n\n    mat3 cam = calcCamera(eye, target);\n\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 rd = cam * normalize(vec3(uv, 2.0));\n\n    vec3 col = vec3(1.0);\n\n    vec2 res = trace(eye, rd);\n    if (res.x > 0.0) {\n        vec3 pos = eye + rd * res.x;\n        vec3 nor = calcNormal(pos);\n        vec3 ldir = normalize(vec3(-10.5, 20.8, 24.0));\n\n        if (res.y < 1.5) {\n            col = 0.5 + 0.5 * nor.zzx;\n            float dif = max(dot(nor, ldir), 0.0);\n            vec3 ref = reflect(rd, nor);\n            float spe = pow(clamp(dot(ref, ldir), 0.0, 1.0), 15.0);\n\n            col *= (0.3 + 0.7 * dif);\n            float edge = pow(1.0 - dot(-rd, nor), 1.1);\n            col += 0.8 * edge + spe;\n        }\n\n        float sh = calcShadow(pos, ldir, 0.1, 30.0);\n        col *= (0.5 + sh);\n    }\n\n\n\n\n    if (fract(iTime / 5.) < 0.153) {\n        // col=vec3( shape1(uv*20.-vec2(0,4))>0. )\n\n        float len = shape1(uv * 15. - vec2(0, 0));\n\n        //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n        col = vec3(1.0) - sign(len) * vec3(0.1, 0.4, 0.7);\n        col *= 1.0 - exp(-iResolution.y * 0.008 * abs(len));\n        col *= 0.8 + 0.2 * cos(iResolution.y * 0.3 * abs(len));\n        col = mix(col, vec3(1.0), max(1.0 - abs(len) * iResolution.y * 0.2, 0.0));\n        fragColor = vec4(col * col, 1.0);\n    }\n    if (fract(iTime / 5.) < 0.0565) {\n        // col=vec3( shape2(uv*20.-vec2(0,-8))>0. );\n\n        float len = shape2(uv * 5. - vec2(2, 0)) / 4.;\n\n        //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n        col = vec3(1.0) - sign(len) * vec3(0.1, 0.4, 0.7);\n        col *= 1.0 - exp(-iResolution.y * 0.008 * abs(len));\n        col *= 0.8 + 0.2 * cos(iResolution.y * 0.3 * abs(len));\n        col = mix(col, vec3(1.0), max(1.0 - abs(len) * iResolution.y * 0.2, 0.0));\n\n        fragColor = vec4(col * col, 1.0);\n    }\n    fragColor = vec4(col, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "ttXSDl",
    "date": "0",
    "viewed": 0,
    "name": "Architectural Volute III",
    "description": " Still work in progress\n I intended to define it as  two points, each with a curl number, a filament width and some overall swirl radius for each point.  \nI guess some of the shapes are nice.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "volute"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Architectural Volute VI\" by TLC123. https://shadertoy.com/view/wlsXzf\n// 2019-07-31 14:16:54\n\n// Fork of \"Architectural Volute\" by TLC123. https://shadertoy.com/view/Wdl3DN\n// 2019-07-22 17:24:56\n\n// Fork of \"Swirly Gabor noise\" by TLC123. https://shadertoy.com/view/WdlGDr\n// 2019-01-01 12:09:36\n\n \n#define OCTAVES 2\n#define PI 3.14159265359\n \n \nfloat pModInterval1(  float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn p;\n}\n\nfloat CWspiral(vec2 p,float r,int a,int b){\n \nfloat d= abs(pModInterval1(length(p)+atan(p.y,-p.x)/6.28*r ,r ,float(a),float(b)));\n //d=pModInterval1 (u,.1,0.,2.);\nif (a>0)d=min(d,length(p-vec2(+float(a)*r-r*0.5,0.)));\nd=min(d,length(p-vec2(+float(b)*r+r*0.5,0.)));\nreturn    abs(d )   ;\n}\n float CCspiral(vec2 p,float r,int a,int b){\n \nfloat d= abs(pModInterval1(length(p)-atan(p.y,p.x)/6.28*r ,r ,float(a),float(b)));\n //d=pModInterval1 (u,.1,0.,2.);\nif (a>0)d=min(d,length(p-vec2(-float(a)*r+r*0.5,0.)));\nd=min(d,length(p-vec2(-float(b)*r-r*0.5,0.)));\nreturn    abs(d )   ;\n}\n \n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \tvec2 uv = (fragCoord.xy-iResolution.xy*0.5) / iResolution.xx;\n\n \n    float  freq = 10. ;\n     \n \n    \n    \n\n//float Gabornoise( in vec2 point, float Freq, float GAUSS_F ,float SCALE,float ANGLE,float Phi, float Spread)\n\n          float  len;\n         len=     CCspiral( uv-vec2(0.175,-0.0 ),.07,1,2);   \n       len=   min(len,  CWspiral( uv-vec2(-0.175,0.0 ),.07,1,2))-0.005;   \n len*=3.;\n    //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n      vec3 col = vec3(1.0) - sign(len)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-iResolution.y*0.08*abs(len));\n\tcol *= .8 + 0.3*cos(iResolution.y*0.5 *abs(len));\n\t col = mix( col, vec3(1.0), max(1.0-abs(len)*iResolution.y*0.2,0.0));\n \tfragColor = vec4(col*col, 1.0);   \n \n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wlsXzf",
    "date": "1563822030",
    "viewed": 59,
    "name": "Architectural Volute VI",
    "description": " Still work in progress\n I intended to define it as  two points, each with a curl number, a filament width and some overall swirl radius for each point.  \nI guess some of the shapes are nice.",
    "likes": 5,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "volute"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Architectural Volute\" by TLC123. https://shadertoy.com/view/Wdl3DN\n// 2019-07-22 17:24:56\n\n// Fork of \"Swirly Gabor noise\" by TLC123. https://shadertoy.com/view/WdlGDr\n// 2019-01-01 12:09:36\n\n \n#define OCTAVES 2\n#define PI 3.14159265359\n \n \n \n\n \n\nfloat smootherstep(float a, float b, float x)\n{\n    x = clamp((x - a)/(b - a), 0.0, 1.0);\n    return x*x*x*(x*(x*6.0 - 15.0) + 10.0);\n}\nvec2 spiralCoords(vec2 p, float turns) \n{\n\tp = vec2(atan(p.x, p.y)/6.283 - .4, length(p)*turns);\n    float s = p.y+p.x;\n    float l = (floor(s)-p.x);\n    float d = fract(s);\n    return vec2(l, d);\n}\n \n float spiral(vec2 p)\n{\n\tfloat t = 0.05;\n\tfloat s = 0.3;\n\tp = spiralCoords(p,2.0);\n\tfloat d = smoothstep(0.5-t-s, 0.5-t, p.y);\n\td *= 1.0 - smoothstep(0.5+t, 0.5+t+s, p.y);\n\td *= 1.0 - smoothstep(1.0,1.1, p.x);\n\treturn  1.-d;\n}\n\nfloat ornament(vec2 p)\n{\n\tvec2 op = p;\n\t\n\t//swirls\n\tp += vec2(1.0, -0.1);\n\tfloat d = spiral(p);\n\tp += vec2(-2.0, 0.2);\n\tp *= -1.0;\n\td = min(d, spiral(p));\n\n\t//connection piece\n\tp = op;\n\tfloat c = abs(p.y - mix(-0.65, 0.65, smootherstep(-1.0, 1.0, p.x)));\n\tc = smoothstep(0.00, 0.15, c);\n\tc += smoothstep(1.0, 1.1, abs(p.x));\n\t\t\n\t d =   min(d, c);\n\treturn 1.0 - d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \tvec2 uv = (fragCoord.xy-iResolution.xy*0.5) / iResolution.xx;\n\n \n    float  freq = 10. ;\n     \n \n    \n    \n\n//float Gabornoise( in vec2 point, float Freq, float GAUSS_F ,float SCALE,float ANGLE,float Phi, float Spread)\n\n          float  len;\n         len=     ornament( uv *4. )*-0.05;   \n  len*=3.;\n    //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n      vec3 col = vec3(1.0) - sign(len)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-iResolution.y*0.08*abs(len));\n\tcol *= .8 + 0.3*cos(iResolution.y*0.5 *abs(len));\n\t col = mix( col, vec3(1.0), max(1.0-abs(len)*iResolution.y*0.2,0.0));\n \tfragColor = vec4(col*col, 1.0);   \n \n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tlSSRR",
    "date": "0",
    "viewed": 0,
    "name": "Base shader",
    "description": "stripped down starting point to fork",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "raymarching"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsX3zn",
       "filepath": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png",
       "type": "cubemap",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//------------------------------------------------------------------------------\n// ++ Physically-based SDF  https://www.shadertoy.com/view/XlKSDR  romainguy\n//------------------------------------------------------------------------------\n\n#define AA 2\n\n//------------------------------------------------------------------------------\n// Scene\n//------------------------------------------------------------------------------\nvec2 paint(float d, float c) {\n\treturn vec2(d, c);\n}\n\nvec2 scene( in vec3 pos) {\n\n\tvec2 res = paint(sdSphere(pos, 1.),1.);\n\tvec2 plane = paint(sdPlane(pos, vec4(0, 1, 0, 0.5)), 1.);\n\tres = opSmoothUnion(res, plane, 0.1);\n\n\treturn res;\n}\n//------------------------------------------------------------------------------\n// Materials\n//------------------------------------------------------------------------------\n\nfloat checkersGradBox( in vec2 p) {\n\t// filter kernel\n\tvec2 w = fwidth(p) + 0.001;\n\t// analytical integral (box filter)\n\tvec2 i = 2.0 * (abs(fract((p - 0.5 * w) * 0.5) - 0.5) - abs(fract((p + 0.5 * w) * 0.5) - 0.5)) / w;\n\t// xor pattern\n\treturn 0.5 - 0.5 * i.x * i.y;\n}\n\nvec3 normal( in vec3 position) {\n\tvec3 epsilon = vec3(0.001, 0.0, 0.0);\n\tvec3 n = vec3(\n\t\tscene(position + epsilon.xyy).x - scene(position - epsilon.xyy).x,\n\t\tscene(position + epsilon.yxy).x - scene(position - epsilon.yxy).x,\n\t\tscene(position + epsilon.yyx).x - scene(position - epsilon.yyx).x);\n\treturn normalize(n);\n}\n\nmatr getMaterial(vec3 pos, float id, float distance, float occ, vec3 n, vec3 origin, vec3 direction) {\n   // default material gets copied and normal is added.\n    // user defined materila function is called here\n\tfloat i = float(material.length());\n\tint idint = int(round(clamp(id, 0., i)));\n\tmatr ret;\n\n\tret = material[idint];\n\tret.normal = n;\n \n\n\tif (idint == 1) {\n\t\tfloat f = checkersGradBox(2.2 * pos.xz);\n\t\tret.rgb = 0.3 + f * material[idint].rgb ;\n         \n\t}\n\n \n\n\treturn ret;\n}\n//------------------------------------------------------------------------------\n//https://www.shadertoy.com/view/XlKSDR\n//------------------------------------------------------------------------------\nfloat shadow( in vec3 origin, in vec3 direction) {\n\tfloat hit = 1.0;\n\tfloat t = 0.02;\n\n\tfor (int i = 0; i < 1000; i++) {\n\t\tfloat h = scene(origin + direction * t).x;\n\t\tif (h < 0.001) return 0.0;\n\t\tt += h;\n\t\thit = min(hit, 10.0 * h / t);\n\t\tif (t >= 2.5) break;\n\t}\n\n\treturn clamp(hit, 0.0, 1.0);\n}\n\nvec2 traceRay( in vec3 origin, in vec3 direction) {\n\tfloat material = -1.0;\n\n\tfloat t = 0.02;\n\n\tfor (int i = 0; i < 100; i++) {\n\t\tvec2 hit = scene(origin + direction * t);\n\t\tif (hit.x < 0.00005|| t > 20.0) break;\n\t\tt += hit.x;\n\t\tmaterial = hit.y;\n\t}\n\n\tif (t > 15.0) {\n\t\tmaterial = -1.0;\n\t}\n\n\treturn vec2(t, material);\n}\n\n\n\n \n\nfloat calcAO( in vec3 pos, in vec3 nor) {\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor (int i = 0; i < 9; i++) {\n\t\tfloat hr = 0.01 + 0.12 * float(i) / 4.0;\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = scene(aopos).x;\n\t\tocc += -(dd - hr) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp(1.0 - 2.0 * occ, 0.0, 1.0);\n}\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\n\n\n\n\n\n//------------------------------------------------------------------------------\n// Rendering\n//------------------------------------------------------------------------------\nvec3 render( in vec3 origin, in vec3 direction, out float distance) {\n\t// Sky gradient\n\t//vec3 color = vec3(0.65, 0.85, 1.0) + direction.y * 0.72;\n\tvec3 bgcolor = texture(iChannel0, direction).xyz;\n\tvec3 color = bgcolor;\n\n\t// (distance, material)\n\tvec2 hit = traceRay(origin, direction);\n\tdistance = hit.x;\n\tfloat id = hit.y;\n\n\t// We've hit something in the scene\n\tif (id > 0.0) {\n\t\tvec3 position = origin + distance * direction;\n\n\t\tvec3 v = normalize(-direction);\n\t\tvec3 n = normal(position);\n\t\tfloat occ = calcAO(position, n);\n\n\t\tmatr M = getMaterial(position, id, distance, occ, n, origin, direction);\n\t\tvec3 baseColor = M.rgb;\n\t\tfloat roughness = M.rough;\n\t\tfloat metallic = M.metal;\n\n\t\tn = M.normal;\n\n\t\tvec3 l = normalize(vec3(0.6, 0.7, -0.7));\n\t\tvec3 h = normalize(v + l);\n\t\tvec3 r = normalize(reflect(direction, n));\n\n\t\tfloat NoV = abs(dot(n, v)) + 1e-5;\n\t\tfloat NoL = clamp(dot(n, l), 0., 1.);\n\t\tfloat NoH = clamp(dot(n, h), 0., 1.);\n\t\tfloat LoH = clamp(dot(l, h), 0., 1.);\n\n\t\tfloat intensity = 3.0;\n\t\tfloat indirectIntensity = 0.64;\n\n\t\tfloat linearRoughness = roughness * roughness;\n\t\tvec3 diffuseColor = (1.0 - metallic) * baseColor.rgb;\n\t\tvec3 f0 = 0.04 * (1.0 - metallic) + baseColor.rgb * metallic;\n\n\t\tfloat attenuation = shadow(position, l);\n\n\t\t// specular BRDF\n\t\tfloat D = D_GGX(linearRoughness, NoH, h);\n\t\tfloat V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n\t\tvec3 F = F_Schlick(f0, LoH);\n\t\tvec3 Fr = (D * V) * F;\n\n\t\t// diffuse BRDF\n\t\tvec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n\n\t\tcolor = Fd + Fr;\n\t\tcolor *= (intensity * attenuation * NoL) * vec3(0.98, 0.92, 0.89);\n\n\t\t// diffuse indirect\n\t\tvec3 indirectDiffuse = Irradiance_SphericalHarmonics(n) * Fd_Lambert();\n\n\t\tvec2 indirectHit = traceRay(position, r);\n\n\t\tvec3 indirectSpecular = texture(iChannel0, r.xyz).xyz + r.y * 0.72;\n        float indirecid=indirectHit.y;\n\t\tif (indirecid > 0.0) {\n\t\t\tvec3 indirectPosition = position + indirectHit.x * r;\n              vec3 indirectn = normal(indirectPosition);\n\t\t      float indirectocc = calcAO(indirectPosition, n);\n        M = getMaterial(indirectPosition, indirecid, indirectHit.x, indirectocc, indirectn, position, r);\n\t\t\tindirectSpecular = M.rgb;\n\n\t\t}\n\n\t\t// indirect contribution\n\t\tvec2 dfg = PrefilteredDFG_Karis(roughness, NoV);\n\t\tvec3 specularColor = f0 * dfg.x + dfg.y;\n\t\tvec3 ibl = diffuseColor * indirectDiffuse + indirectSpecular * specularColor;\n\n\t\tcolor += ibl * indirectIntensity;\n\t}\n\tcolor = mix(color, bgcolor, smoothstep(13., 14.5, distance));\n\n\treturn color;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n// Setup\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n \n\nvoid setup() {}\n//------------------------------------------------------------------------------\n// Main and Final \n//------------------------------------------------------------------------------\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tsetup();\n \t vec2 mo = iMouse.xy / iResolution.xy;\n     if(mo.x==mo.y)mo=vec2(0.5);\n    mo *=3.14;\n     mo.y-2.14;\n \tfloat time = .0 + iTime;\n\tvec3 tot = vec3(0.0);\n #\tif AA > 1\n\tfor (int m = 0; m < AA; m++)\n\t\tfor (int n = 0; n < AA; n++) {\n\t\t\t// pixel coordinates\n\t\t\tvec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n\t\t\tvec2 p = (-iResolution.xy + 2.0 * (fragCoord + o)) / iResolution.y;\n # else\n\t\t\tvec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n # endif\n\t\t\t // camera\t\n\t\t\tvec3 ta = vec3(0, 0, 0);\n\n\t\t\tvec3 ro = vec3(0, cos(mo.y), sin(mo.y));\n\t\t\tvec4 horz = BuildQuat(vec3(0, 1, 0), -mo.x * 2. + iTime * 0.1);\n\t\t\tro = ta + Rotate(horz, ro) * 4.;\n            \n\t\t\t // camera-to-world transformation\n\t\t\tmat3 ca = setCamera(ro, ta, 0.0);\n\t\t\t // ray direction\n\t\t\tvec3 rd = ca * normalize(vec3(p.xy, 2.5));\n\t\t\t // render\n\t\t\tfloat distance;\n\t\t\tvec3 col = render(ro, rd, distance);\n\t\t\t // gamma\n\t\t\tcol = pow(col, vec3(0.4545));\n\t\t\ttot += col;\n # if AA > 1\n\t\t}\n\ttot /= float(AA * AA);\n #\tendif\n\tfragColor = vec4(tot, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// Common megapack\n#define PI  3.14159265\n#define hPI 1.57079632\n#define TAU 6.283185\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n//----------------------------------------------------------------------------------------\n// Palette IQ\n//----------------------------------------------------------------------------------------\n\nstruct palette\n{ \n  vec3 a;\n  vec3 b;\n  vec3 c;\n  vec3 d;\n      };\npalette Sarcoline=  palette( vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\npalette Coquelicot= palette(   vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\npalette Smaragdine= palette(  vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\npalette Amaranth=   palette(  vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\npalette Glaucous=   palette(  vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\npalette Eburnean=   palette(   vec3( 0.5,0.1,0.2),vec3(1.,0.75,0.8),vec3(2.0,1.0,.90),vec3(0.2,0.20,0.25) );\npalette Fulvous=    palette(  vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    \n\nvec3 pal( in float t, palette p )\n{\n    return p.a + p.b*cos( 6.28318*(p.c*t+p.d) );\n}\n\n//----------------------------------------------------------------------------------------\n// Palette IQ\n//----------------------------------------------------------------------------------------\n#define  AliceBlue        vec3 ( 0.94, 0.97, 1.00 ) \n#define  AntiqueWhite        vec3 ( 0.98, 0.92, 0.84 ) \n#define   Aqua        vec3 ( 0.00, 1.00, 1.00 ) \n #define  Aquamarine        vec3 ( 0.50, 1.00, 0.83 ) \n #define  Azure        vec3 ( 0.94, 1.00, 1.00 ) \n #define  Beige        vec3 ( 0.96, 0.96, 0.86 ) \n #define  Bisque        vec3 ( 1.00, 0.89, 0.77 ) \n #define  Black        vec3 ( 0.00, 0.00, 0.00 ) \n #define  BlanchedAlmond        vec3 ( 1.00, 0.92, 0.80 ) \n #define  Blue        vec3 ( 0.00, 0.00, 1.00 ) \n #define  BlueViolet        vec3 ( 0.54, 0.17, 0.89 ) \n #define  Brown        vec3 ( 0.65, 0.16, 0.16 ) \n #define  Burlywood        vec3 ( 0.87, 0.72, 0.53 ) \n #define  CadetBlue        vec3 ( 0.37, 0.62, 0.63 ) \n #define  Chartreuse        vec3 ( 0.50, 1.00, 0.00 ) \n #define  Chocolate        vec3 ( 0.82, 0.41, 0.12 ) \n #define  Coral        vec3 ( 1.00, 0.50, 0.31 ) \n #define  Cornflower        vec3 ( 0.39, 0.58, 0.93 ) \n #define  Cornsilk        vec3 ( 1.00, 0.97, 0.86 ) \n #define  Crimson        vec3 ( 0.86, 0.08, 0.24 ) \n #define  Cyan        vec3 ( 0.00, 1.00, 1.00 ) \n #define  DarkBlue        vec3 ( 0.00, 0.00, 0.55 ) \n #define  DarkCyan        vec3 ( 0.00, 0.55, 0.55 ) \n #define  DarkGoldenrod        vec3 ( 0.72, 0.53, 0.04 ) \n #define  DarkGray        vec3 ( 0.66, 0.66, 0.66 ) \n #define  DarkGreen        vec3 ( 0.00, 0.39, 0.00 ) \n #define  DarkKhaki        vec3 ( 0.74, 0.72, 0.42 ) \n #define  DarkMagenta        vec3 ( 0.55, 0.00, 0.55 ) \n #define  DarkOliveGreen        vec3 ( 0.33, 0.42, 0.18 ) \n #define  DarkOrange        vec3 ( 1.00, 0.55, 0.00 ) \n #define  DarkOrchid        vec3 ( 0.60, 0.20, 0.80 ) \n #define  DarkRed        vec3 ( 0.55, 0.00, 0.00 ) \n #define  DarkSalmon        vec3 ( 0.91, 0.59, 0.48 ) \n #define  DarkSeaGreen        vec3 ( 0.56, 0.74, 0.56 ) \n #define  DarkSlateBlue        vec3 ( 0.28, 0.24, 0.55 ) \n #define  DarkSlateGray        vec3 ( 0.18, 0.31, 0.31 ) \n #define  DarkTurquoise        vec3 ( 0.00, 0.81, 0.82 ) \n #define  DarkViolet        vec3 ( 0.58, 0.00, 0.83 ) \n #define  DeepPink        vec3 ( 1.00, 0.08, 0.58 ) \n #define  DeepSkyBlue        vec3 ( 0.00, 0.75, 1.00 ) \n #define  DimGray        vec3 ( 0.41, 0.41, 0.41 ) \n #define  DodgerBlue        vec3 ( 0.12, 0.56, 1.00 ) \n #define  Firebrick        vec3 ( 0.70, 0.13, 0.13 ) \n #define  FloralWhite        vec3 ( 1.00, 0.98, 0.94 ) \n #define  ForestGreen        vec3 ( 0.13, 0.55, 0.13 ) \n #define  Fuchsia        vec3 ( 1.00, 0.00, 1.00 ) \n #define  Gainsboro        vec3 ( 0.86, 0.86, 0.86 ) \n #define  GhostWhite        vec3 ( 0.97, 0.97, 1.00 ) \n #define  Gold        vec3 ( 1.00, 0.84, 0.00 ) \n #define  Goldenrod        vec3 ( 0.85, 0.65, 0.13 ) \n #define  Gray        vec3 ( 0.75, 0.75, 0.75 ) \n #define  WebGray        vec3 ( 0.50, 0.50, 0.50 ) \n #define  Green        vec3 ( 0.00, 1.00, 0.00 ) \n #define  WebGreen        vec3 ( 0.00, 0.50, 0.00 ) \n #define  GreenYellow        vec3 ( 0.68, 1.00, 0.18 ) \n #define  Honeydew        vec3 ( 0.94, 1.00, 0.94 ) \n #define  HotPink        vec3 ( 1.00, 0.41, 0.71 ) \n #define  IndianRed        vec3 ( 0.80, 0.36, 0.36 ) \n #define  Indigo        vec3 ( 0.29, 0.00, 0.51 ) \n #define  Ivory        vec3 ( 1.00, 1.00, 0.94 ) \n #define  Khaki        vec3 ( 0.94, 0.90, 0.55 ) \n #define  Lavender        vec3 ( 0.90, 0.90, 0.98 ) \n #define  LavenderBlush        vec3 ( 1.00, 0.94, 0.96 ) \n #define  LawnGreen        vec3 ( 0.49, 0.99, 0.00 ) \n #define  LemonChiffon        vec3 ( 1.00, 0.98, 0.80 ) \n #define  LightBlue        vec3 ( 0.68, 0.85, 0.90 ) \n #define  LightCoral        vec3 ( 0.94, 0.50, 0.50 ) \n #define  LightCyan        vec3 ( 0.88, 1.00, 1.00 ) \n #define  LightGoldenrod        vec3 ( 0.98, 0.98, 0.82 ) \n #define  LightGray        vec3 ( 0.83, 0.83, 0.83 ) \n #define  LightGreen        vec3 ( 0.56, 0.93, 0.56 ) \n #define  LightPink        vec3 ( 1.00, 0.71, 0.76 ) \n #define  LightSalmon        vec3 ( 1.00, 0.63, 0.48 ) \n #define  LightSeaGreen        vec3 ( 0.13, 0.70, 0.67 ) \n #define  LightSkyBlue        vec3 ( 0.53, 0.81, 0.98 ) \n #define  LightSlateGray        vec3 ( 0.47, 0.53, 0.60 ) \n #define  LightSteelBlue        vec3 ( 0.69, 0.77, 0.87 ) \n #define  LightYellow        vec3 ( 1.00, 1.00, 0.88 ) \n #define  Lime        vec3 ( 0.00, 1.00, 0.00 ) \n #define  LimeGreen        vec3 ( 0.20, 0.80, 0.20 ) \n #define  Linen        vec3 ( 0.98, 0.94, 0.90 ) \n #define  Magenta        vec3 ( 1.00, 0.00, 1.00 ) \n #define  Maroon        vec3 ( 0.69, 0.19, 0.38 ) \n #define  WebMaroon        vec3 ( 0.50, 0.00, 0.00 ) \n #define  MediumAquamarine        vec3 ( 0.40, 0.80, 0.67 ) \n #define  MediumBlue        vec3 ( 0.00, 0.00, 0.80 ) \n #define  MediumOrchid        vec3 ( 0.73, 0.33, 0.83 ) \n #define  MediumPurple        vec3 ( 0.58, 0.44, 0.86 ) \n #define  MediumSeaGreen        vec3 ( 0.24, 0.70, 0.44 ) \n #define  MediumSlateBlue        vec3 ( 0.48, 0.41, 0.93 ) \n #define  MediumSpringGreen        vec3 ( 0.00, 0.98, 0.60 ) \n #define  MediumTurquoise        vec3 ( 0.28, 0.82, 0.80 ) \n #define  MediumVioletRed        vec3 ( 0.78, 0.08, 0.52 ) \n #define  MidnightBlue        vec3 ( 0.10, 0.10, 0.44 ) \n #define  MintCream        vec3 ( 0.96, 1.00, 0.98 ) \n #define  MistyRose        vec3 ( 1.00, 0.89, 0.88 ) \n #define  Moccasin        vec3 ( 1.00, 0.89, 0.71 ) \n #define  NavajoWhite        vec3 ( 1.00, 0.87, 0.68 ) \n #define  NavyBlue        vec3 ( 0.00, 0.00, 0.50 ) \n #define  OldLace        vec3 ( 0.99, 0.96, 0.90 ) \n #define  Olive        vec3 ( 0.50, 0.50, 0.00 ) \n #define  OliveDrab        vec3 ( 0.42, 0.56, 0.14 ) \n #define  Orange        vec3 ( 1.00, 0.65, 0.00 ) \n #define  OrangeRed        vec3 ( 1.00, 0.27, 0.00 ) \n #define  Orchid        vec3 ( 0.85, 0.44, 0.84 ) \n #define  PaleGoldenrod        vec3 ( 0.93, 0.91, 0.67 ) \n #define  PaleGreen        vec3 ( 0.60, 0.98, 0.60 ) \n #define  PaleTurquoise        vec3 ( 0.69, 0.93, 0.93 ) \n #define  PaleVioletRed        vec3 ( 0.86, 0.44, 0.58 ) \n #define  PapayaWhip        vec3 ( 1.00, 0.94, 0.84 ) \n #define  PeachPuff        vec3 ( 1.00, 0.85, 0.73 ) \n #define  Peru        vec3 ( 0.80, 0.52, 0.25 ) \n #define  Pink        vec3 ( 1.00, 0.75, 0.80 ) \n #define  Plum        vec3 ( 0.87, 0.63, 0.87 ) \n #define  PowderBlue        vec3 ( 0.69, 0.88, 0.90 ) \n #define  Purple        vec3 ( 0.63, 0.13, 0.94 ) \n #define  WebPurple        vec3 ( 0.50, 0.00, 0.50 ) \n #define  RebeccaPurple        vec3 ( 0.40, 0.20, 0.60 ) \n #define  Red  vec3(1.00, 0.00, 0.00)\n #define  RosyBrown  vec3(0.74, 0.56, 0.56)\n #define  RoyalBlue  vec3(0.25, 0.41, 0.88)\n #define  SaddleBrown  vec3(0.55, 0.27, 0.07)\n #define  Salmon  vec3(0.98, 0.50, 0.45)\n #define  SandyBrown  vec3(0.96, 0.64, 0.38)\n #define  SeaGreen  vec3(0.18, 0.55, 0.34)\n #define  Seashell  vec3(1.00, 0.96, 0.93)\n #define  Sienna  vec3(0.63, 0.32, 0.18)\n #define  Silver  vec3(0.75, 0.75, 0.75)\n #define  SkyBlue  vec3(0.53, 0.81, 0.92)\n #define  SlateBlue  vec3(0.42, 0.35, 0.80)\n #define  SlateGray  vec3(0.44, 0.50, 0.56)\n #define  Snow  \t\tvec3(1.00, 0.98, 0.98)\n #define  SpringGreen        vec3 ( 0.00, 1.00, 0.50 ) \n #define  SteelBlue        vec3 ( 0.27, 0.51, 0.71 ) \n #define  Tan        vec3 ( 0.82, 0.71, 0.55 ) \n #define  Teal        vec3 ( 0.00, 0.50, 0.50 ) \n #define  Thistle        vec3 ( 0.85, 0.75, 0.85 ) \n #define  Tomato        vec3 ( 1.00, 0.39, 0.28 ) \n #define  Turquoise        vec3 ( 0.25, 0.88, 0.82 ) \n #define  Violet        vec3 ( 0.93, 0.51, 0.93 ) \n #define  Wheat        vec3 ( 0.96, 0.87, 0.70 ) \n #define  White        vec3 ( 1.00, 1.00, 1.00 ) \n #define  WhiteSmoke        vec3 ( 0.96, 0.96, 0.96 ) \n #define  Yellow        vec3 ( 1.00, 1.00, 0.00 ) \n #define  YellowGreen        vec3 ( 0.60, 0.80, 0.20 ) \n/*\n * Material colors.\n * \n * Originally by Hans Häggström, 2010.\n * Dual licenced under Creative Commons Attribution-Share Alike 3.0 and LGPL2 or later\n */\n\n #define  Oak  vec3(0.65, 0.5, 0.4)\n #define  Pine  vec3(0.85, 0.7, 0.45)\n #define  Birch  vec3(0.9, 0.8, 0.6)\n #define  FiberBoard  vec3(0.7, 0.67, 0.6)\n #define  BlackPaint   vec3     (0.2, 0.2, 0.2)\n\n\n \n//----------------------------------------------------------------------------------------\n #define  Steel vec3 (0.65, 0.67, 0.72)\n #define  Stainless vec3 (0.45, 0.43, 0.5)\n #define  Brass vec3 (0.88, 0.78, 0.5) \n #define  Iron vec3 (0.560,0.579,0.580)\n #define  Aluminium vec3 (0.913,0.921,0.925)\n #define  Aluminum vec3 (0.913,0.921,0.925)\n #define  Copper vec3 (0.955,0.637,0.538)\n #define  Chromium vec3 (0.550,0.556,0.554)\n #define  Nickel vec3 (0.660,0.609,0.526)\n #define  Titanium vec3 (0.542,0.497,0.440)\n #define  Cobalt vec3 (0.662,0655,0.634)\n #define  Rust vec3 (.183,.065,.001)\n\n//----------------------------------------------------------------------------------------\n// PBR Material struct TLC123\n//----------------------------------------------------------------------------------------\n \nstruct matr{\n  vec3 \trgb;\n  float rough;\n  float metal;\n  vec3 \tnormal;\n};\n\n#define nullv vec3(0.)\n  \n \n    \nmatr[] material =\n\tmatr[](\n        \n\t\tmatr(Black, .5, .2, nullv), \n        matr(White, 1., 0.2, nullv),        \n        matr(Steel, 1., 1., nullv),\n        matr(Stainless, 1., 1., nullv),\n        matr(Iron, 1., 1., nullv),\n        matr(Aluminium, 1., 1., nullv),\n        matr(Copper, 1., 1., nullv),\n        matr(Chromium, 1., 1., nullv),\n        matr(Nickel, 1., 1., nullv),\n        matr(Titanium, 1., 1., nullv),\n        matr(Cobalt, 1., 1., nullv),\n        matr(Steel, 1., 1., nullv),\n        matr(Steel, 1., 1., nullv),\n        matr(Steel, 1., 1., nullv),\n        matr(Steel, 1., 1., nullv)\n        \n      );\n\n//----------------------------------------------------------------------------------------\n// Quaternios\n//----------------------------------------------------------------------------------------\n vec4 NormQuat(vec4 q)\n{\n    float lenSQ = dot(q, q);\n    float invLenSQ = 1./lenSQ;\n    return q*invLenSQ;\n}\n\nvec4 BuildQuat(vec3 axis, float angle)\n{\n    angle *= 0.5;\n    float s = sin(angle);\n    return NormQuat(vec4(axis*s, cos(angle)));\n}\n\nvec4 MulQuat(vec4 q1, vec4 q2)\n{\n    vec4 res = vec4(0.);\n    res.w   = q1.w*q2.w - dot(q1.xyz, q2.xyz);\n    res.xyz = q1.w*q2.xyz + q2.w*q1.xyz + cross(q1.xyz, q2.xyz);\n    return NormQuat(res);\n}\n\n \n    \nvec3 Rotate(vec4 q, vec3 v)\n{\n    vec3 t = 2.*cross(q.xyz, v);\n    return v + q.w*t + cross(q.xyz, t);\n}\n\n\nfloat fromTo(vec3 p,vec3 q)\n{\nreturn acos(dot(p,q));\n\n}\nvec4 quatLookAt(vec3 forward,vec3 up){\n    forward=normalize(forward);\n    up=normalize(up);\nreturn  (BuildQuat(cross(forward,up),fromTo(forward,up)));\n}\n\n\nvec4 quatInv(in vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\n//https://en.wikipedia.org/wiki/Slerp#Quaternion_Slerp\n\nvec4 slerp(vec4 v0, vec4 v1, float t) {\n    // Only unit quaternions are valid rotations.\n    // Normalize to avoid undefined behavior.\n     NormQuat(v0);\n     NormQuat(v1);\n\n    // Compute the cosine of the angle between the two vectors.\n    float dotp = dot(v0, v1);\n\n    // If the dot product is negative, slerp won't take\n    // the shorter path. Note that v1 and -v1 are equivalent when\n    // the negation is applied to all four components. Fix by \n    // reversing one quaternion.\n    if (dotp < 0.0f) {\n        v1 = -v1;\n        dotp = -dotp;\n    }  \n\n      float DOT_THRESHOLD = 0.9995;\n    if (dotp > DOT_THRESHOLD) {\n        // If the inputs are too close for comfort, linearly interpolate\n        // and normalize the result.\n\n        vec4 result = v0 + t*(v1 - v0);\n        NormQuat(result);\n        return result;\n    }\n\n    // Since dot is in range [0, DOT_THRESHOLD], acos is safe\n    float theta_0 = acos(dotp);        // theta_0 = angle between input vectors\n    float theta = theta_0*t;          // theta = angle between v0 and result\n    float sin_theta = sin(theta);     // compute this value only once\n    float sin_theta_0 = sin(theta_0); // compute this value only once\n\n    float s0 = cos(theta) - dotp * sin_theta / sin_theta_0;  // == sin(theta_0 - theta) / sin(theta_0)\n    float s1 = sin_theta / sin_theta_0;\n\n    return (s0 * v0) + (s1 * v1);\n}\n//----------------------------------------------------------------------------------------\n// rotate by matirx\n//----------------------------------------------------------------------------------------\n\nvec3 rotxyz(mat3 m, vec3 p){\n    \nreturn vec3(p.x*m[0]+p.y*m[1]+p.z*m[2]);\n}\n\n\n\n//----------------------------------------------------------------------------------------\n// Hash without Sine  https://www.shadertoy.com/view/4djSRW\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n//----------------------------------------------------------------------------------------\n//// Created by inigo quilez - iq/2014\n//----------------------------------------------------------------------------------------\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat noise13( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( \n        mix(\n                mix( hash13( i + vec3(0.0,0.0,0.0) ), \n                     hash13( i + vec3(1.0,0.0,0.0) ), u.x),\n                mix( hash13( i + vec3(0.0,1.0,0.0) ), \n                     hash13( i + vec3(1.0,1.0,0.0) ), u.x)\n               , u.y),\n              mix(\n                mix( hash13( i + vec3(0.0,0.0,1.0) ), \n                     hash13( i + vec3(1.0,0.0,1.0) ), u.x),\n                mix( hash13( i + vec3(0.0,1.0,1.0) ), \n                     hash13( i + vec3(1.0,1.0,1.0) ), u.x)\n               , u.y)\n        \n         , u.z)\n        ;\n}\n\nvec3 noise33(  vec3 p )\n{\n    p=p+10000.;\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u;\n    u.x = f.x*f.x*(3.0-2.0*f.x);\n    u.y = f.y*f.y*(3.0-2.0*f.y);\n    u.z = f.z*f.z*(3.0-2.0*f.z);\n\n    return mix( \n        mix(\n                mix( hash33( i + vec3(0.0,0.0,0.0) ), \n                     hash33( i + vec3(1.0,0.0,0.0) ), u.x),\n                mix( hash33( i + vec3(0.0,1.0,0.0) ), \n                     hash33( i + vec3(1.0,1.0,0.0) ), u.x)\n               , u.y),\n              mix(\n                mix( hash33( i + vec3(0.0,0.0,1.0) ), \n                     hash33( i + vec3(1.0,0.0,1.0) ), u.x),\n                mix( hash33( i + vec3(0.0,1.0,1.0) ), \n                     hash33( i + vec3(1.0,1.0,1.0) ), u.x)\n               , u.y)\n        \n         , u.z)\n        ;\n}\n\nfloat fbm( vec2 p )\n{\n      mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nvec3 fbm33( vec3 p )\n{\n   \n     mat3 m = mat3(vec3(0.80,  0.60, -0.6).xyz,\n                    vec3(0.80,  0.60, -0.6).yzx,\n                    vec3(0.80,  0.60, -0.6).zxy);\n    vec3 f = vec3(0.0);\n    f += 0.5000*noise33( p ); p = m*p*2.02;\n    f += 0.2500*noise33( p ); p = m*p*2.03;\n    f += 0.1250*noise33( p ); p = m*p*2.01;\n    f += 0.0625*noise33( p );\n    return f/0.9375;\n}\n\nfloat fbm13( vec3 p )\n{\n         float m =1.;\n\n\n    float f =  (0.0);\n    f += 0.5000*noise13( p ); p = m*p*2.02;\n    f += 0.2500*noise13( p ); p = m*p*2.03;\n    f += 0.1250*noise13( p ); p = m*p*2.01;\n    f += 0.0625*noise13( p );\n    return f/0.9375;\n}\n\nvec2 fbm2( in vec2 p )\n{\n    return vec2( fbm(p.xy), fbm(p.yx) );\n}\n\n\nvec3 fbm33Grad( in vec3 position) {\n\tvec3 epsilon = vec3(0.001, 0.0, 0.0);\n\tvec3 n = vec3(\n\t\tfbm13(position + epsilon.xyy)  - fbm13(position - epsilon.xyy) ,\n\t\tfbm13(position + epsilon.yxy) - fbm13(position - epsilon.yxy) ,\n\t\tfbm13(position + epsilon.yyx) - fbm13(position - epsilon.yyx) );\n\treturn normalize(n);\n}\n\n \n\n//----------------------------------------------------------------------------------------\n//  gradients by IQ\n//----------------------------------------------------------------------------------------\nfloat f(vec2 p){return  0.;}\n\nvec2 grad( in vec2 x )\n{\n    vec2 h = vec2( 0.01, 0.0 );\n    return vec2( f(x+h.xy) - f(x-h.xy),\n                 f(x+h.yx) - f(x-h.yx) )/(2.0*h.x);\n}\n \nfloat color( in vec2 x )\n{\n    float v = f( x );\n    vec2  g = grad( x );\n    float de = abs(v)/length(g);\n    float eps = 1.;\n    return smoothstep( 1.0*eps, 2.0*eps, de );\n}\n\n\n\n//----------------------------------------------------------------------------------------\n//http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n//----------------------------------------------------------------------------------------\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat dot2(vec2 a ) { return dot(a,a); }\n\n \nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\n \nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n \nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\n \nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\n \nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n \nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n \nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\n \nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n \nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\n \nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n \nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n \nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\n \nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 6.283185/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon,\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n \nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n \nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c = sin/cos of the aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\n \nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n \nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p;\n    p = vec2((p.y>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\n \nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\n\n \nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return sign(k)*length(max(w,0.0)) + r;\n}\n\n \n \n \nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n \nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n        vec2 qos = d + (c + b*t)*t;\n        res = dot(qos,qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n        vec2 qos = d + (c + b*t.x)*t.x;\n        res = dot(qos,qos);\n        qos = d + (c + b*t.y)*t.y;\n        res = min(res,dot(qos,qos));\n        qos = d + (c + b*t.z)*t.z;\n        res = min(res,dot(qos,qos));\n    }\n    return sqrt( res );\n}\n\n \nfloat sdRoundedShape( float d, in float r )\n{\n  return d - r;\n}\n \nfloat sdAnnularShape( float d, in float r )\n{\n  return abs(d) - r;\n}\n\n \n//----------------------------------------------------------------------------------------\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//----------------------------------------------------------------------------------------\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n \nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n \nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n \nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n \nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n \nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n \nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n \nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n \nfloat sdPlane( vec3 p  )\n{\n  // n must be normalized\n  return p.y;\n}\n \nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n \nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n \nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n \nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\n \nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n \nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n \nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n \nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n \nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n \nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n \nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n \n \n\n \nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n \n float udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n \nvec3 opElongate(  in vec3 p, in vec3 h )\n{\n    vec3 q = p - clamp( p, -h, h );\n    return   q ;\n}\n\n \n \n\n \n \n\n \nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n \nvec2 min2(vec2 a,vec2 b){return a.x<b.x?a:b;}\nvec2 max2(vec2 a,vec2 b){return a.x>b.x?a:b;}\n \nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nvec2 opUnion( vec2 d1, vec2 d2 ) { return min2(d1,d2); }\n\nvec2 opSubtraction( vec2 d1, vec2 d2 ) { return max2(vec2(-d1.x,d1.y),d2); }\n\nvec2 opIntersection( vec2 d1, vec2 d2 ) { return max2(d1,d2); }\n\n \n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nvec2 opSmoothUnion( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2( mix( d2.x, d1.x, h ) - k*h*(1.0-h), d1.x<d2.x?d1.y:d2.y); }\n\nvec2 opSmoothSubtraction( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2( mix( d2.x, -d1.x, h ) + k*h*(1.0-h), d1.x<d2.x?d1.y:d2.y); }\n\nvec2 opSmoothIntersection( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return vec2(  mix( d2.x, d1.x, h ) + k*h*(1.0-h), d1.x<d2.x?d1.y:d2.y); }\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2016-01-10\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n//\n//\n//\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n//\n////////////////////////////////////////////////////////////////\n//\n// How to use this:\n//\n// 1. Build some system to #include glsl files in each other.\n//   Include this one at the very start. Or just paste everywhere.\n// 2. Build a sphere tracer. See those papers:\n//   * \"Sphere Tracing\" http://graphics.cs.illinois.edu/sites/default/files/zeno.pdf\n//   * \"Enhanced Sphere Tracing\" http://lgdv.cs.fau.de/get/2234\n//   The Raymnarching Toolbox Thread on pouet can be helpful as well\n//   http://www.pouet.net/topic.php?which=7931&page=1\n//   and contains links to many more resources.\n// 3. Use the tools in this library to build your distance bound f().\n// 4. ???\n// 5. Win a compo.\n// \n// (6. Buy us a beer or a good vodka or something, if you like.)\n//\n////////////////////////////////////////////////////////////////\n//\n// Table of Contents:\n//\n// * Helper functions and macros\n// * Collection of some primitive objects\n// * Domain Manipulation operators\n// * Object combination operators\n//\n////////////////////////////////////////////////////////////////\n//\n// Why use this?\n//\n// The point of this lib is that everything is structured according\n// to patterns that we ended up using when building geometry.\n// It makes it more easy to write code that is reusable and that somebody\n// else can actually understand. Especially code on Shadertoy (which seems\n// to be what everybody else is looking at for \"inspiration\") tends to be\n// really ugly. So we were forced to do something about the situation and\n// release this lib ;)\n//\n// Everything in here can probably be done in some better way.\n// Please experiment. We'd love some feedback, especially if you\n// use it in a scene production.\n//\n// The main patterns for building geometry this way are:\n// * Stay Lipschitz continuous. That means: don't have any distance\n//   gradient larger than 1. Try to be as close to 1 as possible -\n//   Distances are euclidean distances, don't fudge around.\n//   Underestimating distances will happen. That's why calling\n//   it a \"distance bound\" is more correct. Don't ever multiply\n//   distances by some value to \"fix\" a Lipschitz continuity\n//   violation. The invariant is: each fSomething() function returns\n//   a correct distance bound.\n// * Use very few primitives and combine them as building blocks\n//   using combine opertors that preserve the invariant.\n// * Multiply objects by repeating the domain (space).\n//   If you are using a loop inside your distance function, you are\n//   probably doing it wrong (or you are building boring fractals).\n// * At right-angle intersections between objects, build a new local\n//   coordinate system from the two distances to combine them in\n//   interesting ways.\n// * As usual, there are always times when it is best to not follow\n//   specific patterns.\n//\n////////////////////////////////////////////////////////////////\n//\n// FAQ\n//\n// Q: Why is there no sphere tracing code in this lib?\n// A: Because our system is way too complex and always changing.\n//    This is the constant part. Also we'd like everyone to\n//    explore for themselves.\n//\n// Q: This does not work when I paste it into Shadertoy!!!!\n// A: Yes. It is GLSL, not GLSL ES. We like real OpenGL\n//    because it has way more features and is more likely\n//    to work compared to browser-based WebGL. We recommend\n//    you consider using OpenGL for your productions. Most\n//    of this can be ported easily though.\n//\n// Q: How do I material?\n// A: We recommend something like this:\n//    Write a material ID, the distance and the local coordinate\n//    p into some global variables whenever an object's distance is\n//    smaller than the stored distance. Then, at the end, evaluate\n//    the material to get color, roughness, etc., and do the shading.\n//\n// Q: I found an error. Or I made some function that would fit in\n//    in this lib. Or I have some suggestion.\n// A: Awesome! Drop us a mail at spheretracing@mercury.sexy.\n//\n// Q: Why is this not on github?\n// A: Because we were too lazy. If we get bugged about it enough,\n//    we'll do it.\n//\n// Q: Your license sucks for me.\n// A: Oh. What should we change it to?\n//\n// Q: I have trouble understanding what is going on with my distances.\n// A: Some visualization of the distance field helps. Try drawing a\n//    plane that you can sweep through your scene with some color\n//    representation of the distance field at each point and/or iso\n//    lines at regular intervals. Visualizing the length of the\n//    gradient (or better: how much it deviates from being equal to 1)\n//    is immensely helpful for understanding which parts of the\n//    distance field are broken.\n//\n////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0, 1)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\nfloat square (float x) {\n\treturn x*x;\n}\n\nvec2 square (vec2 x) {\n\treturn x*x;\n}\n\nvec3 square (vec3 x) {\n\treturn x*x;\n}\n\nfloat lengthSqr(vec3 x) {\n\treturn dot(x, x);\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that is a distance function is called fSomething.\n// The first argument is always a point in 2 or 3-space called <p>.\n// Unless otherwise noted, (if the object has an intrinsic \"up\"\n// side or direction) the y axis is \"up\" and the object is\n// centered at the origin.\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n\treturn vmax(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n\n// Endless \"corner\"\nfloat fCorner (vec2 p) {\n\treturn length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\n \n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = clamp(dot(p - a, ab) / dot(ab, ab),0.,1.);\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// A circle line. Can also be used to make a torus by subtracting the smaller radius of the torus.\nfloat fCircle(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn length(vec2(p.y, l));\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n\t//this is mathematically equivalent to this line, but less efficient:\n\t//return max(q.y - h.y, max(dot(vec2(cos(PI/3), sin(PI/3)), q.zx), q.z) - h.x);\n}\n\n// Hexagonal prism, incircle variant\nfloat fHexagonIncircle(vec3 p, vec2 h) {\n\treturn fHexagonCircumcircle(p, vec2(h.x*sqrt(3.)*0.5, h.y));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n \n\n\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that modifies the domain is named pSomething.\n//\n// Many operate only on a subset of the three dimensions. For those,\n// you must choose the dimensions that you want manipulated\n// by supplying e.g. <p.x> or <p.zx>\n//\n// <inout p> is always the first argument and modified in place.\n//\n// Many of the operators partition space into cells. An identifier\n// or cell index is returned, if possible. This return value is\n// intended to be optionally used e.g. as a random seed to change\n// parameters of the distance functions inside the cells.\n//\n// Unless stated otherwise, for cell index 0, <p> is unchanged and cells\n// are centered on the origin so objects don't have to be moved to fit.\n//\n//\n////////////////////////////////////////////////////////////////\n\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Same, but mirror every second cell so they match at the boundaries\nfloat pModMirror1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0)*2. - 1.;\n\treturn c;\n}\n\n// Repeat the domain only in positive direction. Everything in the negative half-space is unchanged.\nfloat pModSingle1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tif (p >= 0.)\n\t\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2))*2. - vec2(1.);\n\treturn c;\n}\n\n// Same, but mirror every second cell at the diagonal as well\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\tp *= mod(c,vec2(2))*2. - vec2(1);\n\tp -= size/2.;\n\tif (p.x > p.y) p.xy = p.yx;\n\treturn floor(c/2.);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sgn(t);\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// We usually need the following boolean operators to combine two objects:\n// Union: OR(a,b)\n// Intersection: AND(a,b)\n// Difference: AND(a,!b)\n// (a and b being the distances to the objects).\n//\n// The trivial implementations are min(a,b) for union, max(a,b) for intersection\n// and max(a,-b) for difference. To combine objects in more interesting ways to\n// produce rounded edges, chamfers, stairs, etc. instead of plain sharp edges we\n// can use combination operators. It is common to use some kind of \"smooth minimum\"\n// instead of min(), but we don't like that because it does not preserve Lipschitz\n// continuity in many cases.\n//\n// Naming convention: since they return a distance, they are called fOpSomething.\n// The different flavours usually implement all the boolean operators above\n// and are called fOpUnionRound, fOpIntersectionRound, etc.\n//\n// The basic idea: Assume the object surfaces intersect at a right angle. The two\n// distances <a> and <b> constitute a new local two-dimensional coordinate system\n// with the actual intersection as the origin. In this coordinate system, we can\n// evaluate any 2D distance function we want in order to shape the edge.\n//\n// The operators below are just those that we found useful or interesting and should\n// be seen as examples. There are infinitely more possible operators.\n//\n// They are designed to actually produce correct distances or distance bounds, unlike\n// popular \"smooth minimum\" operators, on the condition that the gradients of the two\n// SDFs are at right angles. When they are off by more than 30 degrees or so, the\n// Lipschitz condition will no longer hold (i.e. you might get artifacts). The worst\n// case is parallel surfaces that are close to each other.\n//\n// Most have a float argument <r> to specify the radius of the feature they represent.\n// This should be much smaller than the object size.\n//\n// Some of them have checks like \"if ((-a < r) && (-b < r))\" that restrict\n// their influence (and computation cost) to a certain area. You might\n// want to lift that restriction or enforce it. We have left it as comments\n// in some cases.\n//\n// usage example:\n//\n// float fTwoBoxes(vec3 p) {\n//   float box0 = fBox(p, vec3(1));\n//   float box1 = fBox(p-vec3(1), vec3(1));\n//   return fOpUnionChamfer(box0, box1, 0.2);\n// }\n//\n////////////////////////////////////////////////////////////////\n\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n\treturn max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n\treturn fOpIntersectionChamfer(a, -b, r);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n\ta = -a;\n\tfloat m = min(a, b);\n\t//avoid the expensive computation where not needed (produces discontinuity though)\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/n/2.0;\n\t\tcolumnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\n\t\tpR45(p);\n\t\tp.y += columnradius;\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += -columnradius*sqrt(2.)/2.;\n\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\tpMod1(p.y,columnradius*2.);\n\n\t\tfloat result = -length(p) + columnradius;\n\t\tresult = max(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn -min(result, b);\n\t} else {\n\t\treturn -m;\n\t}\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n\treturn fOpDifferenceColumns(a,-b,r, n);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\n\n// Similar to fOpUnionRound, but more lipschitz-y at acute angles\n// (and less so at 90 degrees). Useful when fudging around too much\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\n\n// produces a cylindical pipe that runs along the intersection.\n// No objects remain, only the pipe. This is not a boolean operator.\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\n// first object gets a v-shaped engraving where it intersect the second\nfloat fOpEngrave(float a, float b, float r) {\n\treturn max(a, (a + r - abs(b))*sqrt(0.5));\n}\n\n// first object gets a capenter-style groove cut out\nfloat fOpGroove(float a, float b, float ra, float rb) {\n\treturn max(a, min(a + ra, rb - abs(b)));\n}\n\n// first object gets a capenter-style tongue attached\nfloat fOpTongue(float a, float b, float ra, float rb) {\n\treturn min(a, max(a - ra, abs(b) - rb));\n}\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / PI;\n}\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n// ACES fitted\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\n\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wdcSRr",
    "date": "0",
    "viewed": 0,
    "name": "Branching  Mapping",
    "description": "i couldn't fint it so i made it",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "specialmapping"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Root branching pattern\" by TLC123. https://shadertoy.com/view/tdV3Dd\n// 2019-10-17 07:28:02\n\nfloat  anytexture(vec2 uv){\nreturn float(mod(floor(uv.x) + floor(uv.y *2. ), 2.));\n}\n\n\nfloat fu(vec2 uv) {\n    float Y =  (  pow(1.56,uv.y ) ),\n          y = fract(Y),\n          o = exp2( floor(Y)),\n          x = abs( fract(   uv.x * o ) - .5 ),\n        \n        p=anytexture(vec2(uv.x * o ,Y));\n    \n    //      p = 1. - abs(  x - smoothstep(0., 1., y) / 4.);\n    //p= mix( p, p * p, y * 1.333) + .15 / abs(Y - .5);\n    \n    return p;\n}\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n\n    float t = iTime;\n    U = U / iResolution.x - vec2(.5, .15);\n    U *= 7. + sin(t) * 5.;\n    U += 1.* vec2( sin(t*.17) , cos(t*.13) );\n    \n    float l =  length(U),\n          v = mod(iTime, 30.) < 25. \n              ?  fu( vec2(  ( atan(U.y,U.x) + sin(t*.1) * 4. ) / 6.28 \n                           * floor( 5. + sin(t*.4) *3. ) \n                          ,  l +1.\n                    )    )\n                   /  max(1., l*l*.125)\n              :  fu(U);\n\n    v *= .75;\n\n    O = vec4( smoothstep(0., 1., v ) );\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3lBGzt",
    "date": "1560621337",
    "viewed": 126,
    "name": "ChamferBox Super Primitive",
    "description": "My goal was  a super primitive of a Chamfer Box that also take a secondary rounding parameter on the new edges. Sphere, Cuboid and Octahedron in one continuum.\nfinalized 2019 with function sdOctahedron( in vec3 p, in float s)// by Iq  ",
    "likes": 5,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "sdf"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"ChamferBox\" by TLC123. https://shadertoy.com/view/ltdSzX\n// 2019-06-15 17:45:33\n// ChamferBox and map created by TLC123 \n// Everything else adapted from stuff Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n \n \n\nfloat sdOctahedron( in vec3 p, in float s)// by Iq 2019\n{\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n \n\n \n\n \n \n\n\tfloat ChamferBox(vec3 op, vec3 b, float ch, float r) {\nvec3 p=abs(op)+vec3(ch)+vec3( r);\n       p=max(vec3(0),p-b); \n\nfloat d =sdOctahedron(   p,   ch)\n           ;\n \n \n return d  -r ;\t\t}\n//----------------------------------------------------------------------\n\n \n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n\n//a bunch of fudging  numbers to drive demo\n float vari=0.5;\n float pivot=.85;   \nvec3 box = 2.0*normalize( vec3 (  pivot + sin(48.2+iTime*0.783116+1.  )*vari ,pivot+sin(131.2+iTime*0.953116  )*vari ,pivot+sin(4.2+iTime*0.43 )*vari ));\n float mb= min(min(box.x,box.y),box.z);\n    \nfloat ch=   0.9* mb*( .5+sin(414.5+ 1.+iTime*0.53116  )*.450)  ;\n    float r=    mb*    ( (0.5+ cos(2.+iTime*0.261265)*.50)) ;\n\n    float d= ChamferBox(pos+ vec3(1.5,0.,1.5) , box ,ch/max(min(mb,1.0),ch+r),r/max(min(mb,1.),ch+r));\n \n    \n    \n  box = 2.*normalize( vec3 (pivot+sin(16.2+iTime*0.93116+1.  )*vari ,pivot+sin(311.2+iTime*0.953116  )*vari,pivot+sin(4.2+iTime*0.823116  )*vari ));\n \n  mb= min(min(box.x,box.y),box.z);      \n    ch=     0.9* mb*(.5+ sin(31.+iTime*0.73116  )*.450)  ;\n      r=        mb*  ( (0.5+ cos(2.3+iTime*0.3261265)*.50)) ;\n float  dd= ChamferBox(pos+ vec3(-1.5,0.,1.5) , box  ,ch/max(min(mb,1.0),ch+r),r/max(min(mb,1.),ch+r));\n \n    \n      d=min(d,dd);\n  box = 2.*normalize( vec3 (pivot+sin(34.2+iTime*0.973116+1.  )*vari,pivot+sin(234.2+iTime*0.7153116  )*vari ,pivot+sin(24.2+iTime*0.993116  )*vari ));\n \n    mb= min(min(box.x,box.y),box.z); \n       ch=    0.9*  mb*( .5+ sin(22.3+iTime*0.843116  )*.450)  ;\n      r=       mb*   ( (0.5+ cos(1.6+iTime*0.63261265)*.50)) ;\n      dd= ChamferBox(pos+ vec3(1.5,0.,-1.5) , box  , ch/max(min(mb,1.0),ch+r),r/max(min(mb,1.),ch+r));\n \n   \n    d=min(d,dd);\n  box =  2.*normalize(vec3 (pivot+sin(43.2+iTime*0.83116+1.  )*vari ,pivot+ sin(3.2+iTime*0.8253116  )*vari ,pivot+sin(14.2+iTime*0.763116  )*vari ));\n \n    mb= min(min(box.x,box.y),box.z);      \n     ch=   0.9* mb*( 0.5+ sin(10.3+iTime*0.8143116  )*.450)  ;\n      r=       mb*   ( (0.5+ cos(1.2+iTime*0.563261265)*.50)) ;\n      dd= ChamferBox(pos+ vec3(-1.5,0.,-1.5) ,box   ,ch/max(min(mb,1.0),ch+r),r/max(min(mb,1.),ch+r));\n \n    d=min(d,dd);\n\nreturn vec2(  d  ,25);\n }\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 20.0;\n    \n#if 0\n    float tp1 = (0.0-ro.y)/rd.y; if( tp1>0.0 ) tmax = min( tmax, tp1 );\n    float tp2 = (1.6-ro.y)/rd.y; if( tp2>0.0 ) { if( ro.y>1.6 ) tmin = max( tmin, tp2 );\n                                                 else           tmax = min( tmax, tp2 ); }\n#endif\n    \n\tfloat precis = 0.0002;\n    float t = tmin;\n    float m = -1.0;\n    for( int i=-0; i<250; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x*0.2;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n\n\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.45 + 0.3*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t\n        if( m<1.5 )\n        {\n            \n            float f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n            col = 0.4 + 0.1*f*vec3(1.0);\n        }\n\n        // lighitng        \n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= softshadow( pos, lig, 0.02, 2.5 );\n        dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 1.20*dif*vec3(1.00,0.85,0.55);\n\t\tlin += 1.20*spe*vec3(1.00,0.85,0.55)*dif;\n        lin += 0.20*amb*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*dom*vec3(0.50,0.70,1.00)*occ;\n        lin += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec2 p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n\n\t// camera\t\n\tvec3 ro = 1.2*vec3( -0.5+3.5*cos(1.6*time + 6.0*mo.x), 3.0 + 2.0*mo.y, 0.5 + 3.5*sin(1.6*time + 6.0*mo.x) );\n\tvec3 ta = vec3( -0.0, -0.0, 0. ) ;\n\t\n\t// camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n    \n    // ray direction\n\tvec3 rd = ca * normalize( vec3(p.xy,2.0) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n\tcol = pow( col, vec3(0.4545) );\n\n    fragColor=vec4( col, 1.0 );\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Wdjczz",
    "date": "0",
    "viewed": 0,
    "name": "Concave Mesh SDF",
    "description": "Polyhedron, Triangle mesh, SDF ,",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "sdf",
     "triangle",
     "distance",
     "mesh",
     "polyhedron",
     "concave",
     "curv"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "MsSXDV",
       "filepath": "https://soundcloud.com/yennyskev/100-wet",
       "type": "musicstream",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 0
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Concave polyhedron SDF\" by TLC123. https://shadertoy.com/view/XltyWB\n// 2020-04-04 09:08:16\n\n//based on https://www.shadertoy.com/view/4sXXRN\n\n// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// use https://jsfiddle.net/tlc123/xwp8ut3d/25/ to convert\n\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n//-------------------------------------------------------------------------------- \n\n\n//    A little experiment with Concave polyhedron  SDFs.\n\n//    The motivation was to be able to use triangle meshes in CSG ops with other SDFs.\n    \n//    Polyhedron  must be a closed non intersecting mesh. \n\n//    Some artifacs appear at narrow or coplanar faces (fixed) \n\n//    Defined as a collection of triangles, yeah like a stl donit.\n\n//    For each calculationg a pair of unsigned distance and one inside/outside number. \n    \n//    Basically the closest triangle get first shot to call inside/outside.\n   \n//        but there are some edgecases that requires extra bits\n     \n//        some logic v=  abs(v1.x-v.x)<0.001? (v1.y>v.y?v1:v):     v1.x<=v.x?v1:v; \n\n//    Generally sound sdf, some edge leakage and some GLSL issues.  \n     \n//    In demo Polyhedra is differenced by sphere and smooth unioned with \n//    ground plane to showcase full sdf capabilites\n\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n// music credit to https://soundcloud.com/yennyskev/100-wet\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n\n\n\n\n\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;}\nfloat smin( float a, float b, float k )\n{    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);}\n\n \nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nvec2 dTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n float side=dot(p-v1,nor);\n  float  dist=( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n    return vec2(dist,side);\n}\n\n \n//=====================================================\nvec2 distlogic(vec2 v,vec2 v1){\nreturn abs(v1.r-v.r)< // if distances are\n             0.00001 // closer than some fugde factor\n             * max(max(v1.r,v.r),1.) // that gets a little larger further out but never below 1\n              ? (v1.g<=0. && v.g<=0.)? (v1.g<v.g?v1:v) : (v1.g>v.g?v1:v) :\n                          //select most positive side\n    \t\tv1.r<=v.r?v1:v; // or the common case;\n}\n\nfloat MyPolyhedron(vec3 p )\n{  \n   vec2 v=vec2( 1e+25,0.) ;\nint numberOfFaces=36;\nvec3[] points = vec3[] (vec3(8.81591701508,21.8541851044,14.3616361618),vec3(7.44091033936,23.3522720337,25.0458030701),vec3(10.3873872757,6.75782680511,25.1022548676),vec3(-6.350233078,6.82580089569,8.478556633),vec3(-9.91341304779,17.7780208588,21.9961891174),vec3(-6.82484054565,23.4799690247,12.1470556259),vec3(5.04093933105,-17.7688713074,14.1287736893),vec3(-5.62336301804,-20.4358348846,14.2187976837),vec3(-6.1624789238,-8.46228694916,10.2179460526),vec3(-5.62336301804,-20.4358348846,14.2187976837),vec3(-1.14260208607,-14.0449886322,25.825138092),vec3(-6.1624789238,-8.46228694916,10.2179460526),vec3(10.3873872757,6.75782680511,25.1022548676),vec3(-1.19344377518,15.5543146133,30.9838905334),vec3(3.24834489822,-2.3164730072,29.867105484),vec3(-1.19344377518,15.5543146133,30.9838905334),vec3(-1.14260208607,-14.0449886322,25.825138092),vec3(3.24834489822,-2.3164730072,29.867105484),vec3(10.3873872757,6.75782680511,25.1022548676),vec3(10.009557724,-4.17630958557,19.5363082886),vec3(8.81591701508,21.8541851044,14.3616361618),vec3(8.81591701508,21.8541851044,14.3616361618),vec3(1.30648517609,24.8290882111,4.29085683823),vec3(-1.33641219139,30.2954864502,21.6504554749),vec3(-1.33641219139,30.2954864502,21.6504554749),vec3(7.44091033936,23.3522720337,25.0458030701),vec3(8.81591701508,21.8541851044,14.3616361618),vec3(-9.91341304779,17.7780208588,21.9961891174),vec3(-10.2037801743,2.0173895359,22.2149791718),vec3(-1.19344377518,15.5543146133,30.9838905334),vec3(-1.14260208607,-14.0449886322,25.825138092),vec3(-5.62336301804,-20.4358348846,14.2187976837),vec3(0.486758202314,-24.8606567383,24.7508449554),vec3(-6.350233078,6.82580089569,8.478556633),vec3(5.61173677444,10.9682760239,7.64361476898),vec3(5.5680270195,-4.69412326813,5.57577466965),vec3(-10.2037801743,2.0173895359,22.2149791718),vec3(-1.14260208607,-14.0449886322,25.825138092),vec3(-1.19344377518,15.5543146133,30.9838905334),vec3(7.44091033936,23.3522720337,25.0458030701),vec3(-1.33641219139,30.2954864502,21.6504554749),vec3(-1.19344377518,15.5543146133,30.9838905334),vec3(1.0594329834,-30.2398967743,16.2578411102),vec3(-5.62336301804,-20.4358348846,14.2187976837),vec3(5.04093933105,-17.7688713074,14.1287736893),vec3(10.3873872757,6.75782680511,25.1022548676),vec3(3.24834489822,-2.3164730072,29.867105484),vec3(10.009557724,-4.17630958557,19.5363082886),vec3(5.5680270195,-4.69412326813,5.57577466965),vec3(10.009557724,-4.17630958557,19.5363082886),vec3(5.04093933105,-17.7688713074,14.1287736893),vec3(1.0594329834,-30.2398967743,16.2578411102),vec3(0.486758202314,-24.8606567383,24.7508449554),vec3(-5.62336301804,-20.4358348846,14.2187976837),vec3(10.3873872757,6.75782680511,25.1022548676),vec3(7.44091033936,23.3522720337,25.0458030701),vec3(-1.19344377518,15.5543146133,30.9838905334),vec3(-6.82484054565,23.4799690247,12.1470556259),vec3(8.81591701508,21.8541851044,14.3616361618),vec3(5.61173677444,10.9682760239,7.64361476898),vec3(-1.14260208607,-14.0449886322,25.825138092),vec3(10.009557724,-4.17630958557,19.5363082886),vec3(3.24834489822,-2.3164730072,29.867105484),vec3(-1.33641219139,30.2954864502,21.6504554749),vec3(-9.91341304779,17.7780208588,21.9961891174),vec3(-1.19344377518,15.5543146133,30.9838905334),vec3(8.81591701508,21.8541851044,14.3616361618),vec3(10.009557724,-4.17630958557,19.5363082886),vec3(5.5680270195,-4.69412326813,5.57577466965),vec3(1.30648517609,24.8290882111,4.29085683823),vec3(8.81591701508,21.8541851044,14.3616361618),vec3(-6.82484054565,23.4799690247,12.1470556259),vec3(10.009557724,-4.17630958557,19.5363082886),vec3(-1.14260208607,-14.0449886322,25.825138092),vec3(5.04093933105,-17.7688713074,14.1287736893),vec3(0.486758202314,-24.8606567383,24.7508449554),vec3(5.04093933105,-17.7688713074,14.1287736893),vec3(-1.14260208607,-14.0449886322,25.825138092),vec3(-10.2037801743,2.0173895359,22.2149791718),vec3(-9.91341304779,17.7780208588,21.9961891174),vec3(-6.350233078,6.82580089569,8.478556633),vec3(5.61173677444,10.9682760239,7.64361476898),vec3(8.81591701508,21.8541851044,14.3616361618),vec3(5.5680270195,-4.69412326813,5.57577466965),vec3(-1.14260208607,-14.0449886322,25.825138092),vec3(-10.2037801743,2.0173895359,22.2149791718),vec3(-6.1624789238,-8.46228694916,10.2179460526),vec3(-6.82484054565,23.4799690247,12.1470556259),vec3(5.61173677444,10.9682760239,7.64361476898),vec3(-6.350233078,6.82580089569,8.478556633),vec3(0.486758202314,-24.8606567383,24.7508449554),vec3(1.0594329834,-30.2398967743,16.2578411102),vec3(5.04093933105,-17.7688713074,14.1287736893),vec3(-6.1624789238,-8.46228694916,10.2179460526),vec3(-6.350233078,6.82580089569,8.478556633),vec3(5.5680270195,-4.69412326813,5.57577466965),vec3(-6.350233078,6.82580089569,8.478556633),vec3(-6.1624789238,-8.46228694916,10.2179460526),vec3(-10.2037801743,2.0173895359,22.2149791718),vec3(-1.33641219139,30.2954864502,21.6504554749),vec3(-6.82484054565,23.4799690247,12.1470556259),vec3(-9.91341304779,17.7780208588,21.9961891174),vec3(5.5680270195,-4.69412326813,5.57577466965),vec3(5.04093933105,-17.7688713074,14.1287736893),vec3(-6.1624789238,-8.46228694916,10.2179460526),vec3(1.30648517609,24.8290882111,4.29085683823),vec3(-6.82484054565,23.4799690247,12.1470556259),vec3(-1.33641219139,30.2954864502,21.6504554749) );\nvec3[] faces = vec3[] (vec3(0,1,2),vec3(3,4,5),vec3(6,7,8),vec3(9,10,11),vec3(12,13,14),vec3(15,16,17),vec3(18,19,20),vec3(21,22,23),vec3(24,25,26),vec3(27,28,29),vec3(30,31,32),vec3(33,34,35),vec3(36,37,38),vec3(39,40,41),vec3(42,43,44),vec3(45,46,47),vec3(48,49,50),vec3(51,52,53),vec3(54,55,56),vec3(57,58,59),vec3(60,61,62),vec3(63,64,65),vec3(66,67,68),vec3(69,70,71),vec3(72,73,74),vec3(75,76,77),vec3(78,79,80),vec3(81,82,83),vec3(84,85,86),vec3(87,88,89),vec3(90,91,92),vec3(93,94,95),vec3(96,97,98),vec3(99,100,101),vec3(102,103,104),vec3(105,106,107) );\n   for(int i =0; i<numberOfFaces;i++)\n{\n vec2 v1 = dTriangle( points[int( faces[i].y)]*0.03, points[int( faces[i].x)]*0.03, points[int( faces[i].z)]*0.03, p);\n v= distlogic(v,v1);\n}\nreturn (sqrt(v.x)*sign(v.y));\n}\n\nfloat map( in vec3 p )\n{\nfloat t= iTime*2.5; \np= vec3(p.x*cos(t)-p.z*sin(t ),p.y,p.z*cos(t )+p.x*sin(t )) ;\n    \nfloat mesh= MyPolyhedron(p);\n    // ground plane here\n\tfloat d2 = p.y + 1.0;\n    // sphere here\n\tvec3 ps = vec3(sin(-iTime),cos(-iTime),sin(2.-iTime)*2. )*0.7;\n    float sphere=sdSphere(p-ps,0.5);  \n\n    \n    return smin( max(-sphere,mesh), d2,0.5+sin(iTime/3.)*0.5 );\t\n}\n\n\n\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n//-------------------------------------------------------------------------------- \n\n\n\n\n// tracer\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 10.0;\n\tfloat h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<150; i++ )\n    {\n        if( h<0.000001 || t>maxd ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\t\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.002,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n\tfloat h = 1.0;\n    for( int i=0; i<20; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.01, 1.0 );\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.02 + 0.025*float(i*i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return 1.0 - clamp( occ, 0.0, 1.0 );\n}\n\nvec3 lig = normalize(vec3(1.0,0.9,0.7));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n\tvec3 ro = vec3(0.0, 0.25, 2.0 );\n\tvec3 rd = normalize( vec3(p,-1.0) );\n\t\n\tvec3 col = vec3(0.0);\n\n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tfloat sha = calcSoftshadow( pos + nor*0.01, lig, 32.0 );\n\t\tfloat occ = calcOcclusion( pos, nor );\n\t\tcol =  vec3(0.9,0.6,0.3)*clamp( dot( nor, lig ), 0.0, 1.0 ) * sha;\n\t\tcol += vec3(0.5,0.6,0.7)*clamp( nor.y, 0.0, 1.0 )*occ;\n        col += 0.03;\n\t\tcol *= exp( -0.2*t );\n        col *= 1.0 - smoothstep( 5.0, 10.0, t );\n\t}\n\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "XltyWB",
    "date": "1533889056",
    "viewed": 165,
    "name": "Concave polyhedron SDF",
    "description": "Polyhedron, Triangle mesh, SDF ,",
    "likes": 3,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "sdf",
     "triangle",
     "distance",
     "mesh",
     "polyhedron",
     "concave",
     "curv"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "MsSXDV",
       "filepath": "https://soundcloud.com/yennyskev/100-wet",
       "type": "musicstream",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 0
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//based on https://www.shadertoy.com/view/4sXXRN\n\n// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n//-------------------------------------------------------------------------------- \n\n\n//    A little experiment with Concave polyhedron  SDFs.\n\n//    The motivation was to be able to use triangle meshes in CSG ops with other SDFs.\n    \n//    Polyhedron  must be a closed non intersecting mesh. \n\n//    Some artifacs appear at narrow or coplanar faces (fixed) \n\n//    Defined as a collection of triangles, yeah like a stl donit.\n\n//    For each calculationg a pair of unsigned distance and one inside/outside number. \n    \n//    Basically the closest triangle get first shot to call inside/outside.\n   \n//        but there are some edgecases that requires extra bits\n     \n//        some logic v=  abs(v1.x-v.x)<0.001? (v1.y>v.y?v1:v):     v1.x<=v.x?v1:v; \n\n//    Generally sound sdf, some edge leakage and some GLSL issues.  \n     \n//    In demo Polyhedra is differenced by sphere and smooth unioned with \n//    ground plane to showcase full sdf capabilites\n\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n// music credit to https://soundcloud.com/yennyskev/100-wet\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n\n\n\n\n\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;}\nfloat smin( float a, float b, float k )\n{    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);}\n\n \nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nvec2 dTriangle( in vec3 v1, in vec3 v2, in vec3 v3, in vec3 p )\n{\n    vec3 v21 = v2 - v1; vec3 p1 = p - v1;\n    vec3 v32 = v3 - v2; vec3 p2 = p - v2;\n    vec3 v13 = v1 - v3; vec3 p3 = p - v3;\n    vec3 nor = cross( v21, v13 );\n float side=dot(p-v1,nor);\n  float  dist=sqrt( (sign(dot(cross(v21,nor),p1)) + \n                  sign(dot(cross(v32,nor),p2)) + \n                  sign(dot(cross(v13,nor),p3))<2.0) \n                  ?\n                  min( min( \n                  dot2(v21*clamp(dot(v21,p1)/dot2(v21),0.0,1.0)-p1), \n                  dot2(v32*clamp(dot(v32,p2)/dot2(v32),0.0,1.0)-p2) ), \n                  dot2(v13*clamp(dot(v13,p3)/dot2(v13),0.0,1.0)-p3) )\n                  :\n                  dot(nor,p1)*dot(nor,p1)/dot2(nor) );\n    return vec2(dist,side);\n}\n\n \n//=====================================================\nvec2 distlogic(vec2 v,vec2 v1){\nreturn abs(v1.r-v.r)< // if distances are\n             0.00001*  // closer than some fugde factor\n             max(max(v1.r,v.r),1.) // that gets a little larger further out but never below 1\n             ?(v1.g>v.g?v1:v): //select most positive side\n    \t\tv1.r<=v.r?v1:v; // or the common case;\n}\n\nfloat Mypolyhedron(vec3 p )\n{\n    vec2 v=vec2( 99999.,0.) ;\n    \nint numberOfFaces=36;\nvec3[] points = vec3[] (vec3(-1.5,0.75,0.75),vec3(1.5,-0.25,0.75),vec3(1.5,0.75,0.75),vec3(1.5,-0.25,0.75),vec3(-1.5,0.75,0.75),vec3(-1.5,-0.25,0.75),vec3(-1.5,-0.25,-0.25),vec3(1.5,0.75,-0.25),vec3(1.5,-0.25,-0.25),vec3(1.5,0.75,-0.25),vec3(-1.5,-0.25,-0.25),vec3(-1.5,0.75,-0.25),vec3(-1.5,-0.25,-0.25),vec3(1.5,-0.25,0.75),vec3(-1.5,-0.25,0.75),vec3(1.5,-0.25,0.75),vec3(-1.5,-0.25,-0.25),vec3(1.5,-0.25,-0.25),vec3(1.5,-0.25,0.75),vec3(1.5,0.75,-0.25),vec3(1.5,0.75,0.75),vec3(1.5,0.75,-0.25),vec3(1.5,-0.25,0.75),vec3(1.5,-0.25,-0.25),vec3(1.5,0.75,-0.25),vec3(-1.5,0.75,0.75),vec3(1.5,0.75,0.75),vec3(-1.5,0.75,0.75),vec3(1.5,0.75,-0.25),vec3(-1.5,0.75,-0.25),vec3(-1.5,-0.25,-0.25),vec3(-1.5,0.75,0.75),vec3(-1.5,0.75,-0.25),vec3(-1.5,0.75,0.75),vec3(-1.5,-0.25,-0.25),vec3(-1.5,-0.25,0.75),vec3(0.75,-0.75,1.5),vec3(0.75,0.25,-1.5),vec3(0.75,0.25,1.5),vec3(0.75,0.25,-1.5),vec3(0.75,-0.75,1.5),vec3(0.75,-0.75,-1.5),vec3(-0.25,-0.75,-1.5),vec3(-0.25,0.25,1.5),vec3(-0.25,0.25,-1.5),vec3(-0.25,0.25,1.5),vec3(-0.25,-0.75,-1.5),vec3(-0.25,-0.75,1.5),vec3(-0.25,-0.75,-1.5),vec3(0.75,-0.75,1.5),vec3(-0.25,-0.75,1.5),vec3(0.75,-0.75,1.5),vec3(-0.25,-0.75,-1.5),vec3(0.75,-0.75,-1.5),vec3(-0.25,-0.75,-1.5),vec3(0.75,0.25,-1.5),vec3(0.75,-0.75,-1.5),vec3(0.75,0.25,-1.5),vec3(-0.25,-0.75,-1.5),vec3(-0.25,0.25,-1.5),vec3(0.75,0.25,-1.5),vec3(-0.25,0.25,1.5),vec3(0.75,0.25,1.5),vec3(-0.25,0.25,1.5),vec3(0.75,0.25,-1.5),vec3(-0.25,0.25,-1.5),vec3(-0.25,0.25,1.5),vec3(0.75,-0.75,1.5),vec3(0.75,0.25,1.5),vec3(0.75,-0.75,1.5),vec3(-0.25,0.25,1.5),vec3(-0.25,-0.75,1.5),vec3(-0.75,1.5,0.25),vec3(0.25,-1.5,0.25),vec3(0.25,1.5,0.25),vec3(0.25,-1.5,0.25),vec3(-0.75,1.5,0.25),vec3(-0.75,-1.5,0.25),vec3(-0.75,-1.5,-0.75),vec3(0.25,1.5,-0.75),vec3(0.25,-1.5,-0.75),vec3(0.25,1.5,-0.75),vec3(-0.75,-1.5,-0.75),vec3(-0.75,1.5,-0.75),vec3(0.25,-1.5,0.25),vec3(0.25,1.5,-0.75),vec3(0.25,1.5,0.25),vec3(0.25,1.5,-0.75),vec3(0.25,-1.5,0.25),vec3(0.25,-1.5,-0.75),vec3(0.25,1.5,-0.75),vec3(-0.75,1.5,0.25),vec3(0.25,1.5,0.25),vec3(-0.75,1.5,0.25),vec3(0.25,1.5,-0.75),vec3(-0.75,1.5,-0.75),vec3(-0.75,-1.5,-0.75),vec3(-0.75,1.5,0.25),vec3(-0.75,1.5,-0.75),vec3(-0.75,1.5,0.25),vec3(-0.75,-1.5,-0.75),vec3(-0.75,-1.5,0.25),vec3(-0.75,-1.5,-0.75),vec3(0.25,-1.5,0.25),vec3(-0.75,-1.5,0.25),vec3(0.25,-1.5,0.25),vec3(-0.75,-1.5,-0.75),vec3(0.25,-1.5,-0.75) );\nvec3[] faces = vec3[] (vec3(0,1,2),vec3(3,4,5),vec3(6,7,8),vec3(9,10,11),vec3(12,13,14),vec3(15,16,17),vec3(18,19,20),vec3(21,22,23),vec3(24,25,26),vec3(27,28,29),vec3(30,31,32),vec3(33,34,35),vec3(36,37,38),vec3(39,40,41),vec3(42,43,44),vec3(45,46,47),vec3(48,49,50),vec3(51,52,53),vec3(54,55,56),vec3(57,58,59),vec3(60,61,62),vec3(63,64,65),vec3(66,67,68),vec3(69,70,71),vec3(72,73,74),vec3(75,76,77),vec3(78,79,80),vec3(81,82,83),vec3(84,85,86),vec3(87,88,89),vec3(90,91,92),vec3(93,94,95),vec3(96,97,98),vec3(99,100,101),vec3(102,103,104),vec3(105,106,107) );\n  \n    for(int i =0; i<numberOfFaces;i++){\n        \n     vec2 v1 = dTriangle( \n         points[int( faces[i].x)], \n         points[int( faces[i].y)], \n         points[int( faces[i].z)],\n         p);\n         v= distlogic(v,v1);\n    }\n         \n\n      \n    return (v.x*sign(v.y));\n\n}\n\nfloat map( in vec3 p )\n{\nfloat t= iTime*2.5; \np= vec3(p.x*cos(t)-p.z*sin(t ),p.y,p.z*cos(t )+p.x*sin(t )) ;\n    // triangles\t\n\tvec3 p0 = vec3(0,-.8+cos(t+3.)*0.2,0. );\n\tvec3 p1 =  vec3(0,.47+cos(t),-1. );\n\tvec3 p2 =  vec3(1.0,0.3+sin(t/2.),1. );\n\tvec3 p3 =  vec3(-1.0,0.3+sin(t/2.7),1. );\n    vec3 p4 =  mix(vec3(0,0.5,0.5 ),p0,sin(iTime/2.7)*0.99);\nfloat mesh= Mypolyhedron(p);\n    // ground plane here\n\tfloat d2 = p.y + 1.0;\n    // sphere here\n\tvec3 ps = vec3(sin(-iTime),cos(-iTime),sin(2.-iTime)*2. )*0.7;\n    float sphere=sdSphere(p-ps,0.5);  \n\n    \n    return smin( max(-sphere,mesh), d2,0.5+sin(iTime/3.)*0.5 );\t\n}\n\n\n\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n//-------------------------------------------------------------------------------- \n\n\n\n\n// tracer\nfloat intersect( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 10.0;\n\tfloat h = 1.0;\n    float t = 0.0;\n    for( int i=0; i<150; i++ )\n    {\n        if( h<0.000001 || t>maxd ) break;\n\t    h = map( ro+rd*t );\n        t += h;\n    }\n\n    if( t>maxd ) t=-1.0;\n\t\n    return t;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 eps = vec3(0.002,0.0,0.0);\n\n\treturn normalize( vec3(\n           map(pos+eps.xyy) - map(pos-eps.xyy),\n           map(pos+eps.yxy) - map(pos-eps.yxy),\n           map(pos+eps.yyx) - map(pos-eps.yyx) ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n\tfloat h = 1.0;\n    for( int i=0; i<20; i++ )\n    {\n        h = map(ro + rd*t);\n        res = min( res, k*h/t );\n\t\tt += clamp( h, 0.01, 1.0 );\n\t\tif( h<0.0001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.02 + 0.025*float(i*i);\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos );\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return 1.0 - clamp( occ, 0.0, 1.0 );\n}\n\nvec3 lig = normalize(vec3(1.0,0.9,0.7));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n\tvec3 ro = vec3(0.0, 0.25, 2.0 );\n\tvec3 rd = normalize( vec3(p,-1.0) );\n\t\n\tvec3 col = vec3(0.0);\n\n    float t = intersect(ro,rd);\n    if( t>0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\t\tfloat sha = calcSoftshadow( pos + nor*0.01, lig, 32.0 );\n\t\tfloat occ = calcOcclusion( pos, nor );\n\t\tcol =  vec3(0.9,0.6,0.3)*clamp( dot( nor, lig ), 0.0, 1.0 ) * sha;\n\t\tcol += vec3(0.5,0.6,0.7)*clamp( nor.y, 0.0, 1.0 )*occ;\n        col += 0.03;\n\t\tcol *= exp( -0.2*t );\n        col *= 1.0 - smoothstep( 5.0, 10.0, t );\n\t}\n\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}\n\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "llccWS",
    "date": "1533839965",
    "viewed": 154,
    "name": "Concave shape SDF",
    "description": "Concave 2d shape",
    "likes": 4,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "convex"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "MsSSWV",
       "filepath": "https://soundcloud.com/yennyskev/100-wet",
       "type": "musicstream",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 0
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n//-------------------------------------------------------------------------------- \n\n\n//   A little experiment with Concave shape SDFs \n\n//   The motivation was to draw fonts as SDFs, inner loops was a requirement.\n\n//   shape must be closed non intersecting loops \n    \n//   defined as a list of edges vec4(x1,y1,x2,y2)\n\n//    for each calculationg a pair of unsigned distance and one inside/outside number \n    \n//        v=v1.x<=v.x?v1:v;\n    \n//    basically the closest edge segment get first shot to call inside/outside\n   \n//        but there are some edgecases that requires extra bits\n     \n//        some logic v=  abs(v1.x-v.x)<0.001? (v1.y>v.y?v1:v):     v1.x<=v.x?v1:v; \n\n//   Generally sound sdf but some GLSL issue.  \n     \n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n// music credit to https://soundcloud.com/yennyskev/100-wet\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\n\n\nvec2 shapeedge ( vec2 p, vec2 a, vec2 b, float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n     float side = -1.*((p.x-a.x)*(b.y-a.y)-(p.y-a.y)*(b.x-a.x));\n    return vec2(dot2( pa - ba*h ) - r, sign(side)) ;\n}\n\n    // this is the hackish fudge. \n       // Ovelappig condition shold be exactly v1.x==v.x \n       // bu computer says no\n       // \n\nvec2 distlogic(vec2 v,vec2 v1){\nreturn \n    \n \n    \n    abs(v1.r-v.r)< // if distances are\n             0.00001  // closer than some fugde factor\n             *max(max(v1.r,v.r),.1)\n    // that gets a little larger further out but never below 1\n             ? (v1.g<=0. && v.g<=0.)? (v1.g<v.g?v1:v) : (v1.g>v.g?v1:v) :\n    \n            //select most positive side\n    \t\tv1.r<=v.r?v1:v; // or the common case;\n}\n\n//So here´s the problem sdshape passing arrays in GLSL must be of defined length (46)\n\nfloat sdshape(vec2 p,vec4[46] shape){\nfloat t=clamp(sin(iTime*0.5)*6.28+1.56,0.,6.28-1.56) ; \np= vec2(p.x*cos(t)-p.y*sin(t ),p.y*cos(t )+p.x*sin(t )) ;\n     vec2 v=vec2(100000000000000.0,0);\n     vec2 v1; \n     \n     \n     for( int i=0; i<shape.length() ; i++ ) {\n vec2 a = vec2(shape[i].x,shape[i].y)*clamp(sin(iTime)+1.5,-0.4,2.2) ;\n vec2 b = vec2(shape[i].z,shape[i].w)*clamp(sin(iTime)+1.5,-0.4,2.2) ;\n float r =  0.;     \n       v1=  shapeedge(   p,   a,   b,   r );\n   \n         v= distlogic(v,v1);\n     //  v= abs(v1.r-v.r)<(0.00001)*max(max(v1.r,v.r),1.)?( v1.g> 0.?v1:v): v1.r<=v.r?v1:v; \n     //   v= abs(v1.r-v.r)<0.00001?(v1.g<v.g?v:v1): v1.r<=v.r?v1:v;  \n     }\n        \n     return   sqrt(v.x)   *sign(v.y) ;    \n}\n                          \n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n\n\n \n float map(vec2 p){\n             vec4[] shape =vec4[](vec4(0.399, 0.173, 0.269, 0.173), vec4(0.269, 0.173, 0.216, 0.08), vec4(0.216, 0.08, 0.216, 0.124), vec4(0.216, 0.124, 0, 0.249), vec4(0, 0.249, -0.207, 0.129), vec4(-0.207, 0.129, -0.324, 0.129), vec4(-0.324, 0.129, -0.399, 0), vec4(-0.399, 0, -0.324, -0.129), vec4(-0.324, -0.129, -0.208, -0.129), vec4(-0.208, -0.129, 0, -0.249), vec4(0, -0.249, 0.216, -0.124), vec4(0.216, -0.124, 0.216, -0.08), vec4(0.216, -0.08, 0.269, -0.173), vec4(0.269, -0.173, 0.399, -0.173), vec4(0.399, -0.173, 0.249, -0.432), vec4(0.249, -0.432, -0.249, -0.432), vec4(-0.249, -0.432, -0.499, 0), vec4(-0.499, 0, -0.249, 0.432), vec4(-0.249, 0.432, 0.249, 0.432), vec4(0.249, 0.432, 0.399, 0.173), vec4(0.083, -0.262, 0.108, -0.377), vec4(0.108, -0.377, 0.224, -0.389), vec4(0.224, -0.389, 0.272, -0.282), vec4(0.272, -0.282, 0.185, -0.203), vec4(0.185, -0.203, 0.083, -0.262), vec4(-0.224, -0.216, -0.274, -0.303), vec4(-0.274, -0.303, -0.224, -0.389), vec4(-0.224, -0.389, -0.124, -0.389), vec4(-0.124, -0.389, -0.074, -0.303), vec4(-0.074, -0.303, -0.124, -0.216), vec4(-0.124, -0.216, -0.224, -0.216), vec4(-0.224, 0.389, -0.273, 0.318), vec4(-0.273, 0.318, -0.248, 0.235), vec4(-0.248, 0.235, -0.167, 0.203), vec4(-0.167, 0.203, -0.092, 0.246), vec4(-0.092, 0.246, -0.079, 0.332), vec4(-0.079, 0.332, -0.138, 0.396), vec4(-0.138, 0.396, -0.224, 0.389), vec4(0.088, 0.353, 0.078, 0.277), vec4(0.078, 0.277, 0.124, 0.216), vec4(0.124, 0.216, 0.2, 0.206), vec4(0.2, 0.206, 0.261, 0.253), vec4(0.261, 0.253, 0.271, 0.328), vec4(0.271, 0.328, 0.224, 0.389), vec4(0.224, 0.389, 0.149, 0.399), vec4(0.149, 0.399, 0.088, 0.353));\nreturn min(sdshape(p,shape),\n          min( length (p-vec2(1.,0.))-0.2, max(abs(p.x+1.0),abs(p.y))-0.2)\n          );       \n                          }\n                          \n \n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------\n//--------------------------------------------------------------------------------                        \n                          \n                          \nfloat saturate(float x) {\n    return clamp(x, 0.0, 1.0);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord / iResolution.xy) * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\nuv*=3.+sin(iTime+2.)*2.4;\n \n    \n    float d = map (uv);\n        //distanceToBiCapsule(uv, v0, v1, r0, r1);\n    //float d = distance(p, uv);\n    \n    float stripe = smoothstep(0.4, 0.6, abs(fract(d * 10.0) * 2.0 - 1.0));\n    fragColor = vec4((vec3(stripe) * 0.4 + 0.8) * vec3(d * 0.1, 1.0 - d * 0.5, d * 0.2), 1.0);\n    \n    //fragColor.rgb -= smoothstep(0.9, 1.0, min(distance(uv, v0) / r0, distance(uv, v1) / r1)) * 0.25;\n    \n    fragColor.rgb *= mix(0.3, 1.0, smoothstep(0.0, 0.01, d));\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MtcyDn",
    "date": "1532188371",
    "viewed": 113,
    "name": "Cone capsule",
    "description": "three bones of cone capsules special \"synaptic\" blend mode and normaldriven bump texture.\nLooping thou combinations of three blend parameters and two bump noise parameters  (roughness and depth).\nUseful for bone and exoskeleton modelling",
    "likes": 2,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "capsule"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "   \n#ifdef GLSLVIEWER\nuniform vec3 u_eye3d;\nuniform vec3 u_centre3d;\nuniform vec3 u_up3d;\n#endif\n\n\nfloat   arandom (float aseed) {return mod( mod(aseed*43758.5453123, 1.9)+aseed* 78.233 ,1.0);}\n\nfloat value_at (float x,float y,float z) {return arandom(arandom(arandom(x)+y)+z);}\n\n\nfloat noise3d(vec3 p) {\n    \n    // single octave xyz noise\n\t  float  px= floor (p.x); \t   float    py= floor (p.y); \t   float    pz= floor (p.z);\n  \t\tfloat\tlbx= smoothstep(0.0,1.0,p.x-px);\t\n  \t\tfloat  lby= smoothstep(0.0,1.0,p.y-py);\t \n \t\t float  lbz= smoothstep(0.0,1.0,p.z-pz);\n\t  \t  float    p0 = value_at (px,  py,  pz);    float    p1 = value_at (px+1.0,py,  pz);\n      \t  float    p2 = value_at (px+1.0,py+1.0,pz);    float    p3 = value_at (px,  py+1.0,pz);\t\t\n      \t  float    p4 = value_at (px,  py,  pz+1.0);  float      p5 = value_at (px+1.0,py,  pz+1.0);\n      \t  float    p6 = value_at (px+1.0,py+1.0,pz+1.0);  float      p7 = value_at (px,  py+1.0,pz+1.0);   \t     \n          float  p01 =mix(p0,p1,lbx);\t\t\t  float  p32 =mix(p3,p2,lbx);\n    \t  float  \tp45 =mix(p4,p5,lbx);\t\t  float  \tp76 =mix(p7,p6,lbx);\n\t\t  float  \tp0132=mix(p01,p32,lby);\t\t  float  \tp4576=mix(p45,p76,lby);  \t \n    float   c1=mix(p0132,p4576,lbz);\n    return    (c1);}\n\n\nfloat  synmin(float a,float  b,float  r ,float w,float g) {\n    // drop-in function for smin  \n\t \n        float  e =   max(r*0.02,(abs(a-b)/r) );\n        return min (a,b)- max(0.01,(r*e*w*(exp(1.0-(e*g ))))/max(a,b)*0.5)\n \n            ;}\n\nfloat conecapsule2 (vec3 p, vec4 p1 ,vec4 p2  ) {\n// eats vec4 (x,y,z,r) X 2\nvec3 a=mix(p1.xyz,p2.xyz,0.15); // pull back a little from joint\nvec3 b=mix(p1.xyz,p2.xyz,0.9);\nfloat\t\td1=p1.w;\nfloat\t\td2=p2.w*0.9;\nvec3\t\tba = b - a;\nvec3\t\tpa = p - a;\n    float v= dot(pa,ba) / dot(ba,ba);\nfloat\t\th = clamp(  v,   0.0,   1.0);\nfloat\t\t\td=mix(d1,d2,  smoothstep(0.0,1.0,   h));\n     float r= d ;// / 2.0;\n \n            return length (pa - ba*h) - r;\n\n}\n\n float conecapsule (vec3 p, vec4 p1 ,vec4 p2 ,float w, float z) {\n\n    // wrapper of conecapsule to introduce some bump noise\n    \n     vec3 n=normalize(vec3 (\n     conecapsule2(p,p1,p2)-conecapsule2(p+vec3(0.01,0.0,0.0) ,p1,p2),\n       conecapsule2(p,p1,p2)-conecapsule2(p+vec3(0.0,0.01,0.0),p1,p2 ),\n      conecapsule2(p,p1,p2)-conecapsule2(p+vec3(0.0,0.0,0.01),p1,p2 )\n           ));\n \n    \nfloat bumpb=noise3d(n*w+p/(45./w))*z;//mostly normaldriven with a dash of global p\n     \nreturn conecapsule2 (p,p1,p2) +bumpb \n   ; \n}\n \n\nvec4 map(vec4 r0)\n{  vec3 p=r0.xyz ;\n \n \n // make a few points\n vec4 p1= vec4(-0.+(sin(iTime*.5+1.)+1.25)*10.,0.,0.,8.);\n vec4 p2= vec4(45.,0.,0., 7.+(sin(iTime*.7+1.)+1.)*5.);\n vec4 p1b =vec4 ( p1.x, p1.y, p1.z, 5.5+(sin(iTime*.9)+1.1)*5. );\n  vec4 p3= vec4(-10.-(cos(iTime*.5)+1.25)*10.,0.,(sin(iTime*.5))*10., 4.5+(sin(iTime*.9)+1.1)*3.0);\n  vec4 p4= vec4(-40.,-1.+(cos(iTime*.95)+1.25)*10.,-45.+ (sin(iTime*.95)+1.25)*10., 3.1+(sin(iTime*.9)+1.)*3.0);\n// connect point with conecaplsule bones\n float v1= conecapsule(\n               p, \n                p2 , p1,\n             \n                                   \n               (sin(iTime*1.5)+1.5)*3.,(sin(iTime*2.)+1.5)*0.5                   \n                );\n \n float v2= conecapsule(\n               p,                  \n                   p1b,\n                  p3,\n                                   \n               (sin(iTime*1.3)+1.5)*3.,(sin(iTime*2.1)+1.5)*0.5                   \n                );\n  float v2b= conecapsule(\n               p,                  \n                   p1b,\n                  p3,\n                                   \n               3.,2.25                  \n                );\n \n  float v3= conecapsule(\n               p,                  \n                   p3,\n                  p4,\n                                   \n               (sin(iTime*3.1)+1.5)*3.,(sin(iTime*2.4)+1.5)*0.5                   \n                );\n \n \n // synmin union \n //return vec4(  v2b,0.56,0.51,0.52);   //uncomment for single bome demo\n \n return vec4( \n      synmin(v2,  min(v1,v3),(sin(iTime*0.39)+1.1)*8.,(sin(iTime*0.71)+1.4)*8.,(sin(iTime*0.59)+1.4)*2.)\n        ,v1>v2?0.015:0.025, v2<v3?0.015:0.025, 0.013)\n               ;\n\n }\n\n\nconst vec3 bbox_min = vec3(-7.363703305156273,-7.363703305156273,-7.363703305156273);\nconst vec3 bbox_max = vec3(7.363703305156273,7.363703305156273,7.363703305156273);\n// ray marching. ro is ray origin, rd is ray direction (unit vector).\n// result is (t,r,g,b), where\n//  * t is the distance that we marched,\n//  * r,g,b is the colour of the distance field at the point we ended up at.\n//    (-1,-1,-1) means no object was hit.\nvec4 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 300.0;\n   \n    float t = tmin;\n    vec3 c = vec3(-1.0,-1.0,-1.0);\n    for (int i=0; i<200; i++) {\n        float precis = 0.0005*t;\n        vec4 res = map( vec4(ro+rd*t,iTime) );\n        if (res.x < precis) {\n            c = res.yzw;\n            break;\n        }\n        t += res.x;\n        if (t > tmax) break;\n    }\n    return vec4( t, c );\n}\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( vec4(pos + e.xyy,iTime) ).x + \n                      e.yyx*map( vec4(pos + e.yyx,iTime) ).x + \n                      e.yxy*map( vec4(pos + e.yxy,iTime) ).x + \n                      e.xxx*map( vec4(pos + e.xxx,iTime) ).x );\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( vec4(aopos,iTime) ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n// in ro: ray origin\n// in rd: ray direction\n// out: rgb colour\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    //vec3 col = vec3(0.7, 0.9, 1.0) +rd.z*0.8;\n    //vec3 col = vec3(0.8, 0.9, 1.0);\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    vec4 res = castRay(ro,rd);\n    float t = res.x;\n    vec3 c = res.yzw;\n    if( c.x>=0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = mix(c,normalize(c),0.42);\n\n        // lighting        \n        float occ = calcAO( pos, nor );\n        vec3  lig = normalize( ro +vec3(0,10,10) );\n        float amb = clamp( 0.5+0.5*nor.z, 0.0, 1.0 );\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,lig.y,0.0))), 0.0, 1.0 )*clamp( 1.0-pos.z,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.z );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n        \n        vec3 lin = vec3(0.0);\n       lin += 1.30*dif*vec3(1.00,0.80,0.55);\n         lin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n        //lin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n        // lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*bac*vec3(0.35,0.35,0.35)*occ;\n        // lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n        vec3 iqcol = col*lin;\n\n        //col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n        col = mix(col,iqcol, 0.6);\n    }\n\n    return vec3( clamp(col,0.0,1.0) );\n}\n// Create a matrix to transform coordinates to look towards a given point.\n// * `eye` is the position of the camera.\n// * `centre` is the position to look towards.\n// * `up` is the 'up' direction.\nmat3 look_at(vec3 eye, vec3 centre, vec3 up)\n{\n    vec3 ww = normalize(centre - eye);\n    vec3 uu = normalize(cross(ww, up));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n// Generate a ray direction for ray-casting.\n// * `camera` is the camera look-at matrix.\n// * `pos` is the screen position, normally in the range -1..1\n// * `lens` is the lens length of the camera (encodes field-of-view).\n//   0 is very wide, and 2 is a good default.\nvec3 ray_direction(mat3 camera, vec2 pos, float lens)\n{\n    return normalize(camera * vec3(pos, lens));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 origin = (bbox_min + bbox_max) / 2.0 +vec3 (0,0,10);\n    const vec3 radius = (bbox_max - bbox_min) / 2.0;\n    float r = max(radius.x, max(radius.y, radius.z)) / 1.0;\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\n#ifdef GLSLVIEWER\n    vec3 eye = vec3(u_eye3d.x, -u_eye3d.z, u_eye3d.y)*r + origin;\n    vec3 centre = vec3(u_centre3d.x, -u_centre3d.z, u_centre3d.y)*r + origin;\n    vec3 up = vec3(u_up3d.x, -u_up3d.z, u_up3d.y);\n#else\n   \n      vec2 mouse = iMouse.xy / iResolution.xy;\n    vec3 eye = vec3 (cos (4. * mouse.x) * 67., sin (4. * mouse.x) *sin (4. * mouse.y) * 67., -cos (4. * mouse.y) * 67.);\n   // vec3 eye = vec3(sin(iTime/4.)*100., cos(iTime/4.)*90., cos(iTime/4.)*26. +10.);\n    vec3 centre = vec3(0.0, 10.0, 0.0);\n    vec3 up = eye+ vec3(0.0, 0.0, 01.0);\n\t \n#endif\n    mat3 camera = look_at(eye, centre, up);\n    vec3 dir = ray_direction(camera, p, 2.5);\n\n    vec3 col = render( eye, dir );\n    \n    // convert linear RGB to sRGB\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "MltSRf",
    "date": "1480970947",
    "viewed": 274,
    "name": "Flower test",
    "description": "ray marching flower\nRay marcher by Inigo Quilez\nI only made flower function\nadded comments",
    "likes": 20,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "raymarchingflower"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// A list of usefull distance function to simple primitives, and an example on how to \n// do some interesting boolean operations, repetition and displacement.\n//\n// More info here: http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdPlane(vec3 p) {\n\treturn p.y;\n}\n\nfloat sdSphere(vec3 p, float s) {\n\treturn length(p) - s;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r) {\n\treturn (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat udRoundBox(vec3 p, vec3 b, float r) {\n\treturn length(max(abs(p) - b, 0.0)) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n\treturn length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\n \n\nfloat sdCylinder(vec3 p, vec2 h) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - h;\n\treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCone( in vec3 p, in vec3 c) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tfloat d1 = -q.y - c.z;\n\tfloat d2 = max(dot(q, c.xy), q.y);\n\treturn length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat sdConeSection( in vec3 p, in float h, in float r1, in float r2) {\n\tfloat d1 = -p.y - h;\n\tfloat q = p.y - h;\n\tfloat si = 0.5 * (r1 - r2) / h;\n\tfloat d2 = max(sqrt(dot(p.xz, p.xz) * (1.0 - si * si)) + q * si - r2, q);\n\treturn length(max(vec2(d1, d2), 0.0)) + min(max(d1, d2), 0.);\n}\n\nfloat length2(vec2 p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\nfloat length6(vec2 p) {\n\tp = p * p * p;\n\tp = p * p;\n\treturn pow(p.x + p.y, 1.0 / 6.0);\n}\n\nfloat length8(vec2 p) {\n\tp = p * p;\n\tp = p * p;\n\tp = p * p;\n\treturn pow(p.x + p.y, 1.0 / 8.0);\n}\n\nfloat sdTorus82(vec3 p, vec2 t) {\n\tvec2 q = vec2(length2(p.xz) - t.x, p.y);\n\treturn length8(q) - t.y;\n}\n\nfloat sdTorus88(vec3 p, vec2 t) {\n\tvec2 q = vec2(length8(p.xz) - t.x, p.y);\n\treturn length8(q) - t.y;\n}\n\nfloat sdCylinder6(vec3 p, vec2 h) {\n\treturn max(length6(p.xz) - h.x, abs(p.y) - h.y);\n}\n\nfloat flower(vec3 p, float r) {\n\tfloat q = length(p);\n\tp -= vec3(sin(p.x * 15.1), sin(p.y * 25.1), sin(p.z * 15.0)) * 0.01; //some space warping\n\tvec3 n = normalize(p);\n\tq = length(p); // distance before flowerwarp\n\n\tfloat rho = atan(length(vec2(n.x, n.z)), n.y) * 20.0 + q * 15.01; //vertical part of  cartesian to polar with some q warp\n\tfloat theta = atan(n.x, n.z) * 6.0 + p.y * 3.0 + rho * 1.50; //horizontal part plus some warp by z(bend up) and by rho(twist)\n\treturn length(p) - (r + sin(theta) * 0.3 * (1.3 - abs(dot(n, vec3(0, 1, 0)))) //the 1-abs(dot()) is limiting the warp effect at poles\n\t\t+ sin(rho - iTime * 2.0) * 0.3 * (1.3 - abs(dot(n, vec3(0, 1, 0))))); // 1.3-abs(dot()means putting some back in \n}\n\nfloat TTorus(vec3 p, vec2 t) {\n\tvec2 q = vec2(length(p.xz) - t.x, p.y);\n\treturn length(q) - t.y;\n}\n\nfloat ChamferBox(vec3 p, vec3 b, float ch) {\n\tp = max(abs(p) - b, 0.0); // + vec3(ch, ch, ch);\n\tif ((p.x - ch) > (p.y + p.z)) {\n\t\treturn length(p - vec3(ch, 0, 0));\n\t}\n\telse if ((p.y - ch) > (p.x + p.z)) {\n\t\treturn length(p - vec3(0, ch, 0));\n\t}\n\telse if ((p.z - ch) > (p.y + p.x)) {\n\t\treturn length(p - vec3(0, 0, ch));\n\t}\n\telse {\n\t\treturn\n\t\tmax(dot(vec3(0.57735, 0.57735, 0.57735), p) / 0.7967329 - ch * 0.7967329,\n\t\t\tmax(dot(vec3(0.0, 0.707107, 0.707107), p) - ch * 0.7967329,\n\t\t\t\tmax(dot(vec3(0.707107, 0.0, 0.707107), p) - ch * 0.7967329,\n\t\t\t\t\tdot(vec3(0.707107, 0.707107, 0.0), p) - ch * 0.7967329))) + 0.005;\n\t}\n}\n//----------------------------------------------------------------------\n\nfloat opS(float d1, float d2) {\n\treturn max(-d2, d1);\n}\n\nvec2 opU(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nvec3 opRep(vec3 p, vec3 c) {\n\treturn mod(p, c) - 0.5 * c;\n}\n\nvec3 opTwist(vec3 p) {\n\tfloat c = cos(10.0 * p.y + 10.0);\n\tfloat s = sin(10.0 * p.y + 10.0);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn vec3(m * p.xz, p.y);\n}\n\n//----------------------------------------------------------------------\n\nvec2 map( in vec3 pos) {\n\n\treturn vec2(flower(pos, 0.750), 15.1);\n\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd) {\n\tfloat tmin = 1.0;\n\tfloat tmax = 20.0;\n\n\t#if 0\n    {\n        float tp1 = (0.0 - ro.y) / rd.y;\n\tif (tp1 > 0.0) tmax = min(tmax, tp1);\n\tfloat tp2 = (1.6 - ro.y) / rd.y;\n\tif (tp2 > 0.0) {\n\t\tif (ro.y > 1.6) tmin = max(tmin, tp2);\n\t\telse tmax = min(tmax, tp2);\n\t}\n    #\tendif\n\n\tfloat precis = 0.1;\n\tfloat t = tmin;\n\tfloat m = -1.0;\n\tfor (int i = 0; i < 400; i++) {\n\t\tvec2 res = map(ro + rd * t);\n\t\tif (res.x < precis || t > tmax) break;\n\t\tt += res.x * 0.05;\n\t\tm = res.y;\n\t}\n\n\tif (t > tmax) m = -1.0;\n\treturn vec2(t, m);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor (int i = 0; i < 16; i++) {\n\t\tfloat h = map(ro + rd * t).x;\n\t\tres = min(res, 8.0 * h / t);\n\t\tt += clamp(h, 0.02, 0.10);\n\t\tif (h < 0.001 || t > tmax) break;\n\t}\n\treturn clamp(res, 0.0, 1.0);\n\n}\n\nvec3 calcNormal( in vec3 pos) {\n\tvec3 eps = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t\tmap(pos + eps.xyy).x - map(pos - eps.xyy).x,\n\t\tmap(pos + eps.yxy).x - map(pos - eps.yxy).x,\n\t\tmap(pos + eps.yyx).x - map(pos - eps.yyx).x);\n\treturn normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor) {\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor (int i = 0; i < 15; i++) {\n\t\tfloat hr = 0.05 + 0.12 * float(i) / 4.0;\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = map(aopos).x;\n\t\tocc += -(dd - hr) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nvec3 render( in vec3 ro, in vec3 rd) {\n\tvec3 col = vec3(0.7, 0.9, 1.0) + rd.y * 0.8;\n\tvec2 res = castRay(ro, rd);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\tif (m > -0.5) {\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect(rd, nor);\n\n\t\t// material        \n\t\tcol = 0.50 + 0.3 * sin(vec3(2.3 - pos.y / 2.0, 2.15 - pos.y / 4.0, -1.30) * (m - 1.0));\n\n\t\tif (m < 1.5) {\n\n\t\t\tfloat f = mod(floor(5.0 * pos.z) + floor(5.0 * pos.x), 2.0);\n\t\t\tcol = 0.4 + 0.1 * f * vec3(1.0);\n\t\t}\n\n\t\t// lighitng        \n\t\tfloat occ = calcAO(pos, nor);\n\t\tvec3 lig = normalize(vec3(-0.6, 0.7, -0.5));\n\t\tfloat amb = 0.0; // clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n\t\tfloat dif = clamp(dot(nor, lig), 0.0, 1.0);\n\t\tfloat bac = 0.0; // clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\t\tfloat dom = smoothstep(-0.1, 0.1, ref.y);\n\t\tfloat fre = 0.750; //pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = 0.0; //pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n\n\t\t//dif *= softshadow( pos, lig, 0.02, 2.5 );\n\t\t//dom *= softshadow( pos, ref, 0.02, 2.5 );\n\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 1.20 * dif * vec3(1.00, 0.85, 0.55);\n\t\tlin += 1.20 * spe * vec3(1.00, 0.85, 0.55) * dif;\n\t\tlin += 0.20 * amb * vec3(0.50, 0.70, 1.00) * occ;\n\t\tlin += 0.30 * dom * vec3(0.50, 0.70, 1.00) * occ;\n\t\tlin += 0.30 * bac * vec3(0.25, 0.25, 0.25) * occ;\n\t\tlin += 0.40 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\t\tcol = col * lin;\n\n\t\tcol = mix(col, vec3(0.8, 0.9, 1.0), 1.0 - exp(-0.002 * t * t));\n\n\t}\n\n\treturn vec3(clamp(col, 0.0, 1.0));\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * q;\n\tp.x *= iResolution.x / iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy;\n\n\tfloat time = 15.0 + iTime * 3.0;\n\n\t// camera\t\n\tvec3 ro = vec3(0.0, 3.5 * cos(0.1 * -time), 4.0);\n\n\t//vec3( -0.5+3.5*cos(0.1*time + 6.0*mo.x),1.0+3.5*sin(6.0* mo.y), 0.0 + 3.5*sin(0.1*time + 6.0*mo.x)-3.5*cos(  6.0*-mo.y) );\n\tvec3 ta = vec3(-0.1, 0, 0.10);\n\n\t// camera-to-world transformation\n\tmat3 ca = setCamera(ro, ta, 0.0);\n\n\t// ray direction\n\tvec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n\t// render\t\n\tvec3 col = render(ro, rd);\n\n\tcol = pow(col, vec3(0.4545));\n\n\tfragColor = vec4(col, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WlXXWs",
    "date": "0",
    "viewed": 0,
    "name": "Fractal sphere II",
    "description": "fract",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "3d",
     "sdf"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsfGzn",
       "filepath": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg",
       "type": "cubemap",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Hollow sphere\" by TLC123. https://shadertoy.com/view/tllXWX\n// 2019-07-31 09:37:28\n\n// Fork of \"On cube walk animation\" by TLC123. https://shadertoy.com/view/wlXXD2\n// 2019-07-30 16:31:00\n\n// Fork of \"Procedural walk animation\" by TLC123. https://shadertoy.com/view/WlsSWS\n// 2019-07-28 14:16:07\n\n//------------------------------------------------------------------------------\n// ++ Physically-based SDF  https://www.shadertoy.com/view/XlKSDR  romainguy\n//------------------------------------------------------------------------------\n\n\n# define AA 1\n \nstruct matr{\nvec3 rgb;\n  float rough;\n  float metal;\n  vec3 bump;\n};\n\n    /*\nBlue Metal\t0.1, 0.1, 1.0\t1.0\t0.1\nWhite Half- Metal\t0.9, 0.9, 0.9\t0.5\t0.25\nWhite Porcealain\t0.9, 0.9, 0.9\t0.0\t0.15\nBlue Rubber\t0.1, 0.1, 1.0\t0.0\t0.7*/\nmatr[] material=\n    matr[](\n        matr(vec3(0.01,.01,.01)   , .5  ,.01,vec3(.0))\n       ,matr(vec3(.9)         ,1.  ,0.1,vec3(.0))\n       ,matr(vec3(1.000, 0.766, 0.336),1.,.1,vec3(.0))\n       ,matr(vec3(1.0,.01,.10),1.,0.1,vec3(.0))\n    );\n\n \n //------------------------------------------------------------------\n// global form\n//------------------------------------------------------------------\n\n\n\nfloat lpnorm(vec3 p, float s) {\n\treturn pow(\n\t\t(\n\t\t\tpow(abs(p.x), s) +\n\t\t\tpow(abs(p.y), s) +\n\t\t\tpow(abs(p.z), s)),\n\t\t1.0 / s);\n}\n\n\n \n//------------------------------------------------------------------\nvec2 opU(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nvec4 opU(vec4 d1, vec4 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp(.5 + .5*(a-b)/k, 0., 1.);\n\treturn mix(a, b, h) - k*h*(1.-h);\n}\n\n \nvec2 opUsmin(vec2 d1, vec2 d2,float k) {\n    float d=smin(d1.x,d2.x,k);\n\treturn (d1.x < d2.x) ? vec2(d,d1.y) : vec2(d,d2.y);\n}\n\nvec4 opUsmin(vec4 d1, vec4 d2,float k) {\n    float d=smin(d1.x,d2.x,k);\n\treturn (d1.x < d2.x) ? vec4(d,d1.yzw) : vec4(d,d2.yzw);\n}\n \n//------------------------------------------------------------------------------\n// Scene\n//------------------------------------------------------------------------------\nvec3 rotxyz(mat3 m, vec3 p){\n    \nreturn vec3(p.x*m[0]+p.y*m[1]+p.z*m[2]);\n}\n\nvec3 spread31(float i,float seed){\nreturn vec3(sin(i*PI)*cos(seed*97.+i*TAU*7.4214),sin(i*PI),sin(seed*97.+i*TAU*7.4214));\n}\n\nfloat fractalSphere(vec3 pos, float r) {\n\tint subs = 4;\n\tint count = 50;\n\tvec3 c, C, move;\n\tfloat d, R,l;\n\tR = r;\n\tif (sdBB(pos,r) < 0.25) {\n\t\td = sdBB(pos,0.);\n\t\tfor (int i = 0; i < count; i++) {\n\t\t\tr = R;\n\t\t\tC = vec3(0.);\n\t\t\tfor (int j = 0; j < subs; j++) {\n               \n\t\t\t\tr *= .5;\n\t\t\t\tmove = (hash33(C+vec3(i))-0.5)*1.157;\n\t\t\t\tC = C +  (move) * r;\n                   l=sdBB(pos-C,r);\n                if (l > 0.2) break;\n\t\t\t}\n\t\t\td = min(d, sdBB(pos - C, r ) ) ;\n            if (d<0.)break;\n\t\t}\n\t\t d=max(d,sdBB(pos,R) );\n\t} else {\n\t\td = sdBB(pos,r);\n\t}\n\treturn d;\n}\n\n \nvec2 scene( in vec3 pos) {\n\n   float  d=fractalSphere(pos,1.); \n \n vec2 res=    vec2(d,1.)    ;\n    return res;\n}\n//------------------------------------------------------------------------------\n// Materials\n//------------------------------------------------------------------------------\n\nfloat checkersGradBox( in vec2 p) {\n\t// filter kernel\n\tvec2 w = fwidth(p) + 0.001;\n\t// analytical integral (box filter)\n\tvec2 i = 2.0 * (abs(fract((p - 0.5 * w) * 0.5) - 0.5) - abs(fract((p + 0.5 * w) * 0.5) - 0.5)) / w;\n\t// xor pattern\n\treturn 0.5 - 0.5 * i.x * i.y;\n}\n\n\nvec3 normal(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          scene(position + epsilon.xyy).x - scene(position - epsilon.xyy).x,\n          scene(position + epsilon.yxy).x - scene(position - epsilon.yxy).x,\n          scene(position + epsilon.yyx).x - scene(position - epsilon.yyx).x);\n    return normalize(n);\n}\n\nmatr getMaterial(vec3 pos, float m){\n    \n    \n    \nfloat i= float(material.length());       \nint mint=int(round( clamp(m,0.,i)));\n      matr ret;\n            \n     \t\tret = material[mint];\n            ret.bump= normal(pos);\n    \n\t\tif (mint == 1) {\n\t\t\tfloat f = checkersGradBox(1.2 * pos.xz);\n\t\t\tret.rgb = 0.3 + f * material[mint].rgb;\n\t\t}\n if (mint == 3) {\n\t\t\t \n\t\t\tret.rgb =   fbm33(pos*10.);\n\t\t}\n    return ret;\n}\n\n//------------------------------------------------------------------------------\n//https://www.shadertoy.com/view/XlKSDR\n//------------------------------------------------------------------------------\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        float h = scene(origin + direction * t).x;\n        if (h < 0.001) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nvec2 traceRay(in vec3 origin, in vec3 direction) {\n    float material = -1.0;\n\n    float t = 0.02;\n    \n    for (int i = 0; i < 100; i++) {\n        vec2 hit = scene(origin + direction * t);\n        if (hit.x < 0.002 || t > 20.0) break;\n        t += hit.x;\n        material = hit.y;\n    }\n\n    if (t > 15.0) {\n        material = -1.0;\n    }\n\n    return vec2(t, material);\n}\n\n\n\n \n\nfloat calcAO( in vec3 pos, in vec3 nor) {\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor (int i = 0; i < 9; i++) {\n\t\tfloat hr = 0.01 + 0.12 * float(i) / 4.0;\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = scene(aopos).x;\n\t\tocc += -(dd - hr) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp(1.0 - 2.0 * occ, 0.0, 1.0);\n}\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\n\n\n\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / PI;\n}\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n// ACES fitted\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\n\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n//------------------------------------------------------------------------------\n// Rendering\n//------------------------------------------------------------------------------\n\n\nvec3 render(in vec3 origin, in vec3 direction, out float distance) {\n    // Sky gradient\n    //vec3 color = vec3(0.65, 0.85, 1.0) + direction.y * 0.72;\n    vec3 color = texture( iChannel0, direction ).xyz;\n\n    // (distance, material)\n    vec2 hit = traceRay(origin, direction);\n    distance = hit.x;\n    float material = hit.y;\n\n    // We've hit something in the scene\n\n    if (material > 0.0) {\n        vec3 position = origin + distance * direction;\n\n        vec3 v = normalize(-direction);\n        \n      \n     \n        matr M=getMaterial(position,material);\n        vec3 baseColor = M.rgb;\n        float roughness = M.rough;\n        float metallic = M.metal;\n        \n        vec3 n=M.bump;\n        \n         vec3 l = normalize(vec3(0.6, 0.7, -0.7));\n        vec3 h = normalize(v + l);\n        vec3 r = normalize(reflect(direction, n));\n\n        float NoV = abs(dot(n, v)) + 1e-5;\n        float NoL = clamp(dot(n, l),0.,1.);\n        float NoH = clamp(dot(n, h),0.,1.);\n        float LoH = clamp(dot(l, h),0.,1.);\n\n        \n        //float occ =calcAO(position,n);\n        \n        float intensity = 3.0;\n        float indirectIntensity = 0.64 ;\n\n     \n\n        float linearRoughness = roughness * roughness;\n        vec3 diffuseColor = (1.0 - metallic) * baseColor.rgb;\n        vec3 f0 = 0.04 * (1.0 - metallic) + baseColor.rgb * metallic;\n\n        float attenuation = shadow(position, l);\n\n        // specular BRDF\n        float D = D_GGX(linearRoughness, NoH, h);\n        float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n        vec3  F = F_Schlick(f0, LoH);\n        vec3 Fr = (D * V) * F;\n\n        // diffuse BRDF\n        vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n\n        color = Fd + Fr;\n        color *= (intensity * attenuation * NoL) * vec3(0.98, 0.92, 0.89);\n\n        // diffuse indirect\n        vec3 indirectDiffuse = Irradiance_SphericalHarmonics(n) * Fd_Lambert();\n\n        vec2 indirectHit = traceRay(position, r);\n\n        vec3 indirectSpecular =      texture( iChannel0, r.xyz ).xyz + r.y * 0.72;\n        if (indirectHit.y > 0.0) {\n                 vec3 indirectPosition = position + indirectHit.x * r;\n                M=getMaterial(indirectPosition,indirectHit.y );\n                indirectSpecular =M.rgb  ;\n         \n        }\n\n        // indirect contribution\n        vec2 dfg = PrefilteredDFG_Karis(roughness, NoV);\n        vec3 specularColor = f0 * dfg.x + dfg.y;\n        vec3 ibl = diffuseColor * indirectDiffuse + indirectSpecular * specularColor;\n\n        color += ibl * indirectIntensity;\n    }\n\n    return color;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n// Setup\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n \n\n\nvoid setup() {   \n    }\n//------------------------------------------------------------------------------\n// Main and Final \n//------------------------------------------------------------------------------\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tsetup();\n \t vec2 mo = iMouse.xy / iResolution.xy;\n     if(mo.x==mo.y)mo=vec2(0.5);\n    mo *=3.14;\n     mo.y-2.14;\n \tfloat time = .0 + iTime;\n\tvec3 tot = vec3(0.0);\n #\tif AA > 1\n\tfor (int m = 0; m < AA; m++)\n\t\tfor (int n = 0; n < AA; n++) {\n\t\t\t// pixel coordinates\n\t\t\tvec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n\t\t\tvec2 p = (-iResolution.xy + 2.0 * (fragCoord + o)) / iResolution.y;\n # else\n\t\t\t\tvec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n # endif\n\t\t\t// camera\t\n\t\t    vec3 ta =  vec3(0, 0, 0);\n\t\t\t \n            \n              vec3 ro = vec3(0,cos(mo.y ),sin(mo.y ));\n\t\t\t vec4 horz=BuildQuat(vec3(0,1,0), -mo.x*2.+iTime*0.1 );\n             ro = ta+ Rotate(horz,ro)*3.  ;\n             // camera-to-world transformation\n\t\t\tmat3 ca = setCamera(ro, ta, 0.0);\n\t\t\t// ray direction\n\t\t\tvec3 rd = ca * normalize(vec3(p.xy, 2.5));\n\t\t\t// render\n            float distance;\n    vec3 col = render(ro, rd,distance);\n\t\t\t// gamma\n\t\t\tcol = pow(col, vec3(0.4545));\n\t\t\ttot += col;\n # if AA > 1\n\t\t}\n\ttot /= float(AA * AA);\n #\tendif\n\tfragColor = vec4(tot, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// Common megapack\n#define PI  3.14159265\n#define hPI 1.57079632\n#define TAU 6.283185\n\n\n\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n//----------------------------------------------------------------------------------------\n// Quaternios\n//----------------------------------------------------------------------------------------\n vec4 NormQuat(vec4 q)\n{\n    float lenSQ = dot(q, q);\n    float invLenSQ = 1./lenSQ;\n    return q*invLenSQ;\n}\n\nvec4 BuildQuat(vec3 axis, float angle)\n{\n    angle *= 0.5;\n    float s = sin(angle);\n    return NormQuat(vec4(axis*s, cos(angle)));\n}\n\nvec4 MulQuat(vec4 q1, vec4 q2)\n{\n    vec4 res = vec4(0.);\n    res.w   = q1.w*q2.w - dot(q1.xyz, q2.xyz);\n    res.xyz = q1.w*q2.xyz + q2.w*q1.xyz + cross(q1.xyz, q2.xyz);\n    return NormQuat(res);\n}\n\n \n    \nvec3 Rotate(vec4 q, vec3 v)\n{\n    vec3 t = 2.*cross(q.xyz, v);\n    return v + q.w*t + cross(q.xyz, t);\n}\n\n\nfloat fromTo(vec3 p,vec3 q)\n{\nreturn acos(dot(p,q));\n\n}\nvec4 quatLookAt(vec3 forward,vec3 up){\n    forward=normalize(forward);\n    up=normalize(up);\nreturn  (BuildQuat(cross(forward,up),fromTo(forward,up)));\n}\n\n\nvec4 quatInv(in vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\n//https://en.wikipedia.org/wiki/Slerp#Quaternion_Slerp\n\nvec4 slerp(vec4 v0, vec4 v1, float t) {\n    // Only unit quaternions are valid rotations.\n    // Normalize to avoid undefined behavior.\n     NormQuat(v0);\n     NormQuat(v1);\n\n    // Compute the cosine of the angle between the two vectors.\n    float dotp = dot(v0, v1);\n\n    // If the dot product is negative, slerp won't take\n    // the shorter path. Note that v1 and -v1 are equivalent when\n    // the negation is applied to all four components. Fix by \n    // reversing one quaternion.\n    if (dotp < 0.0f) {\n        v1 = -v1;\n        dotp = -dotp;\n    }  \n\n      float DOT_THRESHOLD = 0.9995;\n    if (dotp > DOT_THRESHOLD) {\n        // If the inputs are too close for comfort, linearly interpolate\n        // and normalize the result.\n\n        vec4 result = v0 + t*(v1 - v0);\n        NormQuat(result);\n        return result;\n    }\n\n    // Since dot is in range [0, DOT_THRESHOLD], acos is safe\n    float theta_0 = acos(dotp);        // theta_0 = angle between input vectors\n    float theta = theta_0*t;          // theta = angle between v0 and result\n    float sin_theta = sin(theta);     // compute this value only once\n    float sin_theta_0 = sin(theta_0); // compute this value only once\n\n    float s0 = cos(theta) - dotp * sin_theta / sin_theta_0;  // == sin(theta_0 - theta) / sin(theta_0)\n    float s1 = sin_theta / sin_theta_0;\n\n    return (s0 * v0) + (s1 * v1);\n}\n\n//----------------------------------------------------------------------------------------\n// Hash without Sine  https://www.shadertoy.com/view/4djSRW\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n//----------------------------------------------------------------------------------------\n//// Created by inigo quilez - iq/2014\n//----------------------------------------------------------------------------------------\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat noise13( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( \n        mix(\n                mix( hash13( i + vec3(0.0,0.0,0.0) ), \n                     hash13( i + vec3(1.0,0.0,0.0) ), u.x),\n                mix( hash13( i + vec3(0.0,1.0,0.0) ), \n                     hash13( i + vec3(1.0,1.0,0.0) ), u.x)\n               , u.y),\n              mix(\n                mix( hash13( i + vec3(0.0,0.0,1.0) ), \n                     hash13( i + vec3(1.0,0.0,1.0) ), u.x),\n                mix( hash13( i + vec3(0.0,1.0,1.0) ), \n                     hash13( i + vec3(1.0,1.0,1.0) ), u.x)\n               , u.y)\n        \n         , u.z)\n        ;\n}\n\nvec3 noise33(  vec3 p )\n{\n    p=p+10000.;\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u;\n    u.x = f.x*f.x*(3.0-2.0*f.x);\n    u.y = f.y*f.y*(3.0-2.0*f.y);\n    u.z = f.z*f.z*(3.0-2.0*f.z);\n\n    return mix( \n        mix(\n                mix( hash33( i + vec3(0.0,0.0,0.0) ), \n                     hash33( i + vec3(1.0,0.0,0.0) ), u.x),\n                mix( hash33( i + vec3(0.0,1.0,0.0) ), \n                     hash33( i + vec3(1.0,1.0,0.0) ), u.x)\n               , u.y),\n              mix(\n                mix( hash33( i + vec3(0.0,0.0,1.0) ), \n                     hash33( i + vec3(1.0,0.0,1.0) ), u.x),\n                mix( hash33( i + vec3(0.0,1.0,1.0) ), \n                     hash33( i + vec3(1.0,1.0,1.0) ), u.x)\n               , u.y)\n        \n         , u.z)\n        ;\n}\n\nfloat fbm( vec2 p )\n{\n      mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nvec3 fbm33( vec3 p )\n{\n   \n     mat3 m = mat3(vec3(0.80,  0.60, -0.6).xyz,\n                    vec3(0.80,  0.60, -0.6).yzx,\n                    vec3(0.80,  0.60, -0.6).zxy);\n    vec3 f = vec3(0.0);\n    f += 0.5000*noise33( p ); p = m*p*2.02;\n    f += 0.2500*noise33( p ); p = m*p*2.03;\n    f += 0.1250*noise33( p ); p = m*p*2.01;\n    f += 0.0625*noise33( p );\n    return f/0.9375;\n}\n\nfloat fbm13( vec3 p )\n{\n         float m =1.;\n\n\n    float f =  (0.0);\n    f += 0.5000*noise13( p ); p = m*p*2.02;\n    f += 0.2500*noise13( p ); p = m*p*2.03;\n    f += 0.1250*noise13( p ); p = m*p*2.01;\n    f += 0.0625*noise13( p );\n    return f/0.9375;\n}\n\nvec2 fbm2( in vec2 p )\n{\n    return vec2( fbm(p.xy), fbm(p.yx) );\n}\n\n\n\n//----------------------------------------------------------------------------------------\n//http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n//----------------------------------------------------------------------------------------\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat dot2(vec2 a ) { return dot(a,a); }\n\n \nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\n \nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n \nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n \n \nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\n \nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n \nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n \nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\n \nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n \nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\n \nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n \nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n \nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\n \nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 6.283185/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon,\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n \nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n \nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c = sin/cos of the aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\n \nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n \nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p;\n    p = vec2((p.y>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\n \nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\n\n \nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return sign(k)*length(max(w,0.0)) + r;\n}\n\n \n \n \nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n \nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n        vec2 qos = d + (c + b*t)*t;\n        res = dot(qos,qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n        vec2 qos = d + (c + b*t.x)*t.x;\n        res = dot(qos,qos);\n        qos = d + (c + b*t.y)*t.y;\n        res = min(res,dot(qos,qos));\n        qos = d + (c + b*t.z)*t.z;\n        res = min(res,dot(qos,qos));\n    }\n    return sqrt( res );\n}\n\n \nfloat sdRoundedShape( float d, in float r )\n{\n  return d - r;\n}\n \nfloat sdAnnularShape( float d, in float r )\n{\n  return abs(d) - r;\n}\n\n \n//----------------------------------------------------------------------------------------\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//----------------------------------------------------------------------------------------\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n \nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdBB( vec3 p, float b )\n{\n  vec3 d = abs(p) - vec3(b);\n  return length(max(d,0.0))\n        + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n \nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n \nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n \nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n \nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n \nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n \nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n \nfloat sdPlane( vec3 p  )\n{\n  // n must be normalized\n  return p.y;\n}\n \nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n \nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n \nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n \nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\n \nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n \nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n \nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n \nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n \nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n \nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n \nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n \n \n\n \nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n \n float udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n \nvec3 opElongate(  in vec3 p, in vec3 h )\n{\n    vec3 q = p - clamp( p, -h, h );\n    return   q ;\n}\n\n \n \n\n \n \n\n \nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n \n \n \nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\n \n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n \n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2016-01-10\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n//\n//\n//\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n//\n////////////////////////////////////////////////////////////////\n//\n// How to use this:\n//\n// 1. Build some system to #include glsl files in each other.\n//   Include this one at the very start. Or just paste everywhere.\n// 2. Build a sphere tracer. See those papers:\n//   * \"Sphere Tracing\" http://graphics.cs.illinois.edu/sites/default/files/zeno.pdf\n//   * \"Enhanced Sphere Tracing\" http://lgdv.cs.fau.de/get/2234\n//   The Raymnarching Toolbox Thread on pouet can be helpful as well\n//   http://www.pouet.net/topic.php?which=7931&page=1\n//   and contains links to many more resources.\n// 3. Use the tools in this library to build your distance bound f().\n// 4. ???\n// 5. Win a compo.\n// \n// (6. Buy us a beer or a good vodka or something, if you like.)\n//\n////////////////////////////////////////////////////////////////\n//\n// Table of Contents:\n//\n// * Helper functions and macros\n// * Collection of some primitive objects\n// * Domain Manipulation operators\n// * Object combination operators\n//\n////////////////////////////////////////////////////////////////\n//\n// Why use this?\n//\n// The point of this lib is that everything is structured according\n// to patterns that we ended up using when building geometry.\n// It makes it more easy to write code that is reusable and that somebody\n// else can actually understand. Especially code on Shadertoy (which seems\n// to be what everybody else is looking at for \"inspiration\") tends to be\n// really ugly. So we were forced to do something about the situation and\n// release this lib ;)\n//\n// Everything in here can probably be done in some better way.\n// Please experiment. We'd love some feedback, especially if you\n// use it in a scene production.\n//\n// The main patterns for building geometry this way are:\n// * Stay Lipschitz continuous. That means: don't have any distance\n//   gradient larger than 1. Try to be as close to 1 as possible -\n//   Distances are euclidean distances, don't fudge around.\n//   Underestimating distances will happen. That's why calling\n//   it a \"distance bound\" is more correct. Don't ever multiply\n//   distances by some value to \"fix\" a Lipschitz continuity\n//   violation. The invariant is: each fSomething() function returns\n//   a correct distance bound.\n// * Use very few primitives and combine them as building blocks\n//   using combine opertors that preserve the invariant.\n// * Multiply objects by repeating the domain (space).\n//   If you are using a loop inside your distance function, you are\n//   probably doing it wrong (or you are building boring fractals).\n// * At right-angle intersections between objects, build a new local\n//   coordinate system from the two distances to combine them in\n//   interesting ways.\n// * As usual, there are always times when it is best to not follow\n//   specific patterns.\n//\n////////////////////////////////////////////////////////////////\n//\n// FAQ\n//\n// Q: Why is there no sphere tracing code in this lib?\n// A: Because our system is way too complex and always changing.\n//    This is the constant part. Also we'd like everyone to\n//    explore for themselves.\n//\n// Q: This does not work when I paste it into Shadertoy!!!!\n// A: Yes. It is GLSL, not GLSL ES. We like real OpenGL\n//    because it has way more features and is more likely\n//    to work compared to browser-based WebGL. We recommend\n//    you consider using OpenGL for your productions. Most\n//    of this can be ported easily though.\n//\n// Q: How do I material?\n// A: We recommend something like this:\n//    Write a material ID, the distance and the local coordinate\n//    p into some global variables whenever an object's distance is\n//    smaller than the stored distance. Then, at the end, evaluate\n//    the material to get color, roughness, etc., and do the shading.\n//\n// Q: I found an error. Or I made some function that would fit in\n//    in this lib. Or I have some suggestion.\n// A: Awesome! Drop us a mail at spheretracing@mercury.sexy.\n//\n// Q: Why is this not on github?\n// A: Because we were too lazy. If we get bugged about it enough,\n//    we'll do it.\n//\n// Q: Your license sucks for me.\n// A: Oh. What should we change it to?\n//\n// Q: I have trouble understanding what is going on with my distances.\n// A: Some visualization of the distance field helps. Try drawing a\n//    plane that you can sweep through your scene with some color\n//    representation of the distance field at each point and/or iso\n//    lines at regular intervals. Visualizing the length of the\n//    gradient (or better: how much it deviates from being equal to 1)\n//    is immensely helpful for understanding which parts of the\n//    distance field are broken.\n//\n////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0, 1)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\nfloat square (float x) {\n\treturn x*x;\n}\n\nvec2 square (vec2 x) {\n\treturn x*x;\n}\n\nvec3 square (vec3 x) {\n\treturn x*x;\n}\n\nfloat lengthSqr(vec3 x) {\n\treturn dot(x, x);\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that is a distance function is called fSomething.\n// The first argument is always a point in 2 or 3-space called <p>.\n// Unless otherwise noted, (if the object has an intrinsic \"up\"\n// side or direction) the y axis is \"up\" and the object is\n// centered at the origin.\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n\treturn vmax(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n\n// Endless \"corner\"\nfloat fCorner (vec2 p) {\n\treturn length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\n \n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = clamp(dot(p - a, ab) / dot(ab, ab),0.,1.);\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// A circle line. Can also be used to make a torus by subtracting the smaller radius of the torus.\nfloat fCircle(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn length(vec2(p.y, l));\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n\t//this is mathematically equivalent to this line, but less efficient:\n\t//return max(q.y - h.y, max(dot(vec2(cos(PI/3), sin(PI/3)), q.zx), q.z) - h.x);\n}\n\n// Hexagonal prism, incircle variant\nfloat fHexagonIncircle(vec3 p, vec2 h) {\n\treturn fHexagonCircumcircle(p, vec2(h.x*sqrt(3.)*0.5, h.y));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n \n\n\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that modifies the domain is named pSomething.\n//\n// Many operate only on a subset of the three dimensions. For those,\n// you must choose the dimensions that you want manipulated\n// by supplying e.g. <p.x> or <p.zx>\n//\n// <inout p> is always the first argument and modified in place.\n//\n// Many of the operators partition space into cells. An identifier\n// or cell index is returned, if possible. This return value is\n// intended to be optionally used e.g. as a random seed to change\n// parameters of the distance functions inside the cells.\n//\n// Unless stated otherwise, for cell index 0, <p> is unchanged and cells\n// are centered on the origin so objects don't have to be moved to fit.\n//\n//\n////////////////////////////////////////////////////////////////\n\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Same, but mirror every second cell so they match at the boundaries\nfloat pModMirror1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0)*2. - 1.;\n\treturn c;\n}\n\n// Repeat the domain only in positive direction. Everything in the negative half-space is unchanged.\nfloat pModSingle1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tif (p >= 0.)\n\t\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2))*2. - vec2(1.);\n\treturn c;\n}\n\n// Same, but mirror every second cell at the diagonal as well\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\tp *= mod(c,vec2(2))*2. - vec2(1);\n\tp -= size/2.;\n\tif (p.x > p.y) p.xy = p.yx;\n\treturn floor(c/2.);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sgn(t);\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// We usually need the following boolean operators to combine two objects:\n// Union: OR(a,b)\n// Intersection: AND(a,b)\n// Difference: AND(a,!b)\n// (a and b being the distances to the objects).\n//\n// The trivial implementations are min(a,b) for union, max(a,b) for intersection\n// and max(a,-b) for difference. To combine objects in more interesting ways to\n// produce rounded edges, chamfers, stairs, etc. instead of plain sharp edges we\n// can use combination operators. It is common to use some kind of \"smooth minimum\"\n// instead of min(), but we don't like that because it does not preserve Lipschitz\n// continuity in many cases.\n//\n// Naming convention: since they return a distance, they are called fOpSomething.\n// The different flavours usually implement all the boolean operators above\n// and are called fOpUnionRound, fOpIntersectionRound, etc.\n//\n// The basic idea: Assume the object surfaces intersect at a right angle. The two\n// distances <a> and <b> constitute a new local two-dimensional coordinate system\n// with the actual intersection as the origin. In this coordinate system, we can\n// evaluate any 2D distance function we want in order to shape the edge.\n//\n// The operators below are just those that we found useful or interesting and should\n// be seen as examples. There are infinitely more possible operators.\n//\n// They are designed to actually produce correct distances or distance bounds, unlike\n// popular \"smooth minimum\" operators, on the condition that the gradients of the two\n// SDFs are at right angles. When they are off by more than 30 degrees or so, the\n// Lipschitz condition will no longer hold (i.e. you might get artifacts). The worst\n// case is parallel surfaces that are close to each other.\n//\n// Most have a float argument <r> to specify the radius of the feature they represent.\n// This should be much smaller than the object size.\n//\n// Some of them have checks like \"if ((-a < r) && (-b < r))\" that restrict\n// their influence (and computation cost) to a certain area. You might\n// want to lift that restriction or enforce it. We have left it as comments\n// in some cases.\n//\n// usage example:\n//\n// float fTwoBoxes(vec3 p) {\n//   float box0 = fBox(p, vec3(1));\n//   float box1 = fBox(p-vec3(1), vec3(1));\n//   return fOpUnionChamfer(box0, box1, 0.2);\n// }\n//\n////////////////////////////////////////////////////////////////\n\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n\treturn max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n\treturn fOpIntersectionChamfer(a, -b, r);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n\ta = -a;\n\tfloat m = min(a, b);\n\t//avoid the expensive computation where not needed (produces discontinuity though)\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/n/2.0;\n\t\tcolumnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\n\t\tpR45(p);\n\t\tp.y += columnradius;\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += -columnradius*sqrt(2.)/2.;\n\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\tpMod1(p.y,columnradius*2.);\n\n\t\tfloat result = -length(p) + columnradius;\n\t\tresult = max(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn -min(result, b);\n\t} else {\n\t\treturn -m;\n\t}\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n\treturn fOpDifferenceColumns(a,-b,r, n);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\n\n// Similar to fOpUnionRound, but more lipschitz-y at acute angles\n// (and less so at 90 degrees). Useful when fudging around too much\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\n\n// produces a cylindical pipe that runs along the intersection.\n// No objects remain, only the pipe. This is not a boolean operator.\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\n// first object gets a v-shaped engraving where it intersect the second\nfloat fOpEngrave(float a, float b, float r) {\n\treturn max(a, (a + r - abs(b))*sqrt(0.5));\n}\n\n// first object gets a capenter-style groove cut out\nfloat fOpGroove(float a, float b, float ra, float rb) {\n\treturn max(a, min(a + ra, rb - abs(b)));\n}\n\n// first object gets a capenter-style tongue attached\nfloat fOpTongue(float a, float b, float ra, float rb) {\n\treturn min(a, max(a - ra, abs(b) - rb));\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tlsXWS",
    "date": "0",
    "viewed": 0,
    "name": "FuncLab",
    "description": "collection of some mapping functions ",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "mappingfunctions"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "\n     float amp(float fx,float f0,float f1)\n    {     return (fx-f0)/(f1-f0);}   \n \n\nfloat bounce(float v) { return 0.5-abs( -v+0.5) ;          }\nfloat reflectf(v) return 0.5-abs( v-0.5) ;\nfloat reflectl(v) return 0.5+abs( v-0.5) ;\n\nfloat lerp(start, end, bias)  return  (end * bias + start * (1 - bias));\nfloat step(v,bias,start=0, end=1) return  v>=bias?end:start;\n\nfloat comp(i,c=0.5,s=0.75) return i<c? ramp(i,0,c,0,s) :ramp(i,c,1,s,1) ;\n\nfloat expand(i,c1,c2,s) return i<c? ramp(i,0,c,0,s) :ramp(i,c,1,s,1) ;\n\nfloat mstep(v,steps=3)  return  (floor(v*steps)/steps );\nfloat mods(v,steps=3)  return  ( (v*steps)%1);\nfloat arcs1(v,steps=3)  return arc1(mods(v,steps),1)/steps+mstep(v,steps);\nfloat arcs2(v,steps=3)  return  arc2(mods(v,steps),1)/steps+mstep(v,steps);\nfloat arc1 (x,n=0)  return let(a= n>0? arc1(x,(n-1)):x) clamp(sqrt(1-(1-a)*(1-a)));\nfloat arc2 (x,n=0)  return let(a= n>0? arc2(x,(n-1)):x) clamp( 1-sqrt(1-(a)*(a)));\n\n \n\nfloat ramp(v,bi1=1/3,bi2=2/3,start=1/3, end=2/3)  return  \nlet(b1=min(bi1,bi2),b2=max(bi1,bi2))\nv<=b1?start:v<=b2?lerp(start,end,(v-b1)/(b2-b1))    :end;\nfloat bez2(t, v) return  (len(v) > 2) ? bez2(t, [\n  for (i = [0: len(v) - 2]) lerp(v[i] , v[i + 1] , t)\n]): lerp(v[0] , v[1] ,t);\n\nfloat stepramp(v,bi1=1/5,bi2=4/5,start=1/4, end=3/4)  return  \nlet(b1=min(bi1,bi2),b2=max(bi1,bi2))\nv<=b1?ramp(v,0,b1,0,start):v<=b2?lerp(start,end,(v-b1)/(b2-b1))    :ramp(v,b2,1,end,1);\nfloat minmax(i,v1,v2,bias=0.5) return  i>=bias?max(v1,v2):min(v1,v2);\n \n\n\nfloat maskmix(v1,v2,c )  return  lerp(v1,v2,c);\n\n\nfloat mix(start, end, bias)  return  (end * bias + start * (1 - bias));\n \n\nfloat smooth (a)  return let (b = clamp(a))(b * b * (3 - 2 * b));\nfloat smooths(v,steps)  return smooth( smooth(mods(v,steps) ))/steps+mstep(v,steps);\n\nfloat sinw(i) return gauss(i)-sin(i*360)/2;\nfloat isinw(i) return sin(i*360)/2+smooth(i);\n\nfloat cosw(i) return cos(i*360)/2 -0.5+i;\nfloat icosw(i) return -cos(i*360)/2+0.5+i;\n\nfloat clamp(a, b = 0, c = 1)  return  min(max(a, b), c);\n\nfloat gauss(x)  return      x + (x - smooth(x));\nfloat bisignmap(i) return (i+1)/2;\nfloat infmap(i) return max(0,1-(1/(abs(i)+1)))*sign(i);\n\nfloat  map(  value,istart=-1, istop=1, ostart=0, ostop=1)  return \nostart + (ostop - ostart) * ((value - istart) / (istop - istart));\n;\n    \n    \n  void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n      \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tllXWX",
    "date": "0",
    "viewed": 0,
    "name": "Hollow sphere",
    "description": "holwa",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "3d",
     "sdf"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsfGzn",
       "filepath": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg",
       "type": "cubemap",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"On cube walk animation\" by TLC123. https://shadertoy.com/view/wlXXD2\n// 2019-07-30 16:31:00\n\n// Fork of \"Procedural walk animation\" by TLC123. https://shadertoy.com/view/WlsSWS\n// 2019-07-28 14:16:07\n\n//------------------------------------------------------------------------------\n// ++ Physically-based SDF  https://www.shadertoy.com/view/XlKSDR  romainguy\n//------------------------------------------------------------------------------\n\n\n#define AA 2\n\n\n#define uWavyness 0.2\n#define uScale vec2(1.0, 1.0)\n#define uOffset vec2(0.0, 0.0)\n#define uLayers 6\n#define uBaseFrequency vec2(0.5, 0.5)\n#define uFrequencyStep vec2(0.25, 0.25)\n\n//------------------------------------------------------------------------------\n//https://www.shadertoy.com/view/4syXRD  Fuzzy scratches  Created by Daedelus\n//------------------------------------------------------------------------------\n\nfloat scratch(vec2 uv, vec2 seed)\n{\n    seed.x = floor(sin(seed.x * 51024.0) * 3104.0);\n    seed.y = floor(sin(seed.y * 1324.0) * 554.0);\n \n    uv = uv * 2.0 - 1.0;\n    pR(uv, seed.x + seed.y);\n    uv += sin(seed.x - seed.y);\n    uv = clamp(uv * 0.5 + 0.5, 0.0, 1.0);\n    \n    float s1 = sin(seed.x + uv.y * 3.1415) * uWavyness;\n    float s2 = sin(seed.y + uv.y * 3.1415) * uWavyness;\n    \n    float x = sign(0.01 - abs(uv.x - 0.5 + s2 + s1));\n    return clamp(((1.0 - pow(uv.y, 2.0)) * uv.y) * 2.5 * x, 0.0, 1.0);\n}\n\nfloat layer(vec2 uv, vec2 frequency, vec2 offset, float angle)\n{\n    pR(uv, angle);\n    uv = uv * frequency + offset;\n    return scratch(fract(uv), floor(uv));\n}\n\nfloat scratches(vec2 uv)\n{\n    uv *= uScale;\n    uv += uOffset;\n    vec2 frequency = uBaseFrequency;\n    float scratches = 0.0;\n    for(int i = 0; i < uLayers; ++i)\n    {\n        float fi = float(i);\n    \tscratches += layer(uv, frequency, vec2(fi, fi), fi * 3145.0);\n        frequency += uFrequencyStep;\n    }\n    return scratches;\n}\n\n\n\n\n\n\n \nstruct matr{\nvec3 rgb;\n  float rough;\n  float metal;\n  vec3 bump;\n};\n\n    /*\nBlue Metal\t0.1, 0.1, 1.0\t1.0\t0.1\nWhite Half- Metal\t0.9, 0.9, 0.9\t0.5\t0.25\nWhite Porcealain\t0.9, 0.9, 0.9\t0.0\t0.15\nBlue Rubber\t0.1, 0.1, 1.0\t0.0\t0.7*/\nmatr[] material=\n    matr[](\n        matr(vec3(0.01,.01,.01)   , .5  ,.01,vec3(.0))\n       ,matr(vec3(.9)         ,1.  ,0.1,vec3(.0))\n       ,matr(vec3(1.000, 0.766, 0.336),1.,.1,vec3(.0))\n       ,matr(vec3(1.0,.01,.10),1.,0.1,vec3(.0))\n    );\n\n \n //------------------------------------------------------------------\n// global form\n//------------------------------------------------------------------\n\n\n\nfloat lpnorm(vec3 p, float s) {\n\treturn pow(\n\t\t(\n\t\t\tpow(abs(p.x), s) +\n\t\t\tpow(abs(p.y), s) +\n\t\t\tpow(abs(p.z), s)),\n\t\t1.0 / s);\n}\n\n\n \n//------------------------------------------------------------------\nvec2 opU(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp(.5 + .5*(a-b)/k, 0., 1.);\n\treturn mix(a, b, h) - k*h*(1.-h);\n}\n\n \nvec2 opUsmin(vec2 d1, vec2 d2,float k) {\n    float d=smin(d1.x,d2.x,k);\n\treturn (d1.x < d2.x) ? vec2(d,d1.y) : vec2(d,d2.y);\n}\nfloat band13 (vec3 p){\n    \nreturn \n    scratches( p.xy  )*1.2*abs(dot(p,vec3(0,0,1))) \n    +scratches( p.xz )*1.2*abs(dot(p,vec3(0,1,0))) \n    +scratches( p.yz  )*1.2*abs(dot(p,vec3(1,0,0))) \n    ;\n}\n\nfloat sdHollowSphere(vec3 p ,float r){\n     vec3 exactp=(normalize(p)* r );\n\tfloat d=abs(sdSphere(p,r))-0.015;\n\tif (d<0.02 && \n         \t(band13( p*7. )  <.5\n             //||  displ>0.55\n            )\n       )d=1000.;    \n   \n //d=min(d,sdSphere(p,r-1.));\n\n    \nreturn d ;    \n\n}\n//------------------------------------------------------------------------------\n// Scene\n//------------------------------------------------------------------------------\nvec3 rotxyz(mat3 m, vec3 p){\n    \nreturn vec3(p.x*m[0]+p.y*m[1]+p.z*m[2]);\n}\n\n \nvec2 scene( in vec3 pos) {\n  \n vec2 res;\n    res=\tvec2(sdHollowSphere(pos ,1.2),1.);\n     \n   //res=opU (res, \t\t\tvec2(sdHollowSphere(pos ,1.1),2.)    );\n //res=opUsmin(res,     vec2(sdHollowSphere(pos ,1.1),0.)    ,0.1);\n res=opU (res,     vec2(sdSphere(pos,1.2),1.)    );\n    return res;\n}\n//------------------------------------------------------------------------------\n// Materials\n//------------------------------------------------------------------------------\n\nfloat checkersGradBox( in vec2 p) {\n\t// filter kernel\n\tvec2 w = fwidth(p) + 0.001;\n\t// analytical integral (box filter)\n\tvec2 i = 2.0 * (abs(fract((p - 0.5 * w) * 0.5) - 0.5) - abs(fract((p + 0.5 * w) * 0.5) - 0.5)) / w;\n\t// xor pattern\n\treturn 0.5 - 0.5 * i.x * i.y;\n}\n\n\nvec3 normal(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          scene(position + epsilon.xyy).x - scene(position - epsilon.xyy).x,\n          scene(position + epsilon.yxy).x - scene(position - epsilon.yxy).x,\n          scene(position + epsilon.yyx).x - scene(position - epsilon.yyx).x);\n    return normalize(n);\n}\n\nmatr getMaterial(vec3 pos, float m){\n    \n    \n    \nfloat i= float(material.length());       \nint mint=int(round( clamp(m,0.,i)));\n      matr ret;\n            \n     \t\tret = material[mint];\n            ret.bump= normal(pos);\n    \n\t\tif (mint == 1) {\n\t\t\tfloat f = checkersGradBox(1.2 * pos.xz);\n\t\t\tret.rgb = 0.3 + f * material[mint].rgb;\n\t\t}\n if (mint == 3) {\n\t\t\t \n\t\t\tret.rgb =   fbm33(pos*10.);\n\t\t}\n    return ret;\n}\n\n//------------------------------------------------------------------------------\n//https://www.shadertoy.com/view/XlKSDR\n//------------------------------------------------------------------------------\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        float h = scene(origin + direction * t).x;\n        if (h < 0.001) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nvec2 traceRay(in vec3 origin, in vec3 direction) {\n    float material = -1.0;\n\n    float t = 0.02;\n    \n    for (int i = 0; i < 100; i++) {\n        vec2 hit = scene(origin + direction * t);\n        if (hit.x < 0.002 || t > 20.0) break;\n        t += hit.x;\n        material = hit.y;\n    }\n\n    if (t > 15.0) {\n        material = -1.0;\n    }\n\n    return vec2(t, material);\n}\n\n\n\n \n\nfloat calcAO( in vec3 pos, in vec3 nor) {\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor (int i = 0; i < 9; i++) {\n\t\tfloat hr = 0.01 + 0.12 * float(i) / 4.0;\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = scene(aopos).x;\n\t\tocc += -(dd - hr) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp(1.0 - 2.0 * occ, 0.0, 1.0);\n}\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\n\n\n\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / PI;\n}\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n// ACES fitted\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\n\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n//------------------------------------------------------------------------------\n// Rendering\n//------------------------------------------------------------------------------\n\n\nvec3 render(in vec3 origin, in vec3 direction, out float distance) {\n    // Sky gradient\n    //vec3 color = vec3(0.65, 0.85, 1.0) + direction.y * 0.72;\n    vec3 color = texture( iChannel0, direction ).xyz;\n\n    // (distance, material)\n    vec2 hit = traceRay(origin, direction);\n    distance = hit.x;\n    float material = hit.y;\n\n    // We've hit something in the scene\n\n    if (material > 0.0) {\n        vec3 position = origin + distance * direction;\n\n        vec3 v = normalize(-direction);\n        \n      \n     \n        matr M=getMaterial(position,material);\n        vec3 baseColor = M.rgb;\n        float roughness = M.rough;\n        float metallic = M.metal;\n        \n        vec3 n=M.bump;\n        \n         vec3 l = normalize(vec3(0.6, 0.7, -0.7));\n        vec3 h = normalize(v + l);\n        vec3 r = normalize(reflect(direction, n));\n\n        float NoV = abs(dot(n, v)) + 1e-5;\n        float NoL = clamp(dot(n, l),0.,1.);\n        float NoH = clamp(dot(n, h),0.,1.);\n        float LoH = clamp(dot(l, h),0.,1.);\n\n        \n        //float occ =calcAO(position,n);\n        \n        float intensity = 3.0;\n        float indirectIntensity = 0.64 ;\n\n     \n\n        float linearRoughness = roughness * roughness;\n        vec3 diffuseColor = (1.0 - metallic) * baseColor.rgb;\n        vec3 f0 = 0.04 * (1.0 - metallic) + baseColor.rgb * metallic;\n\n        float attenuation = shadow(position, l);\n\n        // specular BRDF\n        float D = D_GGX(linearRoughness, NoH, h);\n        float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n        vec3  F = F_Schlick(f0, LoH);\n        vec3 Fr = (D * V) * F;\n\n        // diffuse BRDF\n        vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n\n        color = Fd + Fr;\n        color *= (intensity * attenuation * NoL) * vec3(0.98, 0.92, 0.89);\n\n        // diffuse indirect\n        vec3 indirectDiffuse = Irradiance_SphericalHarmonics(n) * Fd_Lambert();\n\n        vec2 indirectHit = traceRay(position, r);\n\n        vec3 indirectSpecular =      texture( iChannel0, r.xyz ).xyz + r.y * 0.72;\n        if (indirectHit.y > 0.0) {\n                 vec3 indirectPosition = position + indirectHit.x * r;\n                M=getMaterial(indirectPosition,indirectHit.y );\n                indirectSpecular =M.rgb  ;\n         \n        }\n\n        // indirect contribution\n        vec2 dfg = PrefilteredDFG_Karis(roughness, NoV);\n        vec3 specularColor = f0 * dfg.x + dfg.y;\n        vec3 ibl = diffuseColor * indirectDiffuse + indirectSpecular * specularColor;\n\n        color += ibl * indirectIntensity;\n    }\n\n    return color;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n// Setup\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n \n\n\nvoid setup() {   \n    }\n//------------------------------------------------------------------------------\n// Main and Final \n//------------------------------------------------------------------------------\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tsetup();\n \t vec2 mo = iMouse.xy / iResolution.xy;\n     if(mo.x==mo.y)mo=vec2(0.5);\n    mo *=3.14;\n     mo.y-2.14;\n \tfloat time = .0 + iTime;\n\tvec3 tot = vec3(0.0);\n #\tif AA > 1\n\tfor (int m = 0; m < AA; m++)\n\t\tfor (int n = 0; n < AA; n++) {\n\t\t\t// pixel coordinates\n\t\t\tvec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n\t\t\tvec2 p = (-iResolution.xy + 2.0 * (fragCoord + o)) / iResolution.y;\n # else\n\t\t\t\tvec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n # endif\n\t\t\t// camera\t\n\t\t    vec3 ta =  vec3(0, 0, 0);\n\t\t\t \n            \n              vec3 ro = vec3(0,cos(mo.y ),sin(mo.y ));\n\t\t\t vec4 horz=BuildQuat(vec3(0,1,0), -mo.x*2.+iTime*0.1 );\n             ro = ta+ Rotate(horz,ro)*3.  ;\n             // camera-to-world transformation\n\t\t\tmat3 ca = setCamera(ro, ta, 0.0);\n\t\t\t// ray direction\n\t\t\tvec3 rd = ca * normalize(vec3(p.xy, 2.5));\n\t\t\t// render\n            float distance;\n    vec3 col = render(ro, rd,distance);\n\t\t\t// gamma\n\t\t\tcol = pow(col, vec3(0.4545));\n\t\t\ttot += col;\n # if AA > 1\n\t\t}\n\ttot /= float(AA * AA);\n #\tendif\n\tfragColor = vec4(tot, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// Common megapack\n#define PI  3.14159265\n#define hPI 1.57079632\n#define TAU 6.283185\n\n\n\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n//----------------------------------------------------------------------------------------\n// Quaternios\n//----------------------------------------------------------------------------------------\n vec4 NormQuat(vec4 q)\n{\n    float lenSQ = dot(q, q);\n    float invLenSQ = 1./lenSQ;\n    return q*invLenSQ;\n}\n\nvec4 BuildQuat(vec3 axis, float angle)\n{\n    angle *= 0.5;\n    float s = sin(angle);\n    return NormQuat(vec4(axis*s, cos(angle)));\n}\n\nvec4 MulQuat(vec4 q1, vec4 q2)\n{\n    vec4 res = vec4(0.);\n    res.w   = q1.w*q2.w - dot(q1.xyz, q2.xyz);\n    res.xyz = q1.w*q2.xyz + q2.w*q1.xyz + cross(q1.xyz, q2.xyz);\n    return NormQuat(res);\n}\n\n \n    \nvec3 Rotate(vec4 q, vec3 v)\n{\n    vec3 t = 2.*cross(q.xyz, v);\n    return v + q.w*t + cross(q.xyz, t);\n}\n\n\nfloat fromTo(vec3 p,vec3 q)\n{\nreturn acos(dot(p,q));\n\n}\nvec4 quatLookAt(vec3 forward,vec3 up){\n    forward=normalize(forward);\n    up=normalize(up);\nreturn  (BuildQuat(cross(forward,up),fromTo(forward,up)));\n}\n\n\nvec4 quatInv(in vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\n//https://en.wikipedia.org/wiki/Slerp#Quaternion_Slerp\n\nvec4 slerp(vec4 v0, vec4 v1, float t) {\n    // Only unit quaternions are valid rotations.\n    // Normalize to avoid undefined behavior.\n     NormQuat(v0);\n     NormQuat(v1);\n\n    // Compute the cosine of the angle between the two vectors.\n    float dotp = dot(v0, v1);\n\n    // If the dot product is negative, slerp won't take\n    // the shorter path. Note that v1 and -v1 are equivalent when\n    // the negation is applied to all four components. Fix by \n    // reversing one quaternion.\n    if (dotp < 0.0f) {\n        v1 = -v1;\n        dotp = -dotp;\n    }  \n\n      float DOT_THRESHOLD = 0.9995;\n    if (dotp > DOT_THRESHOLD) {\n        // If the inputs are too close for comfort, linearly interpolate\n        // and normalize the result.\n\n        vec4 result = v0 + t*(v1 - v0);\n        NormQuat(result);\n        return result;\n    }\n\n    // Since dot is in range [0, DOT_THRESHOLD], acos is safe\n    float theta_0 = acos(dotp);        // theta_0 = angle between input vectors\n    float theta = theta_0*t;          // theta = angle between v0 and result\n    float sin_theta = sin(theta);     // compute this value only once\n    float sin_theta_0 = sin(theta_0); // compute this value only once\n\n    float s0 = cos(theta) - dotp * sin_theta / sin_theta_0;  // == sin(theta_0 - theta) / sin(theta_0)\n    float s1 = sin_theta / sin_theta_0;\n\n    return (s0 * v0) + (s1 * v1);\n}\n\n//----------------------------------------------------------------------------------------\n// Hash without Sine  https://www.shadertoy.com/view/4djSRW\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n//----------------------------------------------------------------------------------------\n//// Created by inigo quilez - iq/2014\n//----------------------------------------------------------------------------------------\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat noise13( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( \n        mix(\n                mix( hash13( i + vec3(0.0,0.0,0.0) ), \n                     hash13( i + vec3(1.0,0.0,0.0) ), u.x),\n                mix( hash13( i + vec3(0.0,1.0,0.0) ), \n                     hash13( i + vec3(1.0,1.0,0.0) ), u.x)\n               , u.y),\n              mix(\n                mix( hash13( i + vec3(0.0,0.0,1.0) ), \n                     hash13( i + vec3(1.0,0.0,1.0) ), u.x),\n                mix( hash13( i + vec3(0.0,1.0,1.0) ), \n                     hash13( i + vec3(1.0,1.0,1.0) ), u.x)\n               , u.y)\n        \n         , u.z)\n        ;\n}\n\nvec3 noise33(  vec3 p )\n{\n    p=p+10000.;\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u;\n    u.x = f.x*f.x*(3.0-2.0*f.x);\n    u.y = f.y*f.y*(3.0-2.0*f.y);\n    u.z = f.z*f.z*(3.0-2.0*f.z);\n\n    return mix( \n        mix(\n                mix( hash33( i + vec3(0.0,0.0,0.0) ), \n                     hash33( i + vec3(1.0,0.0,0.0) ), u.x),\n                mix( hash33( i + vec3(0.0,1.0,0.0) ), \n                     hash33( i + vec3(1.0,1.0,0.0) ), u.x)\n               , u.y),\n              mix(\n                mix( hash33( i + vec3(0.0,0.0,1.0) ), \n                     hash33( i + vec3(1.0,0.0,1.0) ), u.x),\n                mix( hash33( i + vec3(0.0,1.0,1.0) ), \n                     hash33( i + vec3(1.0,1.0,1.0) ), u.x)\n               , u.y)\n        \n         , u.z)\n        ;\n}\n\nfloat fbm( vec2 p )\n{\n      mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nvec3 fbm33( vec3 p )\n{\n   \n     mat3 m = mat3(vec3(0.80,  0.60, -0.6).xyz,\n                    vec3(0.80,  0.60, -0.6).yzx,\n                    vec3(0.80,  0.60, -0.6).zxy);\n    vec3 f = vec3(0.0);\n    f += 0.5000*noise33( p ); p = m*p*2.02;\n    f += 0.2500*noise33( p ); p = m*p*2.03;\n    f += 0.1250*noise33( p ); p = m*p*2.01;\n    f += 0.0625*noise33( p );\n    return f/0.9375;\n}\n\nfloat fbm13( vec3 p )\n{\n         float m =1.;\n\n\n    float f =  (0.0);\n    f += 0.5000*noise13( p ); p = m*p*2.02;\n    f += 0.2500*noise13( p ); p = m*p*2.03;\n    f += 0.1250*noise13( p ); p = m*p*2.01;\n    f += 0.0625*noise13( p );\n    return f/0.9375;\n}\n\nvec2 fbm2( in vec2 p )\n{\n    return vec2( fbm(p.xy), fbm(p.yx) );\n}\n\n\n\n//----------------------------------------------------------------------------------------\n//http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n//----------------------------------------------------------------------------------------\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat dot2(vec2 a ) { return dot(a,a); }\n\n \nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\n \nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n \nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\n \nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\n \nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n \nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n \nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\n \nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n \nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\n \nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n \nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n \nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\n \nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 6.283185/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon,\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n \nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n \nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c = sin/cos of the aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\n \nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n \nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p;\n    p = vec2((p.y>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\n \nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\n\n \nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return sign(k)*length(max(w,0.0)) + r;\n}\n\n \n \n \nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n \nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n        vec2 qos = d + (c + b*t)*t;\n        res = dot(qos,qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n        vec2 qos = d + (c + b*t.x)*t.x;\n        res = dot(qos,qos);\n        qos = d + (c + b*t.y)*t.y;\n        res = min(res,dot(qos,qos));\n        qos = d + (c + b*t.z)*t.z;\n        res = min(res,dot(qos,qos));\n    }\n    return sqrt( res );\n}\n\n \nfloat sdRoundedShape( float d, in float r )\n{\n  return d - r;\n}\n \nfloat sdAnnularShape( float d, in float r )\n{\n  return abs(d) - r;\n}\n\n \n//----------------------------------------------------------------------------------------\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//----------------------------------------------------------------------------------------\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n \nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n \nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n \nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n \nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n \nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n \nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n \nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n \nfloat sdPlane( vec3 p  )\n{\n  // n must be normalized\n  return p.y;\n}\n \nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n \nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n \nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n \nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\n \nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n \nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n \nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n \nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n \nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n \nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n \nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n \n \n\n \nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n \n float udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n \nvec3 opElongate(  in vec3 p, in vec3 h )\n{\n    vec3 q = p - clamp( p, -h, h );\n    return   q ;\n}\n\n \n \n\n \n \n\n \nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n \n \n \nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\n \n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n \n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2016-01-10\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n//\n//\n//\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n//\n////////////////////////////////////////////////////////////////\n//\n// How to use this:\n//\n// 1. Build some system to #include glsl files in each other.\n//   Include this one at the very start. Or just paste everywhere.\n// 2. Build a sphere tracer. See those papers:\n//   * \"Sphere Tracing\" http://graphics.cs.illinois.edu/sites/default/files/zeno.pdf\n//   * \"Enhanced Sphere Tracing\" http://lgdv.cs.fau.de/get/2234\n//   The Raymnarching Toolbox Thread on pouet can be helpful as well\n//   http://www.pouet.net/topic.php?which=7931&page=1\n//   and contains links to many more resources.\n// 3. Use the tools in this library to build your distance bound f().\n// 4. ???\n// 5. Win a compo.\n// \n// (6. Buy us a beer or a good vodka or something, if you like.)\n//\n////////////////////////////////////////////////////////////////\n//\n// Table of Contents:\n//\n// * Helper functions and macros\n// * Collection of some primitive objects\n// * Domain Manipulation operators\n// * Object combination operators\n//\n////////////////////////////////////////////////////////////////\n//\n// Why use this?\n//\n// The point of this lib is that everything is structured according\n// to patterns that we ended up using when building geometry.\n// It makes it more easy to write code that is reusable and that somebody\n// else can actually understand. Especially code on Shadertoy (which seems\n// to be what everybody else is looking at for \"inspiration\") tends to be\n// really ugly. So we were forced to do something about the situation and\n// release this lib ;)\n//\n// Everything in here can probably be done in some better way.\n// Please experiment. We'd love some feedback, especially if you\n// use it in a scene production.\n//\n// The main patterns for building geometry this way are:\n// * Stay Lipschitz continuous. That means: don't have any distance\n//   gradient larger than 1. Try to be as close to 1 as possible -\n//   Distances are euclidean distances, don't fudge around.\n//   Underestimating distances will happen. That's why calling\n//   it a \"distance bound\" is more correct. Don't ever multiply\n//   distances by some value to \"fix\" a Lipschitz continuity\n//   violation. The invariant is: each fSomething() function returns\n//   a correct distance bound.\n// * Use very few primitives and combine them as building blocks\n//   using combine opertors that preserve the invariant.\n// * Multiply objects by repeating the domain (space).\n//   If you are using a loop inside your distance function, you are\n//   probably doing it wrong (or you are building boring fractals).\n// * At right-angle intersections between objects, build a new local\n//   coordinate system from the two distances to combine them in\n//   interesting ways.\n// * As usual, there are always times when it is best to not follow\n//   specific patterns.\n//\n////////////////////////////////////////////////////////////////\n//\n// FAQ\n//\n// Q: Why is there no sphere tracing code in this lib?\n// A: Because our system is way too complex and always changing.\n//    This is the constant part. Also we'd like everyone to\n//    explore for themselves.\n//\n// Q: This does not work when I paste it into Shadertoy!!!!\n// A: Yes. It is GLSL, not GLSL ES. We like real OpenGL\n//    because it has way more features and is more likely\n//    to work compared to browser-based WebGL. We recommend\n//    you consider using OpenGL for your productions. Most\n//    of this can be ported easily though.\n//\n// Q: How do I material?\n// A: We recommend something like this:\n//    Write a material ID, the distance and the local coordinate\n//    p into some global variables whenever an object's distance is\n//    smaller than the stored distance. Then, at the end, evaluate\n//    the material to get color, roughness, etc., and do the shading.\n//\n// Q: I found an error. Or I made some function that would fit in\n//    in this lib. Or I have some suggestion.\n// A: Awesome! Drop us a mail at spheretracing@mercury.sexy.\n//\n// Q: Why is this not on github?\n// A: Because we were too lazy. If we get bugged about it enough,\n//    we'll do it.\n//\n// Q: Your license sucks for me.\n// A: Oh. What should we change it to?\n//\n// Q: I have trouble understanding what is going on with my distances.\n// A: Some visualization of the distance field helps. Try drawing a\n//    plane that you can sweep through your scene with some color\n//    representation of the distance field at each point and/or iso\n//    lines at regular intervals. Visualizing the length of the\n//    gradient (or better: how much it deviates from being equal to 1)\n//    is immensely helpful for understanding which parts of the\n//    distance field are broken.\n//\n////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0, 1)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\nfloat square (float x) {\n\treturn x*x;\n}\n\nvec2 square (vec2 x) {\n\treturn x*x;\n}\n\nvec3 square (vec3 x) {\n\treturn x*x;\n}\n\nfloat lengthSqr(vec3 x) {\n\treturn dot(x, x);\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that is a distance function is called fSomething.\n// The first argument is always a point in 2 or 3-space called <p>.\n// Unless otherwise noted, (if the object has an intrinsic \"up\"\n// side or direction) the y axis is \"up\" and the object is\n// centered at the origin.\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n\treturn vmax(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n\n// Endless \"corner\"\nfloat fCorner (vec2 p) {\n\treturn length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\n \n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = clamp(dot(p - a, ab) / dot(ab, ab),0.,1.);\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// A circle line. Can also be used to make a torus by subtracting the smaller radius of the torus.\nfloat fCircle(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn length(vec2(p.y, l));\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n\t//this is mathematically equivalent to this line, but less efficient:\n\t//return max(q.y - h.y, max(dot(vec2(cos(PI/3), sin(PI/3)), q.zx), q.z) - h.x);\n}\n\n// Hexagonal prism, incircle variant\nfloat fHexagonIncircle(vec3 p, vec2 h) {\n\treturn fHexagonCircumcircle(p, vec2(h.x*sqrt(3.)*0.5, h.y));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n \n\n\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that modifies the domain is named pSomething.\n//\n// Many operate only on a subset of the three dimensions. For those,\n// you must choose the dimensions that you want manipulated\n// by supplying e.g. <p.x> or <p.zx>\n//\n// <inout p> is always the first argument and modified in place.\n//\n// Many of the operators partition space into cells. An identifier\n// or cell index is returned, if possible. This return value is\n// intended to be optionally used e.g. as a random seed to change\n// parameters of the distance functions inside the cells.\n//\n// Unless stated otherwise, for cell index 0, <p> is unchanged and cells\n// are centered on the origin so objects don't have to be moved to fit.\n//\n//\n////////////////////////////////////////////////////////////////\n\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Same, but mirror every second cell so they match at the boundaries\nfloat pModMirror1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0)*2. - 1.;\n\treturn c;\n}\n\n// Repeat the domain only in positive direction. Everything in the negative half-space is unchanged.\nfloat pModSingle1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tif (p >= 0.)\n\t\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2))*2. - vec2(1.);\n\treturn c;\n}\n\n// Same, but mirror every second cell at the diagonal as well\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\tp *= mod(c,vec2(2))*2. - vec2(1);\n\tp -= size/2.;\n\tif (p.x > p.y) p.xy = p.yx;\n\treturn floor(c/2.);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sgn(t);\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// We usually need the following boolean operators to combine two objects:\n// Union: OR(a,b)\n// Intersection: AND(a,b)\n// Difference: AND(a,!b)\n// (a and b being the distances to the objects).\n//\n// The trivial implementations are min(a,b) for union, max(a,b) for intersection\n// and max(a,-b) for difference. To combine objects in more interesting ways to\n// produce rounded edges, chamfers, stairs, etc. instead of plain sharp edges we\n// can use combination operators. It is common to use some kind of \"smooth minimum\"\n// instead of min(), but we don't like that because it does not preserve Lipschitz\n// continuity in many cases.\n//\n// Naming convention: since they return a distance, they are called fOpSomething.\n// The different flavours usually implement all the boolean operators above\n// and are called fOpUnionRound, fOpIntersectionRound, etc.\n//\n// The basic idea: Assume the object surfaces intersect at a right angle. The two\n// distances <a> and <b> constitute a new local two-dimensional coordinate system\n// with the actual intersection as the origin. In this coordinate system, we can\n// evaluate any 2D distance function we want in order to shape the edge.\n//\n// The operators below are just those that we found useful or interesting and should\n// be seen as examples. There are infinitely more possible operators.\n//\n// They are designed to actually produce correct distances or distance bounds, unlike\n// popular \"smooth minimum\" operators, on the condition that the gradients of the two\n// SDFs are at right angles. When they are off by more than 30 degrees or so, the\n// Lipschitz condition will no longer hold (i.e. you might get artifacts). The worst\n// case is parallel surfaces that are close to each other.\n//\n// Most have a float argument <r> to specify the radius of the feature they represent.\n// This should be much smaller than the object size.\n//\n// Some of them have checks like \"if ((-a < r) && (-b < r))\" that restrict\n// their influence (and computation cost) to a certain area. You might\n// want to lift that restriction or enforce it. We have left it as comments\n// in some cases.\n//\n// usage example:\n//\n// float fTwoBoxes(vec3 p) {\n//   float box0 = fBox(p, vec3(1));\n//   float box1 = fBox(p-vec3(1), vec3(1));\n//   return fOpUnionChamfer(box0, box1, 0.2);\n// }\n//\n////////////////////////////////////////////////////////////////\n\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n\treturn max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n\treturn fOpIntersectionChamfer(a, -b, r);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n\ta = -a;\n\tfloat m = min(a, b);\n\t//avoid the expensive computation where not needed (produces discontinuity though)\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/n/2.0;\n\t\tcolumnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\n\t\tpR45(p);\n\t\tp.y += columnradius;\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += -columnradius*sqrt(2.)/2.;\n\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\tpMod1(p.y,columnradius*2.);\n\n\t\tfloat result = -length(p) + columnradius;\n\t\tresult = max(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn -min(result, b);\n\t} else {\n\t\treturn -m;\n\t}\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n\treturn fOpDifferenceColumns(a,-b,r, n);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\n\n// Similar to fOpUnionRound, but more lipschitz-y at acute angles\n// (and less so at 90 degrees). Useful when fudging around too much\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\n\n// produces a cylindical pipe that runs along the intersection.\n// No objects remain, only the pipe. This is not a boolean operator.\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\n// first object gets a v-shaped engraving where it intersect the second\nfloat fOpEngrave(float a, float b, float r) {\n\treturn max(a, (a + r - abs(b))*sqrt(0.5));\n}\n\n// first object gets a capenter-style groove cut out\nfloat fOpGroove(float a, float b, float ra, float rb) {\n\treturn max(a, min(a + ra, rb - abs(b)));\n}\n\n// first object gets a capenter-style tongue attached\nfloat fOpTongue(float a, float b, float ra, float rb) {\n\treturn min(a, max(a - ra, abs(b) - rb));\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "4lyBzK",
    "date": "1543068571",
    "viewed": 333,
    "name": "House: shape over shape ",
    "description": "House UPDATED: more fidelity  \nSorry for the messy code, Just a plaything so far.\nMore than just a lathe in my opinion.\nuse one 2d SDF to find a 2D dist of  say ( X , Y )  then use that  with remaining axis Z to look up another 2d SDF  (dist , Z) \n",
    "likes": 33,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "2d",
     "sdf",
     "shape"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGzn",
       "filepath": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "\n\n// Fork of \"2 * 2d -> 3d  \" by TLC123. https://shadertoy.com/view/MlyfRW\n// 2018-11-21 16:26:28\n\n// Fork of \"The Walking Raymarcher\" by xorxor. https://shadertoy.com/view/Mt3XWH\n// 2018-11-11 15:37:21\n\n\n// tracer from  https://shadertoy.com/view/Mt3XWH\n// sdPentagon from https://www.shadertoy.com/view/llVyWW\n// roundrect forked fromm https://www.shadertoy.com/view/4sjyRz\n// http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n// https://www.shadertoy.com/view/XdfXDB\n// http://mercury.sexy/hg_sdf/\n// sexy union functions work just as great in 2D\n\n// grass https://www.shadertoy.com/view/ls33W7\nfloat  tile=24.0;\n\nfloat hash1( vec2 n )\n{\n    return fract(sin(dot(n,vec2(1.0,113.0)))*43758.5453123);\n}\nfloat fOpPipe(float a, float b, float r) {\n    return length(vec2(a, b)) - r;\n}\nvec2 pR45(  vec2 p) {\n    p = (p + vec2(p.y, -p.x)) * sqrt(0.5);\n    return (p);\n}\nvec2 pR90(  vec2 p) {\n    p = (vec2(p.y, -p.x)) ;\n    return (p);\n}\nfloat pMod1(inout float p, float size) {\n    float halfsize = size * 0.5;\n    float c = floor((p + halfsize) / size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n    if ((a < r) && (b < r)) {\n        vec2 p = vec2(a, b);\n        float columnradius = r * sqrt(2.0) / ((n - 1.) * 2. + sqrt(2.));\n        pR45(p);\n        p.x -= sqrt(2.) / 2. * r;\n        p.x += columnradius * sqrt(2.);\n        if (mod(n, 2.) == 1.) {\n            p.y += columnradius;\n        }\n        // At this point, we have turned 45 degrees and moved at a point on the\n        // diagonal that we want to place the columns on.\n        // Now, repeat the domain along this direction and place a circle.\n        pMod1(p.y, columnradius * 2.);\n        float result = length(p) - columnradius;\n        result = min(result, p.x);\n        result = min(result, a);\n        return min(result, b);\n    } else {\n        return min(a, b);\n    }\n}\n// first object gets a capenter-style groove cut out\nfloat fOpGroove(float a, float b, float ra, float rb) {\n    return max(a, min(a + ra, rb - abs(b)));\n}\n\n// first object gets a capenter-style tongue attached\nfloat fOpTongue(float a, float b, float ra, float rb) {\n    return min(a, max(a - ra, abs(b) - rb));\n}\n\nfloat fOpEngrave(float a, float b, float r) {\n    return max(a, (a + r - abs(b)) * sqrt(0.5));\n}\n\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n    float s = r / n;\n    float u = b - r;\n    return min(min(a, b), 0.5 * (u + a + abs((mod(u - a + s, 2. * s)) - s)));\n}\n\nfloat sdBox( in vec2 p, in vec2 b) {\n    vec2 d = abs(p) - b;\n    return (max(d.x, d.y));\n}\n\n\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2) {\n    vec2 e0 = p1 - p0, e1 = p2 - p1, e2 = p0 - p2;\n    vec2 v0 = p - p0, v1 = p - p1, v2 = p - p2;\n\n    vec2 pq0 = v0 - e0 * clamp(dot(v0, e0) / dot(e0, e0), 0.0, 1.0);\n    vec2 pq1 = v1 - e1 * clamp(dot(v1, e1) / dot(e1, e1), 0.0, 1.0);\n    vec2 pq2 = v2 - e2 * clamp(dot(v2, e2) / dot(e2, e2), 0.0, 1.0);\n\n    float s = sign(e0.x * e2.y - e0.y * e2.x);\n    vec2 d = min(min(vec2(dot(pq0, pq0), s * (v0.x * e0.y - v0.y * e0.x)),\n            vec2(dot(pq1, pq1), s * (v1.x * e1.y - v1.y * e1.x))),\n        vec2(dot(pq2, pq2), s * (v2.x * e2.y - v2.y * e2.x)));\n\n    return -sqrt(d.x) * sign(d.y);\n}\n\n\n\nfloat smin(float a, float b) {\n    const float k = .26;\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n\n}\n\nfloat smax(float d1, float d2, float k) {\n\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n}\n\n\nfloat roundrect(vec2 p, vec2 c, vec2 r) {\n\n    p = abs(p) - c + r;\n    if (p.x >= 0.0 && p.y >= 0.0)\n        return length(p) - r.x;\n    else\n        return max(p.x, p.y) - r.x;\n}\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n\nfloat shape1(vec2 p ,float seed) {\n   \n    \n p=fract(p/tile)*tile;\n  p = vec2(abs(p.x)-(tile*0.5)  ,p.y-(tile*0.5+3.)  ); \n    \nif (fract(seed*7.1)<=0.5){p=pR90(p);           }\nif (fract(seed*9.1)<=0.5){p=pR90(p);           }\n   if (seed<=0.5){p=p.yx;           }\nif (fract(seed*3.1)<=0.5){p=pR90(p);           }\n\n    float d = roundrect(p - vec2(0, -3), vec2(6, 3),vec2(0.));\n\n    if (fract(seed*13.1)<=0.5){p=pR90(p);           }\n    \n      p = vec2(  (p.x)  +cos(seed*17.)*1.25 ,p.y +sin(seed*27.)*1.25); \n\n\n\n    d = fOpUnionStairs(d, roundrect(p - vec2(0, -4.4), vec2(2.2, 3),vec2(0.)), .6, 2.);\n    //d=min(d,   sdBox(p-vec2(0,-2),vec2(2,2) ) );\n    // d=fOpUnionStairs(d, sdLine(p,vec2(0,0),vec2(0,-3))-2. ,.8,2.);\n\n    d = fOpUnionStairs(d, sdLine(p, vec2(0, 0), vec2(0, -3)) - 1.9, .5, 2.);\n    d = fOpUnionStairs(d, sdLine(p, vec2(0, 2), vec2(0, -3)), .5, 2.);\n    d = fOpUnionStairs(d, sdLine(p, vec2(1.4, 1.4), vec2(0, 0)), .5, 2.);\n    d = fOpUnionStairs(d, sdLine(p, vec2(-1.4, 1.4), vec2(0, 0)), .5, 2.);\n\n      p= vec2(abs(p.x),p.y); // mirror p\n    \n    float g = sdBox(p - vec2(0, -3), vec2(4.45, 11));\n    g = smin(g, sdBox(p - vec2(0, -3), vec2(12, 1.42)));\n    //d=min(d,fOpGroove(d,g,0.2,0.51));\n    // d=fOpGroove(d,g,0.2,0.51);\n    d = (fOpTongue(d, g, 0.2, 0.7*seed*seed));\n\n    float g1 = (sdBox(p - vec2(0, -6), vec2(1.3, 4)));\n    d = smin(d, fOpPipe(d - .6, g1, 0.4*seed));\n\n    return (d);\n}\n\n\nfloat shape2(vec2 p,float seed) {\n    \n    \n\n    float d = sdTriangle(p, vec2(0.5, 3), vec2(-4.+sin(seed*10.)*2., 5.+seed*3.), vec2(-10., 5.+seed*3.)); //roof\n    d = min(d, sdTriangle(p, vec2(0.5, 3), vec2(-10., 3), vec2(-10.,5.+seed*3.)));\n\n    d = fOpUnionColumns(d, roundrect(p - vec2(-.4, 3), vec2(1.04, .1), vec2(0.1)), .19, 2.);\n\n\n    d = min(d, roundrect(p - vec2(0, -.5), vec2(0.6, .4), vec2(0.03))); //base\n\n    d = fOpUnionStairs(d, roundrect(p - vec2(-5, 0.4), vec2(5., 2.5), vec2(0.)), 0.3, 2.);\n\n    d = fOpUnionStairs(d, roundrect(p - vec2(0, -1.34), vec2(2.6, .4), vec2(0.)), 0.6, 3.); //base\n\n    d = min(d, roundrect(p - vec2(0, 0.9), vec2(.06, .06), vec2(0.)));\n    d = min(d, roundrect(p - vec2(0, 1.9), vec2(.06, .06), vec2(0.)));\n    d=min(d, p.y + 0.9  );\n \n\n\n    return   d ;\n}\n\nfloat noise(vec2 p){\n    return texture(iChannel0,fract(p)).r;\n}\nvec3 grass(vec2 p){\n    \n    return vec3(mix(\n        vec3(0.12,0.71,0.),\n        vec3(0.07,0.47,0.),\n        noise(p)\n    ));\n}\n\n\nvec4 map(vec3 p) {\n    float plane = abs(p.y + 0.9);\n\nfloat r= hash1(floor(p.xz/tile))*0.5+0.5;    \nfloat g= hash1(vec2(floor(p.xz/tile)+2.));    \nfloat b= hash1(vec2(floor(p.z/tile)))*0.25;    \n\n\n\n    float w = shape1(p.xz,r);\n    float d = shape2(vec2(w, p.y),g);\n\n\n    return (p.y<-0.8 ?vec4(d,grass(  p.xz*0.04)):vec4(d, vec3(r,g,b)/ max(1.,4.*(p.y-2.2)) ));\n}\n\nfloat calcShadow(vec3 ro, vec3 rd, float mint, float maxt) {\n    float t = mint;\n    float res = 1.0;\n    for (int i = 0; i < 100; i++) {\n        float h = map(ro + rd * t).x;\n        res = min(res, 1.1 * h / t);\n        t += h;\n        if ((h < 0.001) || (t > maxt)) {\n            break;\n        }\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nvec4 trace(vec3 ro, vec3 rd) {\n    const float kTMin = 0.001;\n    const float kTMax =300.0;\n    const float kEps = 0.0001;\n\n    float t = kTMin;\n    vec4 res;\n    for (int i = 0; i < 370; i++) {\n        vec3 pos = ro + rd * t;\n        res = map(pos);\n        if ((res.x < kEps) || (t > kTMax)) {\n            break;\n        }\n        t += res.x * 0.25;\n    }\n\n    if (t < kTMax) {\n        return vec4(t, res.yzw);\n    } else {\n        return vec4(-1.0,0,0,0);\n    }\n}\n\nvec3 calcNormal(vec3 p) {\n    const vec2 e = vec2(0.005, 0);\n    float dp = map(p).x;\n    return normalize(vec3(dp - map(p - e.xyy).x,\n        dp - map(p - e.yxy).x,\n        dp - map(p - e.yyx).x));\n}\n\nmat3 calcCamera(vec3 eye, vec3 target) {\n    vec3 cw = normalize(target - eye);\n    vec3 cu = cross(cw, vec3(0, 1, 0));\n    vec3 cv = cross(cu, cw);\n    return mat3(cu, cv, cw);\n}\n\nvec3 cameraPath( float t )\n    \n{\n    t=t*4.;\n    vec2 p  = vec2(400.0*sin(t/102.),400.*cos(t/103.));\n \tp  += vec2(40.0*sin(t/12.),60.*cos(t/13.));\n    float z = 18.0+1.*sin(t/02.) ;\n\n\treturn vec3( p.x,z , p.y );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\n    vec2 mo = vec2(0.95, -0.2);\n    if (iMouse.z > 0.5) {\n        mo = 10.0 * iMouse.xy / iResolution.xy - 1.0;\n        mo *= 3.14159 * vec2(0.4, 0.1);\n    }\n    mo += 3.14159 * 0.15 * iTime;\n\n    vec3 eye = cameraPath(iTime);\n    vec3 target = cameraPath(iTime+23.+sin(iTime)*6.)-vec3(0,30,0);\n\n    mat3 cam = calcCamera(eye, target);\n\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 rd = cam * normalize(vec3(uv, 2.0));\n\n    vec3 col = vec3(0.60);\n\n    vec4 res = trace(eye, rd);\n    if (res.x > 0.0) {\n        vec3 pos = eye + rd * res.x;\n        vec3 nor = calcNormal(pos);\n        vec3 ldir = normalize(vec3(-10.5, 20.8, 24.0));\n\n        if (res.y < 1.5) {\n                        col = col* 0.4 + 0.6 * (vec3(1) - nor.zxy);\n            col = col*0.2 + 0.8 * (vec3(res.yzw) );\n\n            float dif = abs(dot(nor, ldir));\n            vec3 ref = reflect(rd, nor);\n            float spe = pow(clamp(dot(ref, ldir), 0.0, 1.0), 2.0);\n\n            col *= (0.2 + 0.8 * dif);\n            float edge = pow(1.0 - dot(-rd, nor), 1.011);\n            col += 0.1 * edge + spe;\n        }\n\n        float sh = calcShadow(pos, ldir, 0.1, 30.0);\n        col *= (0.5 + sh);\n    }\n\n\n \n    if (fract((iTime + 1.) / 10.) < 0.165) {\n        // col=vec3( shape1(uv*20.-vec2(0,4))>0. )\n\n        float len = shape1(eye.xz+uv * 50. - vec2(0, 4), hash1(floor((eye.xz+uv * 50. - vec2(0, 4))/tile))) / 10.;\n\n        //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n        col = vec3(1.0) - sign(len) * vec3(0.1, 0.4, 0.7);\n        col *= 1.0 - exp(-iResolution.y * 0.008 * abs(len));\n        col *= 0.8 + 0.2 * cos(iResolution.y * 0.3 * abs(len));\n        col = mix(col, vec3(1.0), max(1.0 - abs(len) * iResolution.y * 0.2, 0.0));\n        fragColor = vec4(col * col, 1.0);\n    }\n    if (fract((iTime + 1.) / 10.) < 0.08) {\n        // col=vec3( shape2(uv*20.-vec2(0,-8))>0. );\n\n        float len = shape2(uv * 20. - vec2(0, -2), hash1(floor((uv * 20. - vec2(0, -2))/tile))) / 10.;\n\n        //distance field coloring by iq https://www.shadertoy.com/view/4lcBWn\n        col = vec3(1.0) - sign(len) * vec3(0.1, 0.4, 0.7);\n        col *= 1.0 - exp(-iResolution.y * 0.008 * abs(len));\n        col *= 0.8 + 0.2 * cos(iResolution.y * 0.3 * abs(len));\n        col = mix(col, vec3(1.0), max(1.0 - abs(len) * iResolution.y * 0.2, 0.0));\n        if (abs(uv.x) < 0.005) col = vec3(1.);\n\n        fragColor = vec4(col * col, 1.0);\n    }\n    fragColor = vec4(col, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WsGyWw",
    "date": "0",
    "viewed": 0,
    "name": "Inverse Spherical Fibonacci UV ",
    "description": "Spherical Fibonacci points, as described by this paper [url]https://dokumen.tips/documents/spherical-fibonacci-mapping-fibonacci-mapping-benjamin-keinert-1matthias-innmann.html[/url]",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "3d",
     "fibonazzi",
     "uvmap"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Inverse Spherical Fibonacci\" by iq. https://shadertoy.com/view/lllXz4\n// 2020-10-17 06:19:25\n\n// The MIT License\n// Copyright © 2015 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n// Spherical Fibonnacci points, as described by Benjamin Keinert, Matthias Innmann, \n// Michael Sanger and Marc Stamminger in their paper (below)\n\n\n//=================================================================================================\n// https://dokumen.tips/documents/spherical-fibonacci-mapping-fibonacci-mapping-benjamin-keinert-1matthias-innmann.html\n//=================================================================================================\nconst float PI  = 3.14159265359;\nconst float PHI = 1.61803398875;\n\n\nvec3 inverseSF( vec3 p, float n ) \n{\n    float m = 1.0 - 1.0/n;\n    float U;\n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2  F  = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );    \n    \n    mat2 iB = mat2( ka.y, -ka.x, \n                    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n    \n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    vec2 ca =  ( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n     vec2 uv ;\n    vec3 q;\n    for( int s=0; s<4; s++ ) \n    {\n          uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float i = dot(F, uv + c); // all quantities are ingeters (can take a round() for extra safety)\n        float phi = 2.0*PI*fract(i*PHI);\n        float cosTheta = m - 2.0*i/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n          q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta );\n        \n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) \n        {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n            \n \n     uv = vec2( float(2-2*(2/2)), float(2/2) );\n        \n        float  i = dot(F, uv + c); // all quantities are ingeters (can take a round() for extra safety)\n          phi = 2.0*PI*fract(i*PHI);\n          cosTheta = m - 2.0*i/n;\n         float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 qc = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta );\n     uv = vec2( float(0-2*(0/2)), float(0/2) );\n        \n          i = dot(F, uv + c); // all quantities are ingeters (can take a round() for extra safety)\n          phi = 2.0*PI*fract(i*PHI);\n          cosTheta = m - 2.0*i/n;\n          sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n          q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta );\n    \n        U=   1.+(dot(normalize(p-qc),normalize(p-q)));\n    \n    return vec3( j, sqrt(d),U );\n}\n\n\n//=================================================================================================\n// iq code starts here\n//=================================================================================================\n\nfloat hash1( float n ) { return fract(sin(n)*158.5453123); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 1.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    // sphere center\t\n\tvec3 sc = vec3(0.0,1.0,0.0);\n    \n    vec3 col = vec3(1.0);\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tfloat occ = 1.0;\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tvec3 di = sc - pos;\n\t\tfloat l = length(di);\n\t\tocc = 1.0 - dot(nor,di/l)*1.0*1.0/(l*l); \n        col = vec3(1.0);\n\t}\n\n\t// raytrace-sphere\n\tvec3  ce = ro - sc;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - 1.0;\n\th = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\th = -b - sqrt(h);\n\t\tif( h<tmin ) \n\t\t{ \n\t\t\ttmin=h; \n\t\t\tnor = normalize(ro+h*rd-sc); \n\t\t\tocc = 0.5 + 0.5*nor.y;\n\t\t}\n        \n        const float precis = 150.0;\n        vec3 fi = inverseSF(nor, precis);\n        col = 0.5 + 0.5*sin( hash1(fi.x*13.0)*3.0 + 1.0 + vec3(0.0,1.0,1.0));\n        col *= smoothstep(0.02, 0.03, fi.z);\n        col *= mix( 1.0, 1.0 - smoothstep(0.12, 0.125, fi.y), smoothstep(-0.1,0.1,sin(iTime) )) ;\n        col *= 1.0 + 0.1*sin(250.0*fi.y);\n        col *= 1.5;\n\t}\n\n\tif( tmin<100.0 )\n\t{\n\t    pos = ro + tmin*rd;\n\t\tcol *= occ;\n\t\tcol = mix( col, vec3(1.0), 1.0-exp( -0.003*tmin*tmin ) );\n\t}\n\t\n\tcol = sqrt( col );\n\t\n\tfragColor = vec4( col, 1.0 );\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tlXSRs",
    "date": "1563896306",
    "viewed": 156,
    "name": "Local UV from along +  dist ",
    "description": "Playing  with distance functions that return a distans + a more or less perpendicular  \"along\" component for building a secondary SDF in the local coordinate system. Oblivious care needs to be taken when modelling.  ",
    "likes": 5,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "sdf"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// The MIT License\n// Copyright © 2018 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n \n// and many more here:   http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\nvec2 opSmoothUnion2d( vec2 d1, vec2 d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.y-d1.y)/k, 0.0, 1.0 );\n    float hx = clamp( 0.5 + 0.5*(d2.y-d1.y)/(k*1.4), 0.0, 1.0 );\n    return vec2(\n       mix( d2.x, d1.x, hx ) - (k*1.4)*hx*(1.0-hx) ,\n\t    // d2.y< d1.y?d2.x:d1.x,\n        mix( d2.y, d1.y, h ) - k*h*(1.0-h) );\n}\n\nvec2 sdBox2d( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return vec2( min(abs(p.x),abs(p.y))*max(b.x,b.y), length(max(d,vec2(0))) + min(max(d.x,d.y),0.0));\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\nvec2 sdCircle2d( vec2 p, float r )\n{\n  return vec2(atan(p.y,p.x)/6.28318, length(p) - r);\n} \n\nvec2 sdCircle2dCC( vec2 p, float r )\n{\n    float a=atan(p.y,p.x)*r;\n  //  a=abs(a*2.-1.);\n\n  return vec2(a, length(p) - r);\n} \n\n\nvec2 sdCircle2dCW( vec2 p, float r )\n{\n    float a=atan(p.y,p.x)*r;\n//a=abs(a*2.-1.);\n  return vec2( a , length(p) - r);\n} \n\nvec2 sdBezier2d( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    float t;\n    float t2;\n    float bezlength= (length(A-B)+length(B-C)+length(A-C))*.35 ;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n          t = uv.x + uv.y - kx;\n          t2 = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n        vec2 qos = d + (c + b*t)*t;\n        res = dot(qos,qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        vec3 tc =t;\n        t2=tc.x;\n \t\tt = clamp( t, 0.0, 1.0 );\n\t\tvec2 qos = d + (c + b*t.x)*t.x;\n        res = dot(qos,qos);\n        qos = d + (c + b*t.y)*t.y;\n        t2=(res>dot(qos,qos))?tc.y:t2 ;\n        res = min(res,dot(qos,qos));\n        qos = d + (c + b*t.z)*t.z; \n        t2=(res>dot(qos,qos))?tc.z:t2 ;\n        res = min(res,dot(qos,qos));\n    }\n    t2-=0.5;\n    return vec2( t2*bezlength,sqrt( res ));\n}\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n\n    float b = sqrt(r*r-d*d);  // can delay this sqrt by rewriting the comparison\n    return ((p.y-b)*d > p.x*b) ? length(p-vec2(0.0,b))\n                               : length(p-vec2(-d,0.0))-r;\n}\nvec2 min2d(vec2 a, vec2 b){\nreturn a.y<b.y ?a:b;\n}\n\nvec3 map(vec2 p){\n    vec2 v0 = vec2(-.5,-0.5)+(vec2(1.3,0.9)*cos(iTime*1.1 + vec2(0.0,5.0) ))*0.35;\n    vec2 v2 = vec2(.5,0.5)+(vec2(1.3,0.9)*cos(iTime*1.3 + vec2(2.0,1.0) ))*0.35;\n    vec2 n=normalize(v2-v0);\n    vec2 v1 = mix(v0,v2,0.5+cos(iTime*.651)*0.25  )+vec2(n.y,-n.x) *sin(iTime*.51)*length(v0-v2)*0.7;\n\n    float d;\n    vec2 res ;\n    vec2 res1 ;\n    vec2 res2 ;\n    if (mod(iTime*0.025,1.)>0.5){\n     res = sdBezier2d( p, v0,v1,v2 )-.2 ;\n\n    }else{\n      res1 =  sdCircle2dCC(p-v0,.6)  ;\n   res2=     sdBox2d(p-v2,vec2(.4,.6)) ;\n      //  res2=     sdCircle2dCW(p-v1,.6) ;\n//   res= min2d( res, sdCircle2dCW(p-v1,.6)   );\n   //res= min2d( res, sdBox2d(p-v1,vec2(.4,.4))-0.15  );\n \n        \n    res=opSmoothUnion2d(res1,res2,.6);\n \n       \n       }\n         // res.x=fract(res.x-0.5) ;   \n\n    res.x=abs((fract(res.x*4.)-0.5)*2. )*(1./4.) ; \n      \nd=res.y;\n d=sdBox( res  ,vec2( 0.12,0.06));  \nreturn vec3(res.x,res.y, d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\nvec3 res=map(p);\n\tfloat d = res.x;\n    float ovr=1.;\n        vec3 col  = vec3(1.0) ;\n        if (mod(iTime*0.05,1.)>0.164)d = res.y;\n    if (mod(iTime*0.05,1.)>0.33){\n        d = res.z; \n        }\n    if (mod(iTime*0.0125,.5)<0.025) d=0.021;\n    \n    if (abs(res.y)<0.02 && res.x<0.02)ovr=10.;\n    //if (abs(res.y)<0.01 && res.x<0.01)ovr=0.;\n\n     if (mod(iTime*0.0125,.5)<0.025)ovr=0.;\n\n      col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\n                         \n    \n\t//col *= 1.0 - exp(-4.0*abs(d));\n     col = mix( col, col*(1.0 - exp(-9.0*abs(d))), 1.0-smoothstep(0.01,.25,abs(d)) );\n\n\tcol *= 0.8 + 0.2*cos(140.0*d);\n\t col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n     col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.005,abs(d)) );\n    \n    if (mod(iTime*0.05,1.)>0.66){\n     col = mod(vec3(round(res.x*5.  ),round(res.y*5.  ),0 ),2.0) ;  \n    }\n     col *=ovr;\n\tfragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wd2yzd",
    "date": "0",
    "viewed": 0,
    "name": "Motion Tweening bckup",
    "description": "Creating a looping magnetized block animation using basic motion tweening techniques. ",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "motion",
     "tweening",
     "keyframe"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4sXGRn",
       "filepath": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Motion Tweening\" by Shane. https://shadertoy.com/view/wslcDS\n// 2020-04-18 11:46:15\n\n/*\n\n\n\tMotion Tweening\n\t---------------\n\n\tCreating a looping animation with magnetized blocks utilizing basic motion \n    tweening techniques. The animation sequence itself is a rough recreation \n    of a sequence I've seen around in GIF form on the internet. I'm not sure \n    where the original came from, but if I were to take a guess, I'd say it was \n    created by Andreas Wannerstedt, who produces a lot of mesmerizing looping \n    animations, but don't quote me on it.\n\n    I've been away for a while, so wanted to start with something relatively\n\tsimple. Motion tweening requires a bit of effort, but is relatively easy\n\trepetitive work. Demosceners do stuff like this all the time, but for those \n\tnot familar with the process, you just choose a total looping time \n    (tm = mod(iTime, totalTime)), then partition it into individual time segments \n    using a case statement, or some if-elseif statements. The segment intervals \n    themselves are filled with interpolated motion, distortion, morphing, etc.\n\n    As you can see, none of the individual movements are particularly complex;\n    rotations, pivots, translations, etc -- A lot of it was made up on the fly,\n\tso I'd imagine there'd be more efficient ways to achieve the same. One thing\n\tto note is that the colored cube moves in conjunction with the larger one, \n    which might throw some people off, but that's just a simple case of moving \n    the chrome looking box, setting the cube coordinates to the chrome box \n\tcoordinate system (p = pPrevious), then peforming more simple operations.\n\t\n    I seem to say this a lot, but apologies in advance for the extended compile\n\ttime. This should run pretty quickly, but the lengthy decision-making logic\n\tinside the raymarching loop taxes the compiler, which is amplified with the \n\treflection pass. By the way, you could simplify the objects and use IQ's \n    raytraced rounded-box intersection formulas to make this way, way more\n\tefficient. However, keeping track of the rotations for normal calculations, \n    and so forth, would get pretty tiresome... It's the kind of thing I'll leave \n    for Dr2 to do. :)\n\n\n\n    Other examples:\n\n\n    // This is one of the most clever and innovative examples on here.\n    [SH18] Human Document - reinder\n    https://www.shadertoy.com/view/XtcyW4\n\n*/\n\n#define FAR 30.\n\nvec4 vObjID;\nint objID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n \n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){ \n    \n    n = max(abs(n) - .2, 0.001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(1)); \n    n /= length(n);\n    \n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\n// Time variables.\nfloat tm, t, t2;\n\n// Animation segment ID.\nint segID = 0;\n\n// The motion tween block. There's another withing the raymarching loop. \n// We're performing whatever nonpositional lengthy calculations we can outside \n// the raymarching loop. Usually, declaring things locally can help speed things\n// up, but there is a point where precalculation is necessary. In any case, taking\n// things outside the raymarching loop should reduce compile time... Although,\n// with GPUs, who knows. A lot of it's hit and miss.\n//\nvoid doTweenTime(){\n    \n    \n    // The total loop time. We're starting after the ten second mark.\n    tm = mod(iTime + 10., 10.25);\n    \n    if(tm<1.){ // if(tm>=0. && tm<1.)\n        \n        // Normalize to the zero to one range: Time minus start time, divide total time;\n        t = tm;//(tm - 0.)/(1. - 0.);\n        // At this point, you can perform whatever kind of easing function, etc, on the \n        // normalized figures. \n        t = bounceOut(t);\n          \n        // Afterwards, adjust according to start value and end value.\n        // In this case, we wish to rotate from zero to PI/2.\n        t = mix(0., PI/2., t);\n        \n        // Setting a segment ID. This isn't really necessary, but I wanted the logic\n        // inside the raymarching loop as simple as possible. The theory being that\n        // \"if(segID == 0)\" should compile better than \"if(tm<1.),\" but it also allows\n        // for \"switch\" statement usage.\n        segID = 0;\n        \n    }\n    else if(tm<2.){ // if(tm>=1. && tm<2.)\n        \n        t = tm - 1.; // (tm - 1.)/(2. - 1.);\n        t2 = exponentialInOut(t);\n        t = easeInOutCubic(t);\n        \n        segID = 1;\n      \n    }      \n    else if(tm<3.){\n        \n        t = tm - 2.; // (tm - 2.)/(3. - 2.);\n        t2 = t;\n        t = exponentialOut(t);\n        \n        \n        segID = 2;\n  \n    }    \n    else if(tm<4.){\n         \n        // Normalize to the zero to one range: Time minus start time, divide total time;\n        t = tm - 3.; // (tm - 3.)/(4. - 3.);\n        t2 = t; // easeOutQuad(t);\n        t = bounceOut(t);\n        t = mix(0., PI/2., t);\n        \n        segID = 3;\n    }\n    else if(tm<5.){\n        \n        t = tm - 4.; // (tm - 4.)/(5. - 4.);\n        t2 = easeInQuad(t);\n        t = easeInOutCubic(t);\n        t = mix(PI/2., 0., t);\n        \n        segID = 4;\n        \n     }\n    else if(tm<6.){\n        \n        // Time minus start time, divide total time;\n        t = tm - 5.; // (tm - 5.)/(6. - 5.);\n        t2 = t;\n        // Easing.\n        t = easeInOutCubic(t);\n        // We're performing a half turn.\n        t = mix(0., PI/1., t);\n        \n         segID = 5;\n \n    }\n    else if(tm<7.){\n       \n        // Time minus start time, divide total time;\n        t = tm - 6.; // (tm - 6.)/(7. - 6.);\n        // Easing.\n        t = bounceOut(t);\n        // We're performing a half turn.\n        t = mix(0., -PI/2., t);\n        \n        segID = 6;\n    }\n    else if(tm<8.){\n       \n        // Gold cube pivot to join the left leaning larger block.\n        t = tm - 7.; // (tm - 7.)/(8. - 7.);\n        t = easeInOutCubic(t);\n        t2 = t;\n        \n        segID = 7;\n       \n    }\n    else if(tm<9.){\n       \n        t = tm - 8.; // (tm - 8.)/(9. - 8.);\n        t2 = t;\n        t = easeInOutCubic(t);\n        t = mix(PI/2., 0., t);\n        \n        segID = 8;\n        \n     }  \n    else if(tm<10.){\n       \n        t = tm - 9.; // (tm - 9.)/(10. - 9.);\n        t2 = easeOutQuad(t);\n        \n        segID = 9;\n           \n    }\n    else if(tm<10.25){\n     \n        segID = 10;\n    }    \n    \n    \n}\n\n\n\n// Distance function: This one is pretty simple.\nfloat map(vec3 p){\n\n\n    // Floor.\n    float fl = p.y;  //-sBoxS(p - vec3(0, 3, 0), vec3(6, 3, 6),.04);//min(p.y, -p.y + 3.8);\n    \n    \n\n   \n    const vec3 bDim = vec3(.25, .5, .25);\n    const vec3 bDim2 = vec3(.25, .25, .25);\n    vec3 svDim = bDim;\n\n    \n    \n    \n    vec3 q = p, q2 = p;\n    \n    // I debated over whether to use a switch statement versus the else-if mess you see here. \n    // They say switches are faster with more that a few items, but for whatever reason, my \n    // compiler hated the switch statement... When all's said and done, I know of a much,\n    // much faster way, but it'll require some considerable restructuring.\n    \n    if(segID == 0){\n        \n        \n        // \"segID == 0\" corresponds to the time period between zero and one second. The\n        //  time, \"t,\" has been normalized to the zero to one range (trivial, in this case)\n        // and has been passed through an easing function. Which easing function is chosen \n        // depends on the movement style you're after; ease-in, exponential-out, bounce, etc. \n\n        \n        \n        // Begin with the large box at floor level.\n        q.y -= bDim.y;\n        \n        // Lean down right.\n        // This is a pivot motion. Basically, you offset the position to the pivot point,\n        // whilst rotating and offsetting by the pivot amount. In this case, the pivot\n        // point is at moved from the middle pivot position, vec3(0) to vec3(bDim.x, bDim.y, 0),\n        // which represents the middle of the lower left edge, and we're rotating about the\n        // XY plane. By the way, 3D rotations could be utilized, but I'm trying to stick to\n        // the basics.\n        q.xy = rot2(-t)*(q.xy - vec2(bDim.x, -bDim.y)) - vec2(-bDim.x, bDim.y);\n        \n        // Gold cube pivotal flip, with respect to the larger cube's preoriented transform.\n        //\n        // Set the colored cube coordinates to the chrome boxes coordinats. Using a second \n        // variable for the second objects coordinates isn't absolutely necessary, but I think\n        // it reads better.\n        q2 = q; \n        q2.y -= -bDim2.y; // Move into position with respect to the chrome cube.\n        // Pivot -- See the pivot explanation above.\n        q2.xy = rot2(-t)*(q2.xy - vec2(-bDim2.x, bDim2.y)) - vec2(-bDim2.x, -bDim2.y);\n   \n        \n    }\n    else if(segID == 1){\n        \n        \n        // Slide and shrink the height.\n        q.x -= mix(0., -bDim.x*3., t);\n        q.y -= bDim.y;\n        svDim.y = mix(bDim.y, bDim.y/2., t);\n        \n        q.xy = rot2(-PI/2.)*(q.xy - vec2(bDim.x, -bDim.y)) - vec2(-bDim.x, bDim.y);\n        \n        // Gold cube slide.\n        // Move the cube relative to the large block position, q.\n        q2 = q;\n        q2.x -= -bDim.x*2.; \n        q2.y -= mix(bDim.x, 0., t);\n\n        // Spinning relative to the q axes -- The global XZ axes to the viewer, but the\n        // YZ axes from the perspective of the chrome cube.\n        q2.yz = rot2(t2*PI*2.)*q2.yz;\n     \n    }      \n    else if(segID == 2){\n        \n        // Grow taller.\n        svDim.y = mix(bDim.y/2., bDim.y, t);\n        \n        q.y -= svDim.y;\n        q.xy = rot2(0.)*(q.xy - vec2(bDim.x, -svDim.y)) - vec2(-bDim.x, svDim.y);\n        \n        \n         \n        // Gold cube jump and flip.\n        q2 = p;\n        q2.y -= svDim.y*2. + bDim2.y;//mix(bDim.y/2., bDim.y, t)*2.; // Grow with the bottom object.\n        \n        \n        if(t2<.35) q2.y -= t2/.35*bDim.y*.7; // Ascend from the top of the object below.\n        else q2.y -= (bDim.y - bounceOut((t2 - .35)/.65)*bDim.y)*.7; // Decend back to the top.\n              \n       \n        q2.yz = rot2(-t2*PI/1.)*(q2.yz); // Front flip.\n  \n  \n    }    \n    else if(segID == 3){\n       \n\n        \n        // Lean down right.\n        q.y -= svDim.y;\n        q.xy = rot2(-t)*(q.xy - vec2(bDim.x, -bDim.y)) - vec2(-bDim.x, bDim.y);\n        \n        q2 = q;\n        q2.y -= bDim.y + bDim2.y;\n        // Pivot the gold cube anticlockwise from the top by 2 PI.\n        q2.xy = rot2(t*2.)*(q2.xy - vec2(-bDim2.x, -bDim2.y)) - vec2(bDim2.x, bDim2.y);\n \n        //\n    }\n    else if(segID == 4){\n        \n        \n        // Lean up left.\n        q.y -= bDim.y;\n        q.xy = rot2(-t)*(q.xy - vec2(bDim.x, -bDim.y)) - vec2(-bDim.x, bDim.y);\n        \n        // Gold cube: Slide from top to bottom.\n        q2 = q;\n        q2.x -= -bDim2.x*2.;\n        q2.y -= mix(bDim2.y, -bDim2.y, t2);\n        \n    }\n    else if(segID == 5){\n        \n        \n        q.y -= bDim.y;\n        q.xz = rot2(t)*(q.xz - vec2(bDim.x, bDim.z)) - vec2(-bDim.x, -bDim.z);\n        \n        \n        // Gold cube.\n        q2 = q;\n        q2.y -= -bDim2.y; // Move into position.\n        q2.x -= -bDim2.x*2.; // Move into position.\n        \n        q2.xz = rot2(-t)*(q2.xz - vec2(bDim.x, bDim.z)) - vec2(-bDim.x, -bDim.z);\n\n    }\n    else if(segID == 6){\n        \n        \n        //Lean down left (one cell up).\n        q.y -= bDim.y;\n        q.x -= bDim.x*2.;\n        q.z -= bDim.z*2.;\n        q.xy = rot2(-t)*(q.xy - vec2(-bDim.x, -bDim.y)) - vec2(bDim.x, bDim.y);\n        //q.z -= bDim.z;\n        \n        // Gold cube: Leave stationary.\n        q2 = p; // Detatch from the larger box coordinate system, and use the global one.\n        q2.y -= bDim2.y; // Move into position.\n        q2.x -= bDim2.x*2.;\n        \n    }\n    else if(segID == 7){\n       \n       \n        //From a down left position (one cell up), slide to the right.\n        q.y -= bDim.y;\n        //q.x -= bDim.x*2.;\n        q.x -= mix(bDim.x*2., bDim.x*4., t);\n        q.z -= bDim.z*2.;\n        q.xy = rot2(PI/2.)*(q.xy - vec2(-bDim.x, -bDim.y)) - vec2(bDim.x, bDim.y);\n        \n        // Gold cube.\n        q2 = q; \n        q2.y -= -bDim2.y*3.; \n        q2.z -= -bDim2.z*2.; \n        \n        // Whilst sliding, pivot the gold cube to the top of the larger object.\n        q2.yz = rot2(-t2*PI/2.)*(q2.yz - vec2(bDim.x, bDim.z)) - vec2(-bDim.x, -bDim.z);\n       \n    }\n    else if(segID == 8){\n       \n        \n        // Move the chrome cube into this frame's position.\n        q.y -= bDim.y;\n        q.x -= -bDim.x*2.;\n        q.z -= bDim.z*2.;\n        \n        // Pivot about XZ.\n   \t\tq.xz = rot2(t2*PI/1.)*(q.xz - vec2(bDim.x, -bDim.z)) - vec2(-bDim.x, bDim.z);           \n        // Pivot about XY.\n        q.xy = rot2(-t)*(q.xy - vec2(bDim.x, -bDim.y)) - vec2(-bDim.x, bDim.y);\n \n        \n        // Gold cube flip back down a level.\n        q2 = q; \n        \n        q2.xy = rot2(t2*PI)*(q2.xy - vec2(-bDim.x, bDim.y)) - vec2(bDim.x, -bDim.y);\n        q2.y -= bDim2.y*3.;\n        \n    }  \n    else if(segID == 9){\n       \n         \n        //Rotate and slide back to the original position.\n        q.y -= bDim.y;\n       \n        // Rotate about XZ with no pivoting.\n        q.xz = rot2(t*PI/2.)*(q.xz);           \n         \n        \n        // Pivot the gold cube about XZ whilst sliding back down to the ground.\n        q2 = q;\n        q2.x -= bDim.x*2.;\n        q2.y -= mix(bDim2.y, -bDim2.y, t2);\n      \n        q2.xz = rot2(t*PI)*(q2.xz - vec2(-bDim.x, bDim.z)) - vec2(bDim.x, -bDim.z);\n          \n    }\n    else {\n        \n        // Pause briefly before continuing the looping process again.\n        q.y -= bDim.y;\n        \n        q2 = q;\n        q2.y -= -bDim2.y;\n        q2.x -= -bDim.x*2.;\n        \n    }\n    \n \n    \n    // The rendering portion is the easy bit; Just some standard distance\n    // field operations with IQ's box formula.\n    \n    \n    // The chrome box.\n    float obj = sBox(q, svDim, .04);\n    \n    // The colored cube.\n    float obj2 = sBox(q2, bDim2, .04); \n    \n    // Chrome box grooves.\n    //obj = max(obj, -sBox(q, svDim*vec3(.25, .667, 1.2), .04));   \n    //obj = max(obj, -sBox(q, svDim*vec3(.25, 1.2, .25), .04)); \n    //obj = max(obj, -sBox(q, svDim*vec3(1.2, .667, .25), .04)); \n    obj = max(obj, -sBox(q.xy, svDim.xy*vec2(.25, .667), .04));   \n    obj = max(obj, -sBox(q.xz, svDim.xz*vec2(.25, .25), .04)); \n    obj = max(obj, -sBox(q.yz, svDim.yz*vec2(.667, .25), .04)); \n    \n    // Colored box nodules.\n    obj = min(obj, sBox(q2, bDim2*vec3(.25, .25, 1.2), .04));   \n    obj = min(obj, sBox(q2, bDim2*vec3(.25, 1.2, .25), .04)); \n    obj = min(obj, sBox(q2, bDim2*vec3(1.2, .25, .25), .04));\n    \n    // Center of the chrome box.\n    obj = min(obj, sBox(q, svDim*vec3(.833), .04)); \n\n \n\n    // Store the floor, chrome box and gold cube positions for sorting\n    // and surface identification outside the loop.\n    vObjID = vec4(fl, obj, obj2, 0);\n    \n    \n    // Return the minimum object.\n    return min(min(fl, obj), obj2);\n}\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 0., d;\n    \n    for (int i = min(0, iFrame); i<80; i++){\n\n        d = map(ro + rd*t);\n        \n        // Using the hacky \"abs,\" trick, for more accuracy. \n        if(abs(d)<.001 || t>FAR) break;        \n        \n        t += d;  // Using more accuracy, in the first pass.\n    }\n    \n    return t;\n}\n\n// Second pass, which is the first, and only, reflected bounce. \n// Virtually the same as above, but with fewer iterations and less \n// accuracy.\n//\n// The reason for a second, virtually identical equation is that \n// raymarching is usually a pretty expensive exercise, so since the \n// reflected ray doesn't require as much detail, you can relax things \n// a bit - in the hope of speeding things up a little.\nfloat traceRef(vec3 ro, vec3 rd){\n    \n    float t = 0., d;\n    \n    for (int i = min(0, iFrame); i<48; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.002 || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return t;\n}\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing repeat objects - in a setting like this - with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    vec3 rd = lp - ro; // Unnormalized direction ray.\n\n    float shade = 1.;\n    float dist = .002;    \n    float end = max(length(rd), .001);\n    float stepDist = end/float(maxIterationsShad);\n    \n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = min(0, iFrame); i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, .2), \n        // clamp(h, .02, stepDist*2.), etc.\n        dist += clamp(h, .01, .25);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0. || dist>end) break; \n        //if (h<.001 || dist > end) break; // If you're prepared to put up with more artifacts.\n    }\n\n    // I've added 0.5 to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me.\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n){\n\n\tfloat sca = 1.5, occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.25/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(.001, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n// The floor, chrome cube, and colored cube materials. These ones are pretty\n// basic, but you could put more effort in.\n//\nvec3 getObjectColor(vec3 p, vec3 r, vec3 n){\n    \n    \n    vec3 col;\n        \n    if(objID == 0) {\n       \n        // The floor.\n        vec3 tx = texture(iChannel0, p.xz/4.).xyz; tx *= tx;\n        col = tx*vec3(1, .7, .5)*.5;\n        \n    }\n    else if(objID == 1) {\n        \n        // The chrome colored box. It's something I tend to get, but tinging\n        // things blue can help bring about a metallic color... kind of. :)\n        col = vec3(.65, .85, 1);\n    }\n    else {\n        \n        // The cube. \n        col = vec3(2, .9, .45); // Redish gold.\n        //col = vec3(.7, 1.2, .3); // Green.\n        //col = vec3(2, .35, .85); // Pink.\n        //col = vec3(.3, 1, 2.5); // Blue.\n        //col = vec3(.3); // Grey\n    }\n    \n\n    // Adding some fake cube mapping information. The science is terrible, but it \n    // adds a bit of shine. :)\n    vec3 cTx = tex3D(iChannel0, reflect(r, n)/1.5, n);\n    cTx *= vec3(1, .8, .6);\n    \n    // Add a dose of fake reflection to the box and cube, and just a bit to the floor.\n    if(objID>0) col *= cTx*2.;\n    else col += cTx*.1;\n    \n    return col;\n\n}\n\n// Using the hit point, unit direction ray, etc, to color the \n// scene. Diffuse, specular, falloff, etc. It's all pretty \n// standard stuff.\nvec3 doColor(in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, float t){\n    \n    \n    // Initiate the scene color to zero.\n    vec3 sceneCol = vec3(0);\n    \n    if(t<FAR){\n        \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), .0001); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n        \n        float ao = calcAO(sp, sn);\n\n        // Attenuating the light, based on distance.\n        float atten = 1./(1. + lDist*.2 + lDist*lDist*.05);\n\n        // Standard diffuse term.\n        float diff = max(dot(sn, ld), 0.);\n        // Standard specualr term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.), 8.);\n        \n        // Ramp up the diffuse value. Sometimes, it can help things look metallic.\n        diff = pow(diff, 4.)*2.;\n\n        // Coloring the object. You could set it to a single color, to\n        // make things simpler, if you wanted.\n        vec3 objCol = getObjectColor(sp, rd, sn);\n        \n\n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol*((diff + ao*.2) + vec3(1, .97, .92)*spec*4.);\n        \n        // Apply the attenuation and ambient occlusion.\n        sceneCol *= atten*ao;\n        \n    }\n    \n    \n    // Fog factor -- based on the distance from the camera.\n    float fogF = smoothstep(0., .9, t/FAR);\n    //\n    // Applying the background fog. Just black, in this case, but you could\n    // render sky, etc, as well.\n    sceneCol = mix(sceneCol, vec3(0), fogF); \n\n    \n    // Return the color. Performed once every pass... of which there are\n    // only two, in this particular instance.\n    return sceneCol;\n    \n}\n\n\nvec3 getRd(vec2 u, vec3 ro){\n   \n    // Camera Setup.     \n    vec3 lk = vec3(0, .5, 0);  // \"Look At\" position.\n\n \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 3.14159265/3.; // FOV - Field of view.\n    vec3 fw = normalize(lk - ro);\n    vec3 rt = normalize(vec3(fw.z, 0, -fw.x )); \n    vec3 up = cross(fw, rt);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(fw + (u.x*rt + u.y*up)*FOV);\n    // Warping the ray to give that curved lens effect.\n    //rd = normalize(vec3(rd.xy, rd.z*(1. - length(rd.xy)*.25)));\n    \n    return rd;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\n    // Aspect correct screen coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    \n    // Slight barrel distortion.\n    float r = dot(uv, uv);\n    uv *= 1. + .2*(r*r + r);\n    \n    float cTm = iTime/2.;\n    vec3 ro = vec3(sin(cTm)*2.65, cos(tm)*sin(cTm)*.25 + 2.25, cos(cTm)*2.65);//vec3(0, 0, 0);\n    //vec3 ro = vec3(sin(cTm)*.75, cos(tm)*sin(cTm)*.25 + 2.25, -2.65);//vec3(0, 0, 0);\n \n    \n    vec3 rd = getRd(uv, ro);\n    \n    // Ray origin. Doubling as the surface position, in this particular example.\n    // I hope that doesn't confuse anyone.\n\n    vec3 lp = vec3(1, 3, -1); // Light position. Set in the vicinity the ray origin.\n\n \n    // Movement calculations -- Outside the loop, in an attempt to save on compiler time.\n    doTweenTime();\n    \n    \n    \n    // FIRST PASS.\n    \n    // Raymarch.\n    float t = trace(ro, rd);\n \n    // Obtain the current object ID.\n    objID = vObjID.x < vObjID.y && vObjID.x < vObjID.z? 0 : vObjID.y < vObjID.z? 1 : 2;\n    \n    // Advancing the ray origin, \"ro,\" to the new hit point.\n    ro += rd*t;\n    \n    // Retrieving the normal at the hit point.\n    vec3 sn = getNormal(ro);\n    \n    // Retrieving the color at the hit point, which is now \"ro.\" I agree, reusing \n    // the ray origin to describe the surface hit point is kind of confusing. The reason \n    // we do it is because the reflective ray will begin from the hit point in the \n    // direction of the reflected ray. Thus the new ray origin will be the hit point. \n    // See \"traceRef\" below.\n    vec3 sceneColor = doColor(ro, rd, sn, lp, t);\n    \n    // Checking to see if the surface is in shadow. Ideally, you'd also check to\n    // see if the reflected surface is in shadow. However, shadows are expensive, so\n    // it's only performed on the first pass. If you pause and check the reflections,\n    // you'll see that they're not shadowed. OMG! Better call the shadow police. :)\n    float sh = softShadow(ro +  sn*.0015, lp, 12.);\n    sh = min(sh + .3, 1.);\n    \n    \n    // SECOND PASS - REFLECTED RAY\n    \n    // Standard reflected ray, which is just a reflection of the unit\n    // direction ray off of the intersected surface. You use the normal\n    // at the surface point to do that. Hopefully, it's common sense.\n    rd = reflect(rd, sn);\n    \n    \n    // The reflected pass begins where the first ray ended, which is the suface\n    // hit point, or in a few cases, beyond the far plane. By the way, for the sake\n    // of simplicity, we'll perform a reflective pass for non hit points too. Kind\n    // of wasteful, but not really noticeable. The direction of the new ray will\n    // obviously be in the direction of the reflected ray. See just above.\n    //\n    // To anyone who's new to this, don't forgot to nudge the ray off of the \n    // initial surface point. Otherwise, you'll intersect with the surface\n    // you've just hit. After years of doing this, I still forget on occasion.\n    t = traceRef(ro +  sn*.003, rd);\n    \n\n    // Obtain the current object ID.\n    objID = vObjID.x < vObjID.y && vObjID.x < vObjID.z? 0 : vObjID.y < vObjID.z? 1 : 2;\n    \n    // Advancing the ray origin, \"ro,\" to the new reflected hit point.\n    ro += rd*t;\n    \n    // Retrieving the normal at the reflected hit point.\n    sn = getNormal(ro);\n    \n    // Coloring the reflected hit point, then adding a portion of it to the final scene color.\n    // How much you add, and how you apply it is up to you, but I'm simply adding 35 percent.\n    //sceneColor += doColor(ro, rd, sn, lp, t)*.5;\n    // Other combinations... depending what you're trying to achieve.\n    vec3 rCol = doColor(ro, rd, sn, lp, t);\n    sceneColor = sceneColor + rCol*.75;\n    \n    \n    // APPLYING SHADOWS\n    //\n    // Multiply the shadow from the first pass by the final scene color. Ideally, you'd check to\n    // see if the reflected point was in shadow, and incorporate that too, but we're cheating to\n    // save cycles and skipping it. It's not really noticeable anyway. By the way, ambient\n    // occlusion would make it a little nicer, but we're saving cycles and keeping things simple.\n    sceneColor *= sh;\n    \n    \n    // Extra coloring.\n    //sceneColor *= vec3(1.1, 1, .9);\n\n    // Clamping the scene color, performing some rough gamma correction (the \"sqrt\" bit), then \n    // presenting it to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0., 1.)), 1);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// Easing functions are their own topic, but a lot of it is straight forward.\n// Usage is easy. Normalize the time between zero and one, then choose the \n// one you're after.\n\nconst float PI = 3.14159265358979;\n\n// Robert Penner's easing functions in GLSL.\n// Available as a module for glslify. http://stack.gl/glsl-easings/\n\nfloat easeInOutCubic(float t){\n\n    return t<0.5 ? 4.*t*t*t : (t - 1.)*(2.*t - 2.)*(2.*t - 2.) + 1.;\n}\n\nfloat easeInOutQuint(float t){\n\n    return t<.5 ? 16.*t*t*t*t*t : 1. +16.*(--t)*t*t*t*t;\n}\n\nfloat easeOutQuad(float t) {\n    return -1. * t * (t - 2.);\n}\n\nfloat easeInQuad(float t) {\n    return t * t;\n}\n\n \nfloat bounceOut(float t) {\n    \n  const float a = 4.0 / 11.0;\n  const float b = 8.0 / 11.0;\n  const float c = 9.0 / 10.0;\n\n  const float ca = 4356.0 / 361.0;\n  const float cb = 35442.0 / 1805.0;\n  const float cc = 16061.0 / 1805.0;\n\n  float t2 = t * t;\n\n  return t < a\n    ? 7.5625 * t2\n    : t < b\n      ? 9.075 * t2 - 9.9 * t + 3.4\n      : t < c\n        ? ca * t2 - cb * t + cc\n        : 10.8 * t * t - 20.52 * t + 10.72;\n}\n\nfloat bounceInOut(float t) {\n  return t < 0.5\n    ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\n    : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\n\nfloat bounceIn(float t) {\n  return 1.0 - bounceOut(1.0 - t);\n}\n\n\nfloat elasticOut(float t) {\n  return sin(-13.0 * (t + 1.0) * PI/2.) * pow(2.0, -10.0 * t) + 1.0;\n}\n\nfloat circularInOut(float t) {\n  return t < 0.5\n    ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n    : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\nfloat exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nfloat exponentialIn(float t) {\n  return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\n\nfloat exponentialInOut(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\n\n// IQ's unsigned box formula.\nfloat sBox(in vec3 p, in vec3 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n// IQ's unsigned rectangle formula.\nfloat sBox(in vec2 p, in vec2 b, in float sf){\n\n  return length(max(abs(p) - b + sf, 0.)) - sf;\n}\n\n/*\n// IQ's signed box formula.\nfloat sBoxS(in vec3 p, in vec3 b, in float sf){\n\n  vec3 d = abs(p) - b + sf;\n  return min(max(max(d.x, d.y), d.z), 0.) + length(max(d, 0.)) - sf;\n}\n*/\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3tyXzy",
    "date": "0",
    "viewed": 0,
    "name": "Nexus()",
    "description": "stars",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "music",
     "space",
     "stars",
     "nebula"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4sXGzn",
       "filepath": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3",
       "type": "music",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "XdX3Rr",
       "filepath": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin",
       "type": "volume",
       "channel": 2,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sf3Rr",
       "filepath": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
       "type": "texture",
       "channel": 3,
       "sampler": {
        "filter": "linear",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Nexus XIII (Iteration 2)\" by quizcanners. https://shadertoy.com/view/WtyXzG\n// 2020-02-29 05:55:48\n\n\nvoid layer (out vec4 col, in vec3 uv, in float zoom, in float music)\n{\n    \n    uv.xy *= mix(1.1, 0.01, zoom);\n    \n    float deCenter = length(uv);\n    \n    deCenter = min(1., deCenter * deCenter);\n\n    vec2 smokeDin = vec2(-iTime + sin(uv.z*23.)*12.34, iTime + cos(uv.z*11.))*0.02;\n    \n    vec2 smokeUV = uv.xy;\n \n    float texC = texture(iChannel3, smokeUV*13. * sin(music*0.1 + uv.x) + smokeDin.yx*4.5).r\n        \t\t*texture(iChannel3, smokeUV*15.*zoom*uv.y - smokeDin.yx*3.2).r*0.015;//* deCenter ;\n      \n    \n    float texA = (1.- texture(iChannel3, smokeUV*0.6 - texC * 0.5 + smokeDin*0.2).r) ;\n    \n    texA*=texA;\n    \n    float texB = 1.-texture(iChannel3, smokeUV *  (1.-texA*0.1 + texC * 0.4 * (.5-texA)) + smokeDin*0.1).r;// * deCenter;\n        \n   \n    texA *= (0.5 + texB)*0.25;\n\n    texA *= texA * 8.* zoom * zoom * (1.-col.a) * deCenter;\n    \n    \n    vec2 grid = uv.xy*10.;\n    \n     uv.xy = mod(grid,1.0);\n\n     grid -= uv.xy;\n    \n    uv.xy-=0.5;\n     \n    \n    vec4 add = vec4(0,0,0, texA);\n    \n    float depthMod = uv.z*0.123;\n    \n    float iTimeAndZoom = iTime + zoom;\n    \n    float cutMod = col.a * (64.) * music;\n    \n    float distMod =  (0.1 + texA*10.  + cutMod) * max(0.1,  zoom - col.a*4.) ;\n        \n    for(int x=-1;x<=1;x++){\n    \tfor(int y=-1;y<=1;y++){\n        \n            vec2 dUv = uv.xy - vec2(x,y);\n            vec2 dGrid = grid + vec2(x,y);\n\n            vec3 vol = texture(iChannel2, vec3(dGrid.xy*0.1+depthMod, (dGrid.x + iTimeAndZoom)*0.001 )).rgb ;\n\n            float big = vol.b*vol.b;\n            \n            dUv += (vol.xy - .5)*1.5;\n            \n\n            float len = length(dUv);\n            \n            float dist = big * distMod/len; \n\n            float cut = smoothstep(1.-col.a*0.5,.5,len);\n            \n            float ray = max(0., 1.-abs(dUv.x*dUv.y*300.))* cut * music * big;\n            \n\n            dist += ray * ray * 0.2;\n            \n            add.rgb +=  dist * cut * vol;\n    \t}\n     }\n\n    \n    \n   col += add * zoom * (1.-zoom);\n    \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n     vec3 noise =  texture(iChannel2, vec3(uv*123.123+iTime, iTime+uv.x*uv.y*543.21)).rgb;\n    \n    vec4 col = vec4(0,0,0,0);\n    \n     uv -= 0.5;\n    \n    vec2 M = vec2(sin(iTime*.1)*3.,cos(iTime*.143)*2.);\n    \n    uv += M;\n    \n\n    float aspect = iResolution.x/iResolution.y; \n    \n    uv.x*=aspect;\n        \n    \n    const float stepCnt = 5.;\n    const int steCntInt = 5;\n    const float oneStep = 1./stepCnt;\n    \n    float zoom = iTime*0.1;\n    \n    \n    \n    float index = floor(mod(zoom, 1.)*stepCnt);\n    \n    zoom = mod(zoom, oneStep);\n    \n    float off = 0.;\n    \n    float music = 0.;  \n    \n    for(int i=0;i<steCntInt;i++){\n        \n        float totalZoom = zoom + off;\n        \n        music = texture(iChannel0, vec2(mix(0.01, 0.8, totalZoom),0.25)).x;\n        \n        // music *= music * 2.;\n        \n        music = smoothstep(0.,.2,music);\n        \n    \tlayer(col, vec3(uv.xy,index), totalZoom, music);\n    \toff += oneStep;\n        index = mod(index-1., stepCnt);\n    \t\n    }    \n    \n   col.rgb*=vec3(0.5,0.9,1) * 5. * oneStep;\n    \n    col.rgb += noise*col.rgb*0.15;\n\n    fragColor = vec4(col.rgb,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wlXXD2",
    "date": "0",
    "viewed": 0,
    "name": "On cube walk animation",
    "description": " only could catch my bouncy head",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "3d",
     "animation",
     "walkcycle",
     "footsteps"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsfGzn",
       "filepath": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg",
       "type": "cubemap",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Procedural walk animation\" by TLC123. https://shadertoy.com/view/WlsSWS\n// 2019-07-28 14:16:07\n\n//------------------------------------------------------------------------------\n// ++ Physically-based SDF  https://www.shadertoy.com/view/XlKSDR  romainguy\n//------------------------------------------------------------------------------\n\n\n#define AA 1\n \nstruct matr{\nvec3 rgb;\n  float rough;\n  float metal;\n  vec3 bump;\n};\n\n    /*\nBlue Metal\t0.1, 0.1, 1.0\t1.0\t0.1\nWhite Half- Metal\t0.9, 0.9, 0.9\t0.5\t0.25\nWhite Porcealain\t0.9, 0.9, 0.9\t0.0\t0.15\nBlue Rubber\t0.1, 0.1, 1.0\t0.0\t0.7*/\nmatr[] material=\n    matr[](\n        matr(vec3(0.01,.01,.01)   ,.56  ,.2,vec3(.0))\n       ,matr(vec3(.9)         ,.5  ,0.2,vec3(.0))\n       ,matr(vec3(1.000, 0.766, 0.336),0.5,.5,vec3(.0))\n       ,matr(vec3(1.0,.01,.10),.04,0.5,vec3(.0))\n    );\n\nvec3 begin;\nvec3 snap;\nvec4 systemQ;\nvec4 systemQinv;\nvec4 modelQ;\nvec4 modelQinv;\nvec4 driveQ;\nvec4 driveQinv;\nvec4 abdomenQ;\nvec4 abdomenQinv;\nvec3 up;\nvec3 fwd;\nvec3 left;\n //------------------------------------------------------------------\n// global form\n//------------------------------------------------------------------\n\n\nfloat pathterrain(float x,float z){\n    // Common height function for path and terrain\n    return abs(\n        sin(x*.5 )*1.+cos(z*.3 )*0.3\n        +cos(x*3.+z )*0.1+sin(x-z*.2 )*0.2\n        )*0.5\n        ;}\n vec3 timefly(float t) { \n\tvec3 v =vec3(0); \n    return v        ;\n} \n\nfloat pasa=1.;\nfloat pasaR(float x){\nreturn max(x + fract(x + 0.25) * pasa - pasa, floor(x + 0.25) - 0.25) + 0.25;\n    //gait function \n}\n    \nfloat pasaL(float x){\nreturn max(x + fract(x - 0.25) * pasa - pasa, floor(x - 0.25) + 0.25) + 0.25;\n   //gait function \n}\n\n\n\nfloat lpnorm(vec3 p, float s) {\n\treturn pow(\n\t\t(\n\t\t\tpow(abs(p.x), s) +\n\t\t\tpow(abs(p.y), s) +\n\t\t\tpow(abs(p.z), s)),\n\t\t1.0 / s);\n}\n\n\n \n//------------------------------------------------------------------\nvec2 opU(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp(.5 + .5*(a-b)/k, 0., 1.);\n\treturn mix(a, b, h) - k*h*(1.-h);\n}\n\n \nvec2 opUsmin(vec2 d1, vec2 d2,float k) {\n    float d=smin(d1.x,d2.x,k);\n\treturn (d1.x < d2.x) ? vec2(d,d1.y) : vec2(d,d2.y);\n}\n\n//------------------------------------------------------------------------------\n// Scene\n//------------------------------------------------------------------------------\nvec3 rotxyz(mat3 m, vec3 p){\n    \nreturn vec3(p.x*m[0]+p.y*m[1]+p.z*m[2]);\n}\n\n vec2 model( in vec3 pos) {\n \n         \n \n   // vec3 p= Rotate(modelQ, pos );\n   vec2 res   ;\n    \n    res = vec2(       \tsdTorus( pos  ,vec2(.6,.3)   )        ,3.);\n     //\n      res = opUsmin(res, \t\t\t  vec2( sdCappedCylinder(pos-vec3(0.5,0.2,0),.3, .8),3.)                  ,0.45 ) ;  \n     // pos=Rotate(systemQ, pos);\n\n    //   res =opU(res, \t\t\t  vec2( sdPlane(pos)-pathterrain(pos.x,pos.z) ,1. )                );\n  //res=vec2(sdSphere(pos,1.),1.);\n        \n     return res;\n}\nvec3 snapNormal(in vec3 position) {\n    vec3 epsilon = vec3(0.0001, 0.0, 0.0);\n    vec3 n = vec3(\n          model(position + epsilon.xyy).x - model(position - epsilon.xyy).x,\n          model(position + epsilon.yxy).x - model(position - epsilon.yxy).x,\n          model(position + epsilon.yyx).x - model(position - epsilon.yyx).x);\n    return normalize(n);\n}\nvec3 snapToSurface(vec3 p,float r)\n{\n   float d=model(p).x-r;\n   vec3 n=snapNormal(p);\n   \n     p-=d*n;\n    \n    return p;\n}\n\nvec2 scene( in vec3 pos) {\n  \n    // vec3 p=Rotate(systemQ, pos);\nvec2 res=vec2(sdSphere(pos ,0.05),2.);\n     res =model(pos);\n    \n \n      //pos=Rotate(modelQ, pos);\n    \n\n    \n      pos= rotxyz(inverse(mat3(     left,    up ,fwd)), pos-snap);\n\n    res = opU(res, \n\t\t\t  vec2( sdCappedCylinder(pos,.15, .025),2.)\n                   );    \n    res = opU(res, \n\t\t\t  vec2( sdCapsule(pos,vec3(0), vec3(0,.25,0), .025 ),2.)\n                   );  \n    res = opU(res, \n\t\t\t  vec2( sdCapsule(pos,vec3(-.2,0,0), vec3(.2,0,0), .025 ),1.)\n                   );    \n    res = opU(res, \n\t\t\t  vec2( sdCapsule(pos,vec3(0), vec3(0,0,.25), .025 ),1.)\n                   );    \n      \n    \n    return res;\n}\n//------------------------------------------------------------------------------\n// Materials\n//------------------------------------------------------------------------------\n\nfloat checkersGradBox( in vec2 p) {\n\t// filter kernel\n\tvec2 w = fwidth(p) + 0.001;\n\t// analytical integral (box filter)\n\tvec2 i = 2.0 * (abs(fract((p - 0.5 * w) * 0.5) - 0.5) - abs(fract((p + 0.5 * w) * 0.5) - 0.5)) / w;\n\t// xor pattern\n\treturn 0.5 - 0.5 * i.x * i.y;\n}\n\n\nvec3 normal(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          scene(position + epsilon.xyy).x - scene(position - epsilon.xyy).x,\n          scene(position + epsilon.yxy).x - scene(position - epsilon.yxy).x,\n          scene(position + epsilon.yyx).x - scene(position - epsilon.yyx).x);\n    return normalize(n);\n}\n\nmatr getMaterial(vec3 pos, float m){\n    \n    \n    \nfloat i= float(material.length());       \nint mint=int(round( clamp(m,0.,i)));\n      matr ret;\n            \n     \t\tret = material[mint];\n            ret.bump= normal(pos);\n    \n\t\tif (mint == 1) {\n\t\t\tfloat f = checkersGradBox(1.2 * pos.xz);\n\t\t\tret.rgb = 0.3 + f * material[mint].rgb;\n\t\t}\n \n    return ret;\n}\n\n//------------------------------------------------------------------------------\n//https://www.shadertoy.com/view/XlKSDR\n//------------------------------------------------------------------------------\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        float h = scene(origin + direction * t).x;\n        if (h < 0.001) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nvec2 traceRay(in vec3 origin, in vec3 direction) {\n    float material = -1.0;\n\n    float t = 0.02;\n    \n    for (int i = 0; i < 100; i++) {\n        vec2 hit = scene(origin + direction * t);\n        if (hit.x < 0.002 || t > 20.0) break;\n        t += hit.x;\n        material = hit.y;\n    }\n\n    if (t > 15.0) {\n        material = -1.0;\n    }\n\n    return vec2(t, material);\n}\n\n\n\n \n\nfloat calcAO( in vec3 pos, in vec3 nor) {\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor (int i = 0; i < 9; i++) {\n\t\tfloat hr = 0.01 + 0.12 * float(i) / 4.0;\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = scene(aopos).x;\n\t\tocc += -(dd - hr) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp(1.0 - 2.0 * occ, 0.0, 1.0);\n}\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\n\n\n\n\n\n\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / PI;\n}\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n// ACES fitted\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\n\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\n// ODT_SAT => XYZ => D60_2_D65 => sRGB\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit(vec3 v)\n{\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted(vec3 color)\n{\n    color = color * ACESInputMat;\n\n    // Apply RRT and ODT\n    color = RRTAndODTFit(color);\n\n    color = color * ACESOutputMat;\n\n    // Clamp to [0, 1]\n    color = clamp(color, 0.0, 1.0);\n\n    return color;\n}\n\n\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n//------------------------------------------------------------------------------\n// Rendering\n//------------------------------------------------------------------------------\n\n\nvec3 render(in vec3 origin, in vec3 direction, out float distance) {\n    // Sky gradient\n    //vec3 color = vec3(0.65, 0.85, 1.0) + direction.y * 0.72;\n    vec3 color = texture( iChannel0, direction ).xyz;\n\n    // (distance, material)\n    vec2 hit = traceRay(origin, direction);\n    distance = hit.x;\n    float material = hit.y;\n\n    // We've hit something in the scene\n\n    if (material > 0.0) {\n        vec3 position = origin + distance * direction;\n\n        vec3 v = normalize(-direction);\n        \n      \n     \n        matr M=getMaterial(position,material);\n        vec3 baseColor = M.rgb;\n        float roughness = M.rough;\n        float metallic = M.metal;\n        \n        vec3 n=M.bump;\n        \n         vec3 l = normalize(vec3(0.6, 0.7, -0.7));\n        vec3 h = normalize(v + l);\n        vec3 r = normalize(reflect(direction, n));\n\n        float NoV = abs(dot(n, v)) + 1e-5;\n        float NoL = clamp(dot(n, l),0.,1.);\n        float NoH = clamp(dot(n, h),0.,1.);\n        float LoH = clamp(dot(l, h),0.,1.);\n\n        \n        //float occ =calcAO(position,n);\n        \n        float intensity = 3.0;\n        float indirectIntensity = 0.64 ;\n\n     \n\n        float linearRoughness = roughness * roughness;\n        vec3 diffuseColor = (1.0 - metallic) * baseColor.rgb;\n        vec3 f0 = 0.04 * (1.0 - metallic) + baseColor.rgb * metallic;\n\n        float attenuation = shadow(position, l);\n\n        // specular BRDF\n        float D = D_GGX(linearRoughness, NoH, h);\n        float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n        vec3  F = F_Schlick(f0, LoH);\n        vec3 Fr = (D * V) * F;\n\n        // diffuse BRDF\n        vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n\n        color = Fd + Fr;\n        color *= (intensity * attenuation * NoL) * vec3(0.98, 0.92, 0.89);\n\n        // diffuse indirect\n        vec3 indirectDiffuse = Irradiance_SphericalHarmonics(n) * Fd_Lambert();\n\n        vec2 indirectHit = traceRay(position, r);\n\n        vec3 indirectSpecular =      texture( iChannel0, r.xyz ).xyz + r.y * 0.72;\n        if (indirectHit.y > 0.0) {\n                 vec3 indirectPosition = position + indirectHit.x * r;\n                M=getMaterial(indirectPosition,indirectHit.y );\n                indirectSpecular =M.rgb  ;\n         \n        }\n\n        // indirect contribution\n        vec2 dfg = PrefilteredDFG_Karis(roughness, NoV);\n        vec3 specularColor = f0 * dfg.x + dfg.y;\n        vec3 ibl = diffuseColor * indirectDiffuse + indirectSpecular * specularColor;\n\n        color += ibl * indirectIntensity;\n    }\n\n    return color;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n// Setup\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\nvec3 drive(float t){\n    t*=0.4;\n           driveQ =  BuildQuat(normalize(vec3(1,0,0)),t);  \n    \t    driveQ = MulQuat(  BuildQuat(normalize(vec3(0,1,0)),t*.1),driveQ);  \n    \t    driveQ = MulQuat( BuildQuat(normalize(vec3(1.,1,0)),t*.13),driveQ);  \n           driveQinv =  quatInv(driveQ);  \n           return  ( vec3(0,1 ,0.01)) ;\n}\n\n\nvoid setup() {\n           systemQ =  BuildQuat(normalize(vec3(1,0,0)),0.*.1);    \n           systemQinv =  quatInv(systemQ);  \n           modelQ =BuildQuat(normalize(vec3(0,1,0)),0.*.5);          \n           modelQinv=  quatInv(modelQ);     \n    \t\n\tbegin=  drive(iTime) ;\n\tvec3 beginf=  drive(iTime-0.1) ;\n  \n    \n             fwd=normalize(vec3(0,0,1));\n             up=normalize(snapNormal(snap));   \n             left=cross(up,fwd);\n             fwd=cross(up,left);\n    ;  \n    }\n//------------------------------------------------------------------------------\n// Main and Final \n//------------------------------------------------------------------------------\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tsetup();\n \t vec2 mo = iMouse.xy / iResolution.xy;\n if(mo.x==mo.y)mo=vec2(.5);\n    mo *=3.14;\n     mo.y-2.14;\n \tfloat time = .0 + iTime;\n\tvec3 tot = vec3(0.0);\n #\tif AA > 1\n\tfor (int m = 0; m < AA; m++)\n\t\tfor (int n = 0; n < AA; n++) {\n\t\t\t// pixel coordinates\n\t\t\tvec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n\t\t\tvec2 p = (-iResolution.xy + 2.0 * (fragCoord + o)) / iResolution.y;\n # else\n\t\t\t\tvec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n # endif\n\t\t\t// camera\t\n\t\t\t//vec3 ta = timefly(time) + vec3(0, 0, 0);\n\t\t\tvec3 ta =   drive(iTime )  ;\n            \n              vec3 ro = vec3(0,cos(mo.y ),sin(mo.y ));\n\t\t\t vec4 horz=BuildQuat(vec3(0,1,0), -mo.x*2.+iTime*0.1 );\n             ro = ta+ Rotate(horz,ro)*3.  ;\n              //ro =   drive(iTime-.4)*4.  ;\n           //ro.y=max(pathterrain(ro.x,ro.z)+.2,ro.y);\n            // camera-to-world transformation\n\t\t\tmat3 ca = setCamera(ro, ta, 0.0);\n\t\t\t// ray direction\n\t\t\tvec3 rd = ca * normalize(vec3(p.xy, 2.5));\n\t\t\t// render\n            float distance;\n    vec3 col = render(ro, rd,distance);\n\t\t\t// gamma\n\t\t\tcol = pow(col, vec3(0.4545));\n\t\t\ttot += col;\n # if AA > 1\n\t\t}\n\ttot /= float(AA * AA);\n #\tendif\n\tfragColor = vec4(tot, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// Common megapack\n#define PI  3.14159265\n#define hPI 1.57079632\n#define TAU 6.283185\n\n\n\n#define PHI (sqrt(5)*0.5 + 0.5)\n\n//----------------------------------------------------------------------------------------\n// Quaternios\n//----------------------------------------------------------------------------------------\n vec4 NormQuat(vec4 q)\n{\n    float lenSQ = dot(q, q);\n    float invLenSQ = 1./lenSQ;\n    return q*invLenSQ;\n}\n\nvec4 BuildQuat(vec3 axis, float angle)\n{\n    angle *= 0.5;\n    float s = sin(angle);\n    return NormQuat(vec4(axis*s, cos(angle)));\n}\n\nvec4 MulQuat(vec4 q1, vec4 q2)\n{\n    vec4 res = vec4(0.);\n    res.w   = q1.w*q2.w - dot(q1.xyz, q2.xyz);\n    res.xyz = q1.w*q2.xyz + q2.w*q1.xyz + cross(q1.xyz, q2.xyz);\n    return NormQuat(res);\n}\n\n \n    \nvec3 Rotate(vec4 q, vec3 v)\n{\n    vec3 t = 2.*cross(q.xyz, v);\n    return v + q.w*t + cross(q.xyz, t);\n}\n\n\nfloat fromTo(vec3 p,vec3 q)\n{\nreturn acos(dot(p,q));\n\n}\nvec4 quatLookAt(vec3 forward,vec3 up){\n    forward=normalize(forward);\n    up=normalize(up);\nreturn  (BuildQuat(cross(forward,up),fromTo(forward,up)));\n}\n\n\nvec4 quatInv(in vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\n//https://en.wikipedia.org/wiki/Slerp#Quaternion_Slerp\n\nvec4 slerp(vec4 v0, vec4 v1, float t) {\n    // Only unit quaternions are valid rotations.\n    // Normalize to avoid undefined behavior.\n     NormQuat(v0);\n     NormQuat(v1);\n\n    // Compute the cosine of the angle between the two vectors.\n    float dotp = dot(v0, v1);\n\n    // If the dot product is negative, slerp won't take\n    // the shorter path. Note that v1 and -v1 are equivalent when\n    // the negation is applied to all four components. Fix by \n    // reversing one quaternion.\n    if (dotp < 0.0f) {\n        v1 = -v1;\n        dotp = -dotp;\n    }  \n\n      float DOT_THRESHOLD = 0.9995;\n    if (dotp > DOT_THRESHOLD) {\n        // If the inputs are too close for comfort, linearly interpolate\n        // and normalize the result.\n\n        vec4 result = v0 + t*(v1 - v0);\n        NormQuat(result);\n        return result;\n    }\n\n    // Since dot is in range [0, DOT_THRESHOLD], acos is safe\n    float theta_0 = acos(dotp);        // theta_0 = angle between input vectors\n    float theta = theta_0*t;          // theta = angle between v0 and result\n    float sin_theta = sin(theta);     // compute this value only once\n    float sin_theta_0 = sin(theta_0); // compute this value only once\n\n    float s0 = cos(theta) - dotp * sin_theta / sin_theta_0;  // == sin(theta_0 - theta) / sin(theta_0)\n    float s1 = sin_theta / sin_theta_0;\n\n    return (s0 * v0) + (s1 * v1);\n}\n\n//----------------------------------------------------------------------------------------\n// Hash without Sine  https://www.shadertoy.com/view/4djSRW\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n//----------------------------------------------------------------------------------------\n//// Created by inigo quilez - iq/2014\n//----------------------------------------------------------------------------------------\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat noise13( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( \n        mix(\n                mix( hash13( i + vec3(0.0,0.0,0.0) ), \n                     hash13( i + vec3(1.0,0.0,0.0) ), u.x),\n                mix( hash13( i + vec3(0.0,1.0,0.0) ), \n                     hash13( i + vec3(1.0,1.0,0.0) ), u.x)\n               , u.y),\n              mix(\n                mix( hash13( i + vec3(0.0,0.0,1.0) ), \n                     hash13( i + vec3(1.0,0.0,1.0) ), u.x),\n                mix( hash13( i + vec3(0.0,1.0,1.0) ), \n                     hash13( i + vec3(1.0,1.0,1.0) ), u.x)\n               , u.y)\n        \n         , u.z)\n        ;\n}\n\nvec3 noise33(  vec3 p )\n{\n    p=p+10000.;\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u;\n    u.x = f.x*f.x*(3.0-2.0*f.x);\n    u.y = f.y*f.y*(3.0-2.0*f.y);\n    u.z = f.z*f.z*(3.0-2.0*f.z);\n\n    return mix( \n        mix(\n                mix( hash33( i + vec3(0.0,0.0,0.0) ), \n                     hash33( i + vec3(1.0,0.0,0.0) ), u.x),\n                mix( hash33( i + vec3(0.0,1.0,0.0) ), \n                     hash33( i + vec3(1.0,1.0,0.0) ), u.x)\n               , u.y),\n              mix(\n                mix( hash33( i + vec3(0.0,0.0,1.0) ), \n                     hash33( i + vec3(1.0,0.0,1.0) ), u.x),\n                mix( hash33( i + vec3(0.0,1.0,1.0) ), \n                     hash33( i + vec3(1.0,1.0,1.0) ), u.x)\n               , u.y)\n        \n         , u.z)\n        ;\n}\n\nfloat fbm( vec2 p )\n{\n      mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nvec3 fbm33( vec3 p )\n{\n   \n     mat3 m = mat3(vec3(0.80,  0.60, -0.6).xyz,\n                    vec3(0.80,  0.60, -0.6).yzx,\n                    vec3(0.80,  0.60, -0.6).zxy);\n    vec3 f = vec3(0.0);\n    f += 0.5000*noise33( p ); p = m*p*2.02;\n    f += 0.2500*noise33( p ); p = m*p*2.03;\n    f += 0.1250*noise33( p ); p = m*p*2.01;\n    f += 0.0625*noise33( p );\n    return f/0.9375;\n}\n\nfloat fbm13( vec3 p )\n{\n         float m =1.;\n\n\n    float f =  (0.0);\n    f += 0.5000*noise13( p ); p = m*p*2.02;\n    f += 0.2500*noise13( p ); p = m*p*2.03;\n    f += 0.1250*noise13( p ); p = m*p*2.01;\n    f += 0.0625*noise13( p );\n    return f/0.9375;\n}\n\nvec2 fbm2( in vec2 p )\n{\n    return vec2( fbm(p.xy), fbm(p.yx) );\n}\n\n\n\n//----------------------------------------------------------------------------------------\n//http://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n//----------------------------------------------------------------------------------------\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat dot2(vec2 a ) { return dot(a,a); }\n\n \nfloat sdCircle( vec2 p, float r )\n{\n  return length(p) - r;\n}\n\n \nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n \nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\n \nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p);\n    float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\n    float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\n}\n\n \nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n \nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n \nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\n \nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n \nfloat sdPentagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(0.809016994,0.587785252,0.726542528);\n    p.x = abs(p.x);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);    \n    return length(p)*sign(p.y);\n}\n\n \nfloat sdHexagon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n \nfloat sdOctogon( in vec2 p, in float r )\n{\n    const vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\n    p = abs(p);\n    p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\n    p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\n    p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n    return length(p)*sign(p.y);\n}\n\n \nfloat sdHexagram( in vec2 p, in float r )\n{\n    const vec4 k = vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\n    p = abs(p);\n    p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n    p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\n    p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\n    return length(p)*sign(p.y);\n}\n\n \nfloat sdStar(in vec2 p, in float r, in int n, in float m)\n{\n    // next 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 6.283185/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon,\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n \nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n \nfloat sdPie( in vec2 p, in vec2 c, in float r )\n{\n    p.x = abs(p.x);\n    float l = length(p) - r;\n    float m = length(p-c*clamp(dot(p,c),0.0,r)); // c = sin/cos of the aperture\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\n \nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n{\n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n \nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, \n              c.y, c.x)*p;\n    p = vec2((p.y>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\n \nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b))\n                             : length(p-vec2(-d,0.0))-r;\n}\n\n \nfloat sdCross( in vec2 p, in vec2 b, float r ) \n{\n    p = abs(p); p = (p.y>p.x) ? p.yx : p.xy;\n    vec2  q = p - b;\n    float k = max(q.y,q.x);\n    vec2  w = (k>0.0) ? q : vec2(b.y-p.x,-k);\n    return sign(k)*length(max(w,0.0)) + r;\n}\n\n \n \n \nfloat sdEllipse( in vec2 p, in vec2 ab )\n{\n    p = abs(p); if( p.x > p.y ) {p=p.yx;ab=ab.yx;}\n    float l = ab.y*ab.y - ab.x*ab.x;\n    float m = ab.x*p.x/l;      float m2 = m*m; \n    float n = ab.y*p.y/l;      float n2 = n*n; \n    float c = (m2+n2-1.0)/3.0; float c3 = c*c*c;\n    float q = c3 + m2*n2*2.0;\n    float d = c3 + m2*n2;\n    float g = m + m*n2;\n    float co;\n    if( d<0.0 )\n    {\n        float h = acos(q/c3)/3.0;\n        float s = cos(h);\n        float t = sin(h)*sqrt(3.0);\n        float rx = sqrt( -c*(s + t + 2.0) + m2 );\n        float ry = sqrt( -c*(s - t + 2.0) + m2 );\n        co = (ry+sign(l)*rx+abs(g)/(rx*ry)- m)/2.0;\n    }\n    else\n    {\n        float h = 2.0*m*n*sqrt( d );\n        float s = sign(q+h)*pow(abs(q+h), 1.0/3.0);\n        float u = sign(q-h)*pow(abs(q-h), 1.0/3.0);\n        float rx = -s - u - c*4.0 + 2.0*m2;\n        float ry = (s - u)*sqrt(3.0);\n        float rm = sqrt( rx*rx + ry*ry );\n        co = (ry/sqrt(rm-rx)+2.0*g/rm-m)/2.0;\n    }\n    vec2 r = ab * vec2(co, sqrt(1.0-co*co));\n    return length(r-p) * sign(p.y-r.y);\n}\n\n \nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n        vec2 qos = d + (c + b*t)*t;\n        res = dot(qos,qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n        vec2 qos = d + (c + b*t.x)*t.x;\n        res = dot(qos,qos);\n        qos = d + (c + b*t.y)*t.y;\n        res = min(res,dot(qos,qos));\n        qos = d + (c + b*t.z)*t.z;\n        res = min(res,dot(qos,qos));\n    }\n    return sqrt( res );\n}\n\n \nfloat sdRoundedShape( float d, in float r )\n{\n  return d - r;\n}\n \nfloat sdAnnularShape( float d, in float r )\n{\n  return abs(d) - r;\n}\n\n \n//----------------------------------------------------------------------------------------\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//----------------------------------------------------------------------------------------\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n \nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0))\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n \nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 d = abs(p) - b;\n  return length(max(d,0.0)) - r\n         + min(max(d.x,max(d.y,d.z)),0.0); // remove this line for an only partially signed sdf \n}\n\n \nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n \nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n \nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n \nfloat sdCone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\n \nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n \nfloat sdPlane( vec3 p  )\n{\n  // n must be normalized\n  return p.y;\n}\n \nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n \nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n \nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n \nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n    p.y -= clamp( p.y, 0.0, h );\n    return length( p ) - r;\n}\n\n \nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n \nfloat sdCappedCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n \nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n \nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n \nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\n \nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n \nfloat sdOctahedron( in vec3 p, in float s)\n{\n    p = abs(p);\n    float m = p.x+p.y+p.z-s;\n    vec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\n \n \n\n \nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n \n float udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n \nvec3 opElongate(  in vec3 p, in vec3 h )\n{\n    vec3 q = p - clamp( p, -h, h );\n    return   q ;\n}\n\n \n \n\n \n \n\n \nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n \n \n \nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\n \n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n \n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//                           HG_SDF\n//\n//     GLSL LIBRARY FOR BUILDING SIGNED DISTANCE BOUNDS\n//\n//     version 2016-01-10\n//\n//     Check http://mercury.sexy/hg_sdf for updates\n//     and usage examples. Send feedback to spheretracing@mercury.sexy.\n//\n//     Brought to you by MERCURY http://mercury.sexy\n//\n//\n//\n// Released as Creative Commons Attribution-NonCommercial (CC BY-NC)\n//\n////////////////////////////////////////////////////////////////\n//\n// How to use this:\n//\n// 1. Build some system to #include glsl files in each other.\n//   Include this one at the very start. Or just paste everywhere.\n// 2. Build a sphere tracer. See those papers:\n//   * \"Sphere Tracing\" http://graphics.cs.illinois.edu/sites/default/files/zeno.pdf\n//   * \"Enhanced Sphere Tracing\" http://lgdv.cs.fau.de/get/2234\n//   The Raymnarching Toolbox Thread on pouet can be helpful as well\n//   http://www.pouet.net/topic.php?which=7931&page=1\n//   and contains links to many more resources.\n// 3. Use the tools in this library to build your distance bound f().\n// 4. ???\n// 5. Win a compo.\n// \n// (6. Buy us a beer or a good vodka or something, if you like.)\n//\n////////////////////////////////////////////////////////////////\n//\n// Table of Contents:\n//\n// * Helper functions and macros\n// * Collection of some primitive objects\n// * Domain Manipulation operators\n// * Object combination operators\n//\n////////////////////////////////////////////////////////////////\n//\n// Why use this?\n//\n// The point of this lib is that everything is structured according\n// to patterns that we ended up using when building geometry.\n// It makes it more easy to write code that is reusable and that somebody\n// else can actually understand. Especially code on Shadertoy (which seems\n// to be what everybody else is looking at for \"inspiration\") tends to be\n// really ugly. So we were forced to do something about the situation and\n// release this lib ;)\n//\n// Everything in here can probably be done in some better way.\n// Please experiment. We'd love some feedback, especially if you\n// use it in a scene production.\n//\n// The main patterns for building geometry this way are:\n// * Stay Lipschitz continuous. That means: don't have any distance\n//   gradient larger than 1. Try to be as close to 1 as possible -\n//   Distances are euclidean distances, don't fudge around.\n//   Underestimating distances will happen. That's why calling\n//   it a \"distance bound\" is more correct. Don't ever multiply\n//   distances by some value to \"fix\" a Lipschitz continuity\n//   violation. The invariant is: each fSomething() function returns\n//   a correct distance bound.\n// * Use very few primitives and combine them as building blocks\n//   using combine opertors that preserve the invariant.\n// * Multiply objects by repeating the domain (space).\n//   If you are using a loop inside your distance function, you are\n//   probably doing it wrong (or you are building boring fractals).\n// * At right-angle intersections between objects, build a new local\n//   coordinate system from the two distances to combine them in\n//   interesting ways.\n// * As usual, there are always times when it is best to not follow\n//   specific patterns.\n//\n////////////////////////////////////////////////////////////////\n//\n// FAQ\n//\n// Q: Why is there no sphere tracing code in this lib?\n// A: Because our system is way too complex and always changing.\n//    This is the constant part. Also we'd like everyone to\n//    explore for themselves.\n//\n// Q: This does not work when I paste it into Shadertoy!!!!\n// A: Yes. It is GLSL, not GLSL ES. We like real OpenGL\n//    because it has way more features and is more likely\n//    to work compared to browser-based WebGL. We recommend\n//    you consider using OpenGL for your productions. Most\n//    of this can be ported easily though.\n//\n// Q: How do I material?\n// A: We recommend something like this:\n//    Write a material ID, the distance and the local coordinate\n//    p into some global variables whenever an object's distance is\n//    smaller than the stored distance. Then, at the end, evaluate\n//    the material to get color, roughness, etc., and do the shading.\n//\n// Q: I found an error. Or I made some function that would fit in\n//    in this lib. Or I have some suggestion.\n// A: Awesome! Drop us a mail at spheretracing@mercury.sexy.\n//\n// Q: Why is this not on github?\n// A: Because we were too lazy. If we get bugged about it enough,\n//    we'll do it.\n//\n// Q: Your license sucks for me.\n// A: Oh. What should we change it to?\n//\n// Q: I have trouble understanding what is going on with my distances.\n// A: Some visualization of the distance field helps. Try drawing a\n//    plane that you can sweep through your scene with some color\n//    representation of the distance field at each point and/or iso\n//    lines at regular intervals. Visualizing the length of the\n//    gradient (or better: how much it deviates from being equal to 1)\n//    is immensely helpful for understanding which parts of the\n//    distance field are broken.\n//\n////////////////////////////////////////////////////////////////\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             HELPER FUNCTIONS/MACROS\n//\n////////////////////////////////////////////////////////////////\n\n\n\n// Clamp to [0,1] - this operation is free under certain circumstances.\n// For further information see\n// http://www.humus.name/Articles/Persson_LowLevelThinking.pdf and\n// http://www.humus.name/Articles/Persson_LowlevelShaderOptimization.pdf\n#define saturate(x) clamp(x, 0, 1)\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\nfloat square (float x) {\n\treturn x*x;\n}\n\nvec2 square (vec2 x) {\n\treturn x*x;\n}\n\nvec3 square (vec3 x) {\n\treturn x*x;\n}\n\nfloat lengthSqr(vec3 x) {\n\treturn dot(x, x);\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\nfloat vmin(vec2 v) {\n\treturn min(v.x, v.y);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat vmin(vec4 v) {\n\treturn min(min(v.x, v.y), min(v.z, v.w));\n}\n\n\n\n\n////////////////////////////////////////////////////////////////\n//\n//             PRIMITIVE DISTANCE FUNCTIONS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that is a distance function is called fSomething.\n// The first argument is always a point in 2 or 3-space called <p>.\n// Unless otherwise noted, (if the object has an intrinsic \"up\"\n// side or direction) the y axis is \"up\" and the object is\n// centered at the origin.\n//\n////////////////////////////////////////////////////////////////\n\nfloat fSphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n\treturn dot(p, n) + distanceFromOrigin;\n}\n\n// Cheap Box: distance to corners is overestimated\nfloat fBoxCheap(vec3 p, vec3 b) { //cheap box\n\treturn vmax(abs(p) - b);\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n// Same as above, but in two dimensions (an endless box)\nfloat fBox2Cheap(vec2 p, vec2 b) {\n\treturn vmax(abs(p)-b);\n}\n\nfloat fBox2(vec2 p, vec2 b) {\n\tvec2 d = abs(p) - b;\n\treturn length(max(d, vec2(0))) + vmax(min(d, vec2(0)));\n}\n\n\n// Endless \"corner\"\nfloat fCorner (vec2 p) {\n\treturn length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\n \n\n// Cylinder standing upright on the xz plane\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\n\n// Capsule: A Cylinder with round caps on both sides\nfloat fCapsule(vec3 p, float r, float c) {\n\treturn mix(length(p.xz) - r, length(vec3(p.x, abs(p.y) - c, p.z)) - r, step(c, abs(p.y)));\n}\n\n// Distance to line segment between <a> and <b>, used for fCapsule() version 2below\nfloat fLineSegment(vec3 p, vec3 a, vec3 b) {\n\tvec3 ab = b - a;\n\tfloat t = clamp(dot(p - a, ab) / dot(ab, ab),0.,1.);\n\treturn length((ab*t + a) - p);\n}\n\n// Capsule version 2: between two end points <a> and <b> with radius r \nfloat fCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\treturn fLineSegment(p, a, b) - r;\n}\n\n// Torus in the XZ-plane\nfloat fTorus(vec3 p, float smallRadius, float largeRadius) {\n\treturn length(vec2(length(p.xz) - largeRadius, p.y)) - smallRadius;\n}\n\n// A circle line. Can also be used to make a torus by subtracting the smaller radius of the torus.\nfloat fCircle(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn length(vec2(p.y, l));\n}\n\n// A circular disc with no thickness (i.e. a cylinder with no height).\n// Subtract some value to make a flat disc with rounded edge.\nfloat fDisc(vec3 p, float r) {\n\tfloat l = length(p.xz) - r;\n\treturn l < 0. ? abs(p.y) : length(vec2(p.y, l));\n}\n\n// Hexagonal prism, circumcircle variant\nfloat fHexagonCircumcircle(vec3 p, vec2 h) {\n\tvec3 q = abs(p);\n\treturn max(q.y - h.y, max(q.x*sqrt(3.)*0.5 + q.z*0.5, q.z) - h.x);\n\t//this is mathematically equivalent to this line, but less efficient:\n\t//return max(q.y - h.y, max(dot(vec2(cos(PI/3), sin(PI/3)), q.zx), q.z) - h.x);\n}\n\n// Hexagonal prism, incircle variant\nfloat fHexagonIncircle(vec3 p, vec2 h) {\n\treturn fHexagonCircumcircle(p, vec2(h.x*sqrt(3.)*0.5, h.y));\n}\n\n// Cone with correct distances to tip and base circle. Y is up, 0 is in the middle of the base.\nfloat fCone(vec3 p, float radius, float height) {\n\tvec2 q = vec2(length(p.xz), p.y);\n\tvec2 tip = q - vec2(0, height);\n\tvec2 mantleDir = normalize(vec2(height, radius));\n\tfloat mantle = dot(tip, mantleDir);\n\tfloat d = max(mantle, -q.y);\n\tfloat projected = dot(tip, vec2(mantleDir.y, -mantleDir.x));\n\t\n\t// distance to tip\n\tif ((q.y > height) && (projected < 0.)) {\n\t\td = max(d, length(tip));\n\t}\n\t\n\t// distance to base ring\n\tif ((q.x > radius) && (projected > length(vec2(height, radius)))) {\n\t\td = max(d, length(q - vec2(radius, 0)));\n\t}\n\treturn d;\n}\n\n \n\n\n////////////////////////////////////////////////////////////////\n//\n//                DOMAIN MANIPULATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// Conventions:\n//\n// Everything that modifies the domain is named pSomething.\n//\n// Many operate only on a subset of the three dimensions. For those,\n// you must choose the dimensions that you want manipulated\n// by supplying e.g. <p.x> or <p.zx>\n//\n// <inout p> is always the first argument and modified in place.\n//\n// Many of the operators partition space into cells. An identifier\n// or cell index is returned, if possible. This return value is\n// intended to be optionally used e.g. as a random seed to change\n// parameters of the distance functions inside the cells.\n//\n// Unless stated otherwise, for cell index 0, <p> is unchanged and cells\n// are centered on the origin so objects don't have to be moved to fit.\n//\n//\n////////////////////////////////////////////////////////////////\n\n\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Shortcut for 45-degrees rotation\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Same, but mirror every second cell so they match at the boundaries\nfloat pModMirror1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize,size) - halfsize;\n\tp *= mod(c, 2.0)*2. - 1.;\n\treturn c;\n}\n\n// Repeat the domain only in positive direction. Everything in the negative half-space is unchanged.\nfloat pModSingle1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tif (p >= 0.)\n\t\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Same, but mirror every second cell so all boundaries match\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n\tvec2 halfsize = size*0.5;\n\tvec2 c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\tp *= mod(c,vec2(2))*2. - vec2(1.);\n\treturn c;\n}\n\n// Same, but mirror every second cell at the diagonal as well\nvec2 pModGrid2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\tp *= mod(c,vec2(2))*2. - vec2(1);\n\tp -= size/2.;\n\tif (p.x > p.y) p.xy = p.yx;\n\treturn floor(c/2.);\n}\n\n// Repeat in three dimensions\nvec3 pMod3(inout vec3 p, vec3 size) {\n\tvec3 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5, size) - size*0.5;\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\n// Mirror in both dimensions and at the diagonal, yielding one eighth of the space.\n// translate by dist before mirroring.\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\n// Reflect space at a plane\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset) {\n\tfloat t = dot(p, planeNormal)+offset;\n\tif (t < 0.) {\n\t\tp = p - (2.*t)*planeNormal;\n\t}\n\treturn sgn(t);\n}\n\n\n////////////////////////////////////////////////////////////////\n//\n//             OBJECT COMBINATION OPERATORS\n//\n////////////////////////////////////////////////////////////////\n//\n// We usually need the following boolean operators to combine two objects:\n// Union: OR(a,b)\n// Intersection: AND(a,b)\n// Difference: AND(a,!b)\n// (a and b being the distances to the objects).\n//\n// The trivial implementations are min(a,b) for union, max(a,b) for intersection\n// and max(a,-b) for difference. To combine objects in more interesting ways to\n// produce rounded edges, chamfers, stairs, etc. instead of plain sharp edges we\n// can use combination operators. It is common to use some kind of \"smooth minimum\"\n// instead of min(), but we don't like that because it does not preserve Lipschitz\n// continuity in many cases.\n//\n// Naming convention: since they return a distance, they are called fOpSomething.\n// The different flavours usually implement all the boolean operators above\n// and are called fOpUnionRound, fOpIntersectionRound, etc.\n//\n// The basic idea: Assume the object surfaces intersect at a right angle. The two\n// distances <a> and <b> constitute a new local two-dimensional coordinate system\n// with the actual intersection as the origin. In this coordinate system, we can\n// evaluate any 2D distance function we want in order to shape the edge.\n//\n// The operators below are just those that we found useful or interesting and should\n// be seen as examples. There are infinitely more possible operators.\n//\n// They are designed to actually produce correct distances or distance bounds, unlike\n// popular \"smooth minimum\" operators, on the condition that the gradients of the two\n// SDFs are at right angles. When they are off by more than 30 degrees or so, the\n// Lipschitz condition will no longer hold (i.e. you might get artifacts). The worst\n// case is parallel surfaces that are close to each other.\n//\n// Most have a float argument <r> to specify the radius of the feature they represent.\n// This should be much smaller than the object size.\n//\n// Some of them have checks like \"if ((-a < r) && (-b < r))\" that restrict\n// their influence (and computation cost) to a certain area. You might\n// want to lift that restriction or enforce it. We have left it as comments\n// in some cases.\n//\n// usage example:\n//\n// float fTwoBoxes(vec3 p) {\n//   float box0 = fBox(p, vec3(1));\n//   float box1 = fBox(p-vec3(1), vec3(1));\n//   return fOpUnionChamfer(box0, box1, 0.2);\n// }\n//\n////////////////////////////////////////////////////////////////\n\n\n// The \"Chamfer\" flavour makes a 45-degree chamfered edge (the diagonal of a square of size <r>):\nfloat fOpUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\n// Intersection has to deal with what is normally the inside of the resulting object\n// when using union, which we normally don't care about too much. Thus, intersection\n// implementations sometimes differ from union implementations.\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n\treturn max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n\treturn fOpIntersectionChamfer(a, -b, r);\n}\n\n// The \"Round\" variant uses a quarter-circle to join the two objects smoothly:\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle:\nfloat fOpUnionColumns(float a, float b, float r, float n) {\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\t\tpR45(p);\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += columnradius*sqrt(2.);\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\t// At this point, we have turned 45 degrees and moved at a point on the\n\t\t// diagonal that we want to place the columns on.\n\t\t// Now, repeat the domain along this direction and place a circle.\n\t\tpMod1(p.y, columnradius*2.);\n\t\tfloat result = length(p) - columnradius;\n\t\tresult = min(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn min(result, b);\n\t} else {\n\t\treturn min(a, b);\n\t}\n}\n\nfloat fOpDifferenceColumns(float a, float b, float r, float n) {\n\ta = -a;\n\tfloat m = min(a, b);\n\t//avoid the expensive computation where not needed (produces discontinuity though)\n\tif ((a < r) && (b < r)) {\n\t\tvec2 p = vec2(a, b);\n\t\tfloat columnradius = r*sqrt(2.)/n/2.0;\n\t\tcolumnradius = r*sqrt(2.)/((n-1.)*2.+sqrt(2.));\n\n\t\tpR45(p);\n\t\tp.y += columnradius;\n\t\tp.x -= sqrt(2.)/2.*r;\n\t\tp.x += -columnradius*sqrt(2.)/2.;\n\n\t\tif (mod(n,2.) == 1.) {\n\t\t\tp.y += columnradius;\n\t\t}\n\t\tpMod1(p.y,columnradius*2.);\n\n\t\tfloat result = -length(p) + columnradius;\n\t\tresult = max(result, p.x);\n\t\tresult = min(result, a);\n\t\treturn -min(result, b);\n\t} else {\n\t\treturn -m;\n\t}\n}\n\nfloat fOpIntersectionColumns(float a, float b, float r, float n) {\n\treturn fOpDifferenceColumns(a,-b,r, n);\n}\n\n// The \"Stairs\" flavour produces n-1 steps of a staircase:\n// much less stupid version by paniq\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n;\n\tfloat u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\n\n// We can just call Union since stairs are symmetric.\nfloat fOpIntersectionStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, -b, r, n);\n}\n\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {\n\treturn -fOpUnionStairs(-a, b, r, n);\n}\n\n\n// Similar to fOpUnionRound, but more lipschitz-y at acute angles\n// (and less so at 90 degrees). Useful when fudging around too much\n// by MediaMolecule, from Alex Evans' siggraph slides\nfloat fOpUnionSoft(float a, float b, float r) {\n\tfloat e = max(r - abs(a - b), 0.);\n\treturn min(a, b) - e*e*0.25/r;\n}\n\n\n// produces a cylindical pipe that runs along the intersection.\n// No objects remain, only the pipe. This is not a boolean operator.\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\n// first object gets a v-shaped engraving where it intersect the second\nfloat fOpEngrave(float a, float b, float r) {\n\treturn max(a, (a + r - abs(b))*sqrt(0.5));\n}\n\n// first object gets a capenter-style groove cut out\nfloat fOpGroove(float a, float b, float ra, float rb) {\n\treturn max(a, min(a + ra, rb - abs(b)));\n}\n\n// first object gets a capenter-style tongue attached\nfloat fOpTongue(float a, float b, float ra, float rb) {\n\treturn min(a, max(a - ra, abs(b) - rb));\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "Xltczf",
    "date": "1533501636",
    "viewed": 84,
    "name": "PathMove",
    "description": "Animation, Path follow",
    "likes": 1,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "animation"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3zn",
       "filepath": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg",
       "type": "cubemap",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "4sfGRr",
       "filepath": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin",
       "type": "volume",
       "channel": 2,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//Raycaster code credit to Inigo Quilez\n\n\n\n// animation data:  all keys have equal time spacing\nconst vec3[] v1= vec3[]  (  \n                    vec3 (50., 50., 50.), \n                    vec3 (-50., 50., 50.),           \n                    vec3 (-50., 50., 50.), \n                    vec3 (-50., -50., 50.), \n                    vec3 (50., -50., 50.), \n                    vec3 (50., -50., 50.), \n                    vec3 (50., -50., 10.),\n                    vec3 (50., 50., 10.), \n                    vec3 (-50., 50., 10.),\n                    vec3 (-0., 0., 100.),\n                    vec3 (-0., 0., 10.),\n                    vec3 (-0., 0., 100.), \n                    vec3 (-100., 0., 10.), \n                    vec3 ( 100., 0., 10.), \n                    vec3 (-100., 0., 10.), \n                    vec3 (-0., 0., 40.),\n                    vec3 (-0., 0., 15.),\n                    vec3 (-0., 0., 15.),      \n                    vec3 (-0., 0., 15.),\n                    vec3 (-0., 0., 15.), \n                    vec3 (-50., -50.,20.) \n                  \n) \n                                  ;\n \n\n\n\n \n// rotm sphere  credit to Inigo Quilez\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;}\nfloat smin( float a, float b, float k )\n{    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);}\n\n \n // wraps index 0 - tak \nfloat wrapi( float x,float tak){ return mod((mod(x  , tak) + tak) , tak) ;}\n\nvec3 smooth_animate(float t){\n \nfloat ll=float(v1.length());     // array lenght\nfloat  i=round(ll*t);           // index of closest animation key\nfloat T=mod( (ll*t+0.5),1.) ;   // local t of curve piece\n\n\n//construct three point bezier of current key and  half way to next and prev key\n// wrap index to keep animation looping\nvec3 p0=    mix( v1[int( wrapi(i-1.,ll))], v1[int(wrapi(i,ll))],0.5);\nvec3 p1=    v1[int(wrapi(i,ll))];\nvec3 p2=    mix( v1[int(wrapi(i,ll))],v1[int( wrapi(i+1.,ll))],0.5)  ;\n    \n// 3p bezier\n    return mix(mix( p0,p1,T),mix(p1,p2,T),T) ;}\n\n\n \n\n\nvec4 map(vec4 r0)\n    \n{  \n    vec3 p=r0.xyz ;\n   vec3 psp1= vec3(p.x*cos(iTime)-p.y*sin(iTime),\n                  p.y*cos(iTime)+p.x*sin(iTime) ,p.z) ;\n\n   vec3 psp2= vec3(p.x*cos(iTime/-2.)-p.y*sin(iTime/-2.),\n                  p.y*cos(iTime/-2.)+p.x*sin(iTime/-2.) ,p.z) ;\n\n    vec3 m1= smooth_animate(mod(iTime/15.,1.))  ;\n   vec3 m2= smooth_animate(mod((iTime)/12.,1.)+0.5)  ;\n  vec3 pm1=psp1-m1 ;\n  vec3 pm2=psp2-m2 ;\n\n  float sphere1=sdSphere( psp1-m1, 19.9);\n  float sphere2=sdSphere( psp2-m2, 29.9);\n  float plane=p.z;\n\n float c1= mod( \n        mod (floor(pm1.x/10.),2.)+\n        mod (floor(pm1.y/10.),2.)+\n        mod (floor(pm1.z/10.),2.)\n        ,2.);\n    \n float c2= mod( \n        mod (floor(pm2.x/10.),2.)+\n        mod (floor(pm2.y/10.),2.)+\n        mod (floor(pm2.z/10.),2.)\n        ,2.);\n    \n float c3= mod( mod (floor(p.x/10.),2.)+mod (floor(p.y/10.),2.),2.);\n \n float c= sphere2>sphere1?c1:c2;\n       c= plane> min(sphere2,sphere1)?c:c3;\n \n    return vec4(smin(plane,smin(sphere1,sphere2,20.),20.),c,c,c );\n }\n\n\n\n\n\n\n//Raycaster code credit to Inigo Quilez\n\nconst vec3 bbox_min = vec3(-7.363703305156273, -7.363703305156273, -7.363703305156273);\nconst vec3 bbox_max = vec3(7.363703305156273, 7.363703305156273, 7.363703305156273);\n// ray marching. ro is ray origin, rd is ray direction (unit vector).\n// result is (t,r,g,b), where\n//  * t is the distance that we marched,\n//  * r,g,b is the colour of the distance field at the point we ended up at.\n//    (-1,-1,-1) means no object was hit.\nvec4 castRay( in vec3 ro, in vec3 rd) {\n\tfloat tmin = 1.0;\n\tfloat tmax = 250.;\n \n\tfloat t = tmin;\n\tvec3 c = vec3(-.0, -.0, -.0);\n\n\tfor (int i = 0; i < 200; i++) {\n\t\tfloat precis = 0.03;\n\t\tvec4 res = map(vec4(ro + rd * t, iTime));\n\n\t\tif (res.x < precis *300.) {\n\t\t\tc = mix(c,  (res.yzw*.5)*2., \n                    clamp(1. / res.x, 0., 1.) \n\t\t \n                   ) \n                ;\n\n\t\t\tif (res.x < precis) {\n\t\t\t\tc = mix(c, (res.yzw),0.6);\n \t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tt += res.x;\n\t\tif (t > tmax) {\n\n\t\t\tc = mix(texture(iChannel0, rd.xzy).xyz, c, length(c));\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn vec4(t, c);\n}\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( vec4(pos + e.xyy,iTime) ).x + \n                      e.yyx*map( vec4(pos + e.yyx,iTime) ).x + \n                      e.yxy*map( vec4(pos + e.yxy,iTime) ).x + \n                      e.xxx*map( vec4(pos + e.xxx,iTime) ).x );\n}\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( vec4(aopos,iTime) ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n// in ro: ray origin\n// in rd: ray direction\n// out: rgb colour\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    //vec3 col = vec3(0.7, 0.9, 1.0) +rd.z*0.8;\n    //vec3 col = vec3(0.8, 0.9, 1.0);\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    vec4 res = castRay(ro,rd);\n    float t = res.x;\n    vec3 c = res.yzw;\n    if( true )\n    {col=c;}\n    else if( c.x>=0.0 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = mix(c,normalize(c),0.12)*0.34;\n\n        // lighting        \n        float occ = calcAO( pos, nor );\n        vec3  lig1 = normalize( vec3(-0.8, 0.3, 0.5) );\n        vec3  lig2 = normalize( vec3(0.8, 0.3, 0.5) );\n        float amb = clamp( 0.5+0.5*nor.z, 0.0, 1.0 );\n        float dif1 = clamp( dot( nor, lig1 ), 0.0, 1.0 );\n        float dif2 = clamp( dot( nor, lig2 ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig1.x,lig1.y,0.0))), 0.0, 1.0 )*clamp( 1.0-pos.z,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, ref.z );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        float spe1 = pow(clamp( dot( ref, lig1 ), 0.0, 1.0 ),32.0);\n        float spe2 = pow(clamp( dot( ref, lig2 ), 0.0, 1.0 ),32.0);\n        \n        vec3 lin = vec3(0.0);\n        lin += 4.30*dif1*vec3(1.00,0.80,0.55);\n        lin += 4.30*dif2*vec3(1.00,0.80,0.55);\n        lin += 14.00*spe1*vec3(1.00,0.90,0.70)*dif1;\n        lin += 14.00*spe2*vec3(0.50,0.90,1.0)*dif2;\n        lin += 0.9*amb*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n        lin += 0.20*bac*vec3(0.935,0.935,0.935)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n        vec3 iqcol = col*lin;\n\n        //col = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n        col = mix(col,iqcol, 0.64);\n    }\n\n    return vec3( clamp(col,0.0,1.0) );\n}\n// Create a matrix to transform coordinates to look towards a given point.\n// * `eye` is the position of the camera.\n// * `centre` is the position to look towards.\n// * `up` is the 'up' direction.\nmat3 look_at(vec3 eye, vec3 centre, vec3 up)\n{\n    vec3 ww = normalize(centre - eye);\n    vec3 uu = normalize(cross(ww, up));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n// Generate a ray direction for ray-casting.\n// * `camera` is the camera look-at matrix.\n// * `pos` is the screen position, normally in the range -1..1\n// * `lens` is the lens length of the camera (encodes field-of-view).\n//   0 is very wide, and 2 is a good default.\nvec3 ray_direction(mat3 camera, vec2 pos, float lens)\n{\n    return normalize(camera * vec3(pos, lens));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const vec3 origin = (bbox_min + bbox_max) / 2.0 +vec3 (0,0,10);\n    const vec3 radius = (bbox_max - bbox_min) / 2.0;\n    float r = max(radius.x, max(radius.y, radius.z)) / 1.0;\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n \n      vec2 mouse = iMouse.xy / iResolution.xy;\n      //  vec3 eye = vec3 (cos (4. * mouse.x) * 67., sin (4. * mouse.x) *sin (4. * mouse.y) * 67., -cos (4. * mouse.y) * 67.);\nvec3 eye = vec3(sin(iTime/5.)*150., cos(iTime/5.)*180., cos(iTime/10.)*4.+50.);\n    vec3 centre = vec3(-1.0, 0.0, 30.0);\n    vec3 up = eye+ vec3(0.0, 0.0, 1.0);\n\t \n \n    mat3 camera = look_at(eye, centre, up);\n    vec3 dir = ray_direction(camera, p, 2.5);\n\n    vec3 col = render( eye, dir );\n    \n    // convert linear RGB to sRGB\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3dfyWs",
    "date": "0",
    "viewed": 0,
    "name": "Plane cut stone",
    "description": "stone generation",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "procedural",
     "noise",
     "rock",
     "wet",
     "stone"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Wet stone\" by TDM. https://shadertoy.com/view/ldSSzV\n// 2020-04-02 04:52:38\n\n/*\n\"Wet stone\" by Alexander Alekseev aka TDM - 2014\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nContact: tdmaav@gmail.com\n*/\n\n#define SMOOTH\n#define AA\n\nconst int NUM_STEPS = 32;\nconst int AO_SAMPLES = 4;\nconst vec2 AO_PARAM = vec2(1.2, 3.5);\nconst vec2 CORNER_PARAM = vec2(0.25, 40.0);\nconst float INV_AO_SAMPLES = 1.0 / float(AO_SAMPLES);\nconst float TRESHOLD \t= 0.1;\nconst float EPSILON \t= 1e-3;\nconst float LIGHT_INTENSITY = 0.25;\nconst vec3 RED \t\t= vec3(1.0,0.7,0.7) * LIGHT_INTENSITY;\nconst vec3 ORANGE \t= vec3(1.0,0.67,0.43) * LIGHT_INTENSITY;\nconst vec3 BLUE \t= vec3(0.54,0.77,1.0) * LIGHT_INTENSITY;\nconst vec3 WHITE \t= vec3(1.2,1.07,0.98) * LIGHT_INTENSITY;\n\nconst float DISPLACEMENT = 0.1;\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nvec3 saturation(vec3 c, float t) {\n    return mix(vec3(dot(c,vec3(0.2126,0.7152,0.0722))),c,t);\n}\nfloat hash11(float p) {\n    return fract(sin(p * 727.1)*435.545);\n}\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*437.545);\n}\nvec3 hash31(float p) {\n\tvec3 h = vec3(127.231,491.7,718.423) * p;\t\n    return fract(sin(h)*435.543);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\n// fBm\nfloat fbm3(vec3 p, float a, float f) {\n    return noise_3(p);\n}\n\nfloat fbm3_high(vec3 p, float a, float f) {\n    float ret = 0.0;    \n    float amp = 1.0;\n    float frq = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float n = pow(noise_3(p * frq),2.0);\n        ret += n * amp;\n        frq *= f;\n        amp *= a * (pow(n,0.2));\n    }\n    return ret;\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) { return pow(max(dot(n,l),0.0),p); }\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// distance functions\nfloat plane(vec3 gp, vec4 p) {\n\treturn dot(p.xyz,gp+p.xyz*p.w);\n}\nfloat sphere(vec3 p,float r) {\n\treturn length(p)-r;\n}\nfloat capsule(vec3 p,float r,float h) {\n    p.y -= clamp(p.y,-h,h);\n\treturn length(p)-r;\n}\nfloat cylinder(vec3 p,float r,float h) {\n\treturn max(abs(p.y/h),capsule(p,r,h));\n}\nfloat box(vec3 p,vec3 s) {\n\tp = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\nfloat rbox(vec3 p,vec3 s) {\n\tp = abs(p)-s;\n    return length(p-min(p,0.0));\n}\nfloat quad(vec3 p,vec2 s) {\n\tp = abs(p) - vec3(s.x,0.0,s.y);\n    return max(max(p.x,p.y),p.z);\n}\n\n// boolean operations\nfloat boolUnion(float a,float b) { return min(a,b); }\nfloat boolIntersect(float a,float b) { return max(a,b); }\nfloat boolSub(float a,float b) { return max(a,-b); }\n\n// smooth operations. thanks to iq\nfloat boolSmoothIntersect(float a, float b, float k ) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(a,b,h) + k*h*(1.0-h);\n}\nfloat boolSmoothSub(float a, float b, float k ) {\n    return boolSmoothIntersect(a,-b,k);\n}\t\n\n// world\nfloat rock(vec3 p) {    \n    float d = rbox(p,vec3(.6))-.2; \n    int seed=int(iTime)*300;\n    \n    for(int i = 0; i < 12; i++) {\n        float ii = float(i+seed);\n        float r =  .5+hash11(ii)*0.5;\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0-vec3(0,0.7,0) );\n           \n      \n        d = boolSmoothSub(d, (plane(p,vec4(v,r ))), 0.03);\n              \n    }\n    \n    for(int i = 0; i < 4; i++) {\n        float ii = float(i+seed)+.1;\n        float r =  .7+hash11(ii)*.5;\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0-vec3(0,0.2,0))*1.6 ;\n           \n      \n        d = boolSmoothSub(d, (sphere(p+v,r  )), 0.03);\n              \n    }\n    \n    return d  - fbm3(p*4.0,0.4,2.96) * DISPLACEMENT ;\n}\n\nfloat map(vec3 p) {\n    float d = rock(p) + fbm3(p*2.0,0.4,2.96) * DISPLACEMENT;\n    d = boolUnion(d,plane(p,vec4(0.0,1.0,0.0,1.0)));\n    return d;\n}\n\nfloat map_detailed(vec3 p) {\n    float d = rock(p) + fbm3_high(p*4.0,0.4,2.96) * DISPLACEMENT;\n    d = boolUnion(d,plane(p,vec4(0.0,1.0,0.0,1.0)));\n    return d;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float dens) {\n    vec3 n;\n    n.x = map_detailed(vec3(p.x+EPSILON,p.y,p.z));\n    n.y = map_detailed(vec3(p.x,p.y+EPSILON,p.z));\n    n.z = map_detailed(vec3(p.x,p.y,p.z+EPSILON));\n    return normalize(n-map_detailed(p));\n}\nvec2 getOcclusion(vec3 p, vec3 n) {\n    vec2 r = vec2(0.0);\n    for(int i = 0; i < AO_SAMPLES; i++) {\n        float f = float(i)*INV_AO_SAMPLES;\n        float hao = 0.01+f*AO_PARAM.x;\n        float hc = 0.01+f*CORNER_PARAM.x;\n        float dao = map(p + n * hao) - TRESHOLD;\n        float dc = map(p - n * hc) - TRESHOLD;\n        r.x += clamp(hao-dao,0.0,1.0) * (1.0-f);\n        r.y += clamp(hc+dc,0.0,1.0) * (1.0-f);\n    }    \n    r.x = clamp(1.0-r.x*INV_AO_SAMPLES*AO_PARAM.y,0.0,1.0);\n    r.y = clamp(r.y*INV_AO_SAMPLES*CORNER_PARAM.y,0.0,1.0);\n    return r;\n}\nvec2 spheretracing(vec3 ori, vec3 dir, out vec3 p) {\n    vec2 td = vec2(0.0);\n    for(int i = 0; i < NUM_STEPS; i++) {\n        p = ori + dir * td.x;\n        td.y = map(p);\n        if(td.y < TRESHOLD) break;\n        td.x += (td.y-TRESHOLD) * 0.9;\n    }\n    return td;\n}\n\n// stone\nvec3 getStoneColor(vec3 p, float c, vec3 l, vec3 n, vec3 e) {\n    c = min(c + pow(noise_3(vec3(p.x*20.0,0.0,p.z*20.0)),70.0) * 8.0, 1.0);\n    float ic = pow(1.0-c,0.5);\n    vec3 base = vec3(0.42,0.3,0.2) * 0.35;\n    vec3 sand = vec3(0.51,0.41,0.32)*0.9;\n    vec3 color = mix(base,sand,c);\n        \n    float f = pow(1.0 - max(dot(n,-e),0.0), 5.0) * 0.75 * ic;    \n    color += vec3(diffuse(n,l,0.5) * WHITE);\n    color += vec3(specular(n,l,e,8.0) * WHITE * 1.5 * ic);\n    n = normalize(n - normalize(p) * 0.4);    \n    color += vec3(specular(n,l,e,80.0) * WHITE * 1.5 * ic);    \n    color = mix(color,vec3(1.0),f); \n    \n    color *= sqrt(abs(p.y*0.5+0.5)) * 0.4 + 0.6;\n    color *= (n.y * 0.5 + 0.5) * 0.4 + 0.6; \n    \n    return sand;\n}\n\nvec3 getPixel(in vec2 coord, float time) {\n    vec2 iuv = coord / iResolution.xy * 2.0 - 1.0;\n    vec2 uv = iuv;\n    uv.x *= iResolution.x / iResolution.y;\n        \n    // ray\n    vec3 ang = vec3(0.0,0.2,time);\n    if(iMouse.z > 0.0) ang = vec3(0.0,clamp(2.0-iMouse.y*0.01,0.0,3.1415),iMouse.x*0.01);\n\tmat3 rot = fromEuler(ang);\n    \n    vec3 ori = vec3(0.0,0.0,2.8);\n    vec3 dir = normalize(vec3(uv.xy,-2.0));    \n    ori = ori * rot;\n    dir = dir * rot;\n    \n    // tracing\n    vec3 p;\n    vec2 td = spheretracing(ori,dir,p);\n    vec3 n = getNormal(p,td.y);\n    vec2 occ = getOcclusion(p,n);\n    vec3 light = normalize(vec3(0.0,1.0,0.0)); \n         \n    // color\n    vec3 color = vec3(1.0);    \n    if(td.x < 3.5 && p.y > -0.89) color = getStoneColor(p,occ.y,light,n,dir);\n    color *= occ.x;\n    return color;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime * 0.3;\n        \n#ifdef AA\n    vec3 color = vec3(0.0);\n    for(int i = -1; i <= 1; i++)\n    for(int j = -1; j <= 1; j++) {\n        vec2 uv = fragCoord+vec2(i,j)/3.0;\n        color += getPixel(uv, time);\n    }\n    color /= 9.0;\n#else\n    vec3 color = getPixel(fragCoord, time);\n#endif\n    color = sqrt(color);\n    color = saturation(color,1.7);\n               \n    // vignette\n    vec2 iuv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    float vgn = smoothstep(1.2,0.7,abs(iuv.y)) * smoothstep(1.1,0.8,abs(iuv.x));\n    color *= 1.0 - (1.0 - vgn) * 0.15;\t\n    \n\tfragColor = vec4(color,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "ttfSWH",
    "date": "1562707328",
    "viewed": 193,
    "name": "Plant based ",
    "description": "simple plant sdf some variation possible",
    "likes": 16,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "sdf",
     "plant",
     "foliage"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "float sdPlane(vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r) {\n    return (length(p / r) - 1.0) * min(min(r.x, r.y), r.z);\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r;\n}\n\nfloat TTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat sdTorus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q) - t.y;\n}\n\nfloat opIntersection(float d1, float d2) {\n    return max(d1, d2);\n}\nfloat sdPlane(vec3 p, vec4 n) {\n    // n must be normalized\n    return dot(p, n.xyz) + n.w;\n}\nfloat opSubtraction(float d1, float d2) {\n    return max(-d1, d2);\n}\n\nfloat opOnion( in float sdf, in float thickness) {\n    return abs(sdf) - thickness;\n}\n\nfloat opSmoothIntersection(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n//----------------------------------------------------------------------\n\n//----------------------------------------------------------------------\n\nfloat plant( in vec3 pos, vec4 type) {\n    float l =  length(pos.xz)*max(1.,abs( 4.* pos.y-1.)) ;\n    pos=pos\n        +vec3(l,0,l)*(0.2+sin(pos.x+pos.y+iTime*0.6)*0.2)\n        +vec3(0,l,0)*(0.1+sin(pos.y+iTime*1.6)*0.1)\n                     ;\n    float d, di, plane, lay;\n    d = l;\n    if ((l - type.w) < 0.) {\n\n        for (float i = 0.3; i < 0.28+type.w*0.5; i += +(.101*1./3.)) {\n\n            di = sdTorus(pos + vec3(0, -i * type.z*0.6, 0), vec2(0.18 * type.w + i * type.y, i * 1.5*type.z * type.w));\n\n            di = opOnion(di, type.x * 0.125 * type.w);\n            lay = i * (23.416 * 1.7);\n            plane = sdPlane(vec3(pos.x, pos.y, pos.z), vec4(sin(lay), 0, cos(lay), (-0.5+fract(lay*10.))*0.5*type.x));\n            di = opIntersection(di,\n\n                abs(plane)   -  ( sin(clamp( (min(l,type.w)/type.w )*7.28,.3,6.28) ))*type.x);\n\n            d = min(d, di);\n            if(d<0.01)break;\n\n        }\n        d = opIntersection(d, sdSphere(pos + vec3(0, -type.w * 0.9, 0), type.w));\n\n    }\n\n    return d;\n}\n//-------------------------------------------\nvec2 map( in vec3 pos) {\n    float Strand, Spread, Lift, Size;\n    float sqr = 1.;\n    float d = length(pos.xz)+1.;\n    vec3 pfract = fract(pos / sqr) * sqr;\n    vec3 pround = round(pos / sqr) * sqr + vec3(sqr * 0.5, 0, sqr * 0.5);\n    vec3 mos = vec3(pfract.x, pos.y, pfract.z);\n\n    float i = (pos - pfract).x;\n    float j = (pos - pfract).z;\n\n    Strand = 0.01 + fract( sin(i * 12. + j*9.9) * 9.219869) * 0.0325;\n    Spread = 0. + fract( sin (i * 12. + j*9.9) * 99.24927) * .3;\n    Lift = .2 + fract(  sin(i * 42. + j*32.9) * 199.210930) * .5;\n    Size = .2 + fract( sin (i * 2. + j) * 99.) * .7;\n\n    d = min(d, plant(mos - vec3(sqr * 0.5, 0., sqr * 0.5), vec4(Strand, Spread * 1.1, Lift, Size)));\n\n    float plane = sdPlane(vec3(pos.x, pos.y, pos.z), vec4(0, 1, 0, 0));\n    d = min(d, plane);\n    d = max(d, -(length(pfract.xz - vec3(sqr * 0.5, 0., sqr * 0.5).xz) -0.01));\n\n    return vec2(d, 3);\n\n}\n\nvec2 castRay( in vec3 ro, in vec3 rd) {\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    /*#if 0\n    float tp1 = (0.0 - ro.y) / rd.y;\n    if (tp1 > 0.0) tmax = min(tmax, tp1);\n    float tp2 = (1.6 - ro.y) / rd.y;\n    if (tp2 > 0.0) {\n        if (ro.y > 1.6) tmin = max(tmin, tp2);\n        else tmax = min(tmax, tp2);\n    }#endif*/\n\n    float precis = 0.0002;\n    float t = tmin;\n    float m = -1.0;\n    for (int i = -0; i < 250; i++) {\n        vec2 res = map(ro + rd * t);\n        if (res.x < precis || t > tmax) break;\n        t += res.x * 0.2;\n        m = res.y;\n    }\n\n    if (t > tmax) m = -1.0;\n    return vec2(t, m);\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n    float res = 1.0;\n    float t = mint;\n    for (int i = 0; i < 16; i++) {\n        float h = map(ro + rd * t).x;\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if (h < 0.001 || t > tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n\n}\n\nvec3 calcNormal( in vec3 pos) {\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(pos + eps.xyy).x - map(pos - eps.xyy).x,\n        map(pos + eps.yxy).x - map(pos - eps.yxy).x,\n        map(pos + eps.yyx).x - map(pos - eps.yyx).x);\n    return normalize(nor);\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for (int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3 aopos = nor * hr + pos;\n        float dd = map(aopos).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\nvec3 render( in vec3 ro, in vec3 rd) {\n    vec3 col = vec3(0.3, 0.6, 0.0) + rd.y * 0.8;\n    vec2 res = castRay(ro, rd);\n    float t = res.x;\n    float m = res.y;\n    if (m > -0.5) {\n        vec3 pos = ro + t * rd;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd, nor);\n\n        // material        \n        col = 0.45 + 0.3 * sin(vec3(0.15, 0.8, 0.00) * (m - 1.0));\n\n        if (m < 1.5) {\n\n            float f = mod(floor(5.0 * pos.z) + floor(5.0 * pos.x), 2.0);\n            col = 0.4 + 0.1 * f * vec3(0., 1., 0.);\n        }\n\n        // lighitng   .//     \n        float occ =  calcAO(pos, nor);\n        vec3 lig = normalize(vec3(-0.6, .7, -0.5));\n        float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n        float dif = clamp(dot(nor, lig), 0.0, 1.0);\n        float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0);\n        float dom = smoothstep(-0.1, 0.1, ref.y);\n        float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n        float spe = pow(clamp(dot(ref, lig), 0.0, 1.0), 16.0);\n\n         dif *= softshadow(pos, lig, 0.02, 1.5);\n        // dom *= softshadow(pos, ref, 0.02, 2.5);\n\n        vec3 lin = vec3(0.0);\n        lin += 1.20 * dif * vec3(1.00, 0.85, 0.55);\n        lin += 1.20 * spe * vec3(1.00, 0.85, 0.55) * dif;\n        lin += 0.30 * amb * vec3(0.250, 0.70, 0.255) * occ;\n        lin += 0.30 * dom * vec3(0.50, 0.70, 0.55) * occ;\n        lin += 0.30 * bac * vec3(0.25, 0.5, 0.25) * occ;\n        lin += 0.40 * fre * vec3(1.00, 1.00, 0.55) * occ;\n        col = col * lin;\n\n        //col = mix( col, vec3(0.8,0.9,0.05), 1.0-exp( -0.002*t*t ) );\n\n    }\n\n    return vec3(clamp(col, 0.0, 1.0));\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw, cp));\n    vec3 cv = normalize(cross(cu, cw));\n    return mat3(cu, cv, cw);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 mo = iMouse.xy / iResolution.xy;\n\n    float time = 15.0 + iTime;\n    vec3 fly = vec3(sin(time * 0.0001936), 0, cos(time * 0.0001345)) * 3000.;\n    fly += vec3(sin(time * 0.001563), 0, cos(time * 0.001175)) * 300.;\n    // camera\t\n    vec3 ro = fly + 1.4 * vec3(  1.6  * cos(0.16 * time + 6.0 * mo.x), 1.5 + 1.0 * mo.y,   1.6  * sin(0.16 * time + 6.0 * mo.x));\n    vec3 ta = fly + vec3(-0.0, -0.0, 0.);\n\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    // ray direction\n    vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n    // render\t\n    vec3 col = render(ro, rd);\n\n    col = pow(col, vec3(0.4545));\n\n    fragColor = vec4(col, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WlsSWS",
    "date": "1564116322",
    "viewed": 1047,
    "name": "Procedural walk animation",
    "description": "Now I have to catch my bouncy head.\nMy head is like a ball \nand I lost it in a fall.\nIf I only could catch my bouncy head",
    "likes": 68,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "3d",
     "animation",
     "walkcycle",
     "footsteps"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "Mll3zX",
       "filepath": "https://soundcloud.com/clynos2/funny-melody",
       "type": "musicstream",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 0
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Football\" by . https://shadertoy.com/view/llKcR3\n// 2019-07-25 21:23:38\n// Modified from https://www.shadertoy.com/view/Xds3zN by iq.\n//\n\n/*\n Some path funtion: timefly(t) returns a 2d pivot\n pasaR(t) and pasaL(t) modifies time to get \n initial foot targets when fead to timefly()\n \n*/\n\n#define AA 1\n# define PI 3.14159265359\n# define PHI 1.618033988749895\n# define TAU 6.283185307179586\nvec3 rightFoot;\nvec3 leftFoot;\nvec3 rightToe;\nvec3 leftToe;\nvec3 rightHand;\nvec3 leftHand;\nvec3 rightFootT;\nvec3 leftFootT;\nvec3 rightHandT;\nvec3 leftHandT;\nvec3 rightToeT;\nvec3 leftToeT;\nvec3 rightE; // Elbow\nvec3 leftE;\nvec3 rightK;//Knee\nvec3 leftK;\nvec3 rightH; //Hip\nvec3 leftH;\nvec3 rightS;// Shoulder\nvec3 leftS;\nvec3 pelvis;\nvec3 torso;\nvec3 head;\nvec3 target;\n\n\tfloat pasa = 1.; // steps overlaping airtime\n\tfloat legmax = .89; // max extention\n\tfloat leg = .89+0.005; // actual max length\n\tfloat armmax = .7;// max extention\n\tfloat arm = .7 +.012;// actual max length\n  \tfloat toemax = 1.1;// max extention toe from hip\n    float footlift=0.19; //lift height later multiplied by speed\n\n\n# define PLOTPATH 0\n \n\n//------------------------------------------------------------------\nfloat sdPlane(vec3 p) {\n\treturn p.y;\n}\nfloat sdSphere(vec3 p, float s) {\n\treturn length(p) - s;\n}\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h) - r;\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n    vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat pathterrain(float x,float z){\n    // Common height function for path and terrain\n    return \n        sin(x*.5 )*1.+cos(z*.3 )*0.3\n        +cos(x*3.+z )*0.1+sin(x-z*.2 )*0.2\n        \n        ;}\n vec3 timefly(float t) {\n    // main path Called from many places\n    t*=.80;\n\tt += (.125 + sin(t * .125));\n\tvec3 v =\n\tvec3(sin(t / 50.) * 20., 0., cos(t / 25.) * 24.) +\n\t\tvec3(sin(t / 17.1) * 07., 0., cos(t / 17.1) * 05.) +\n\t\tvec3(sin(t / 8.1) * 6., 0., cos(t / 8.1) * 8.) +\n\t\tvec3(cos(t / 3.) * 3.,0., sin(t / 3.) * 2.)\n        +vec3(cos(t  )*2.,0., sin(t  )*2. );\n    v.y=pathterrain(v.x,v.z);\n    return v        ;\n} \nfloat pasaR(float x){\nreturn max(x + fract(x + 0.25) * pasa - pasa, floor(x + 0.25) - 0.25) + 0.25;\n    //gait function \n}\n    \nfloat pasaL(float x){\nreturn max(x + fract(x - 0.25) * pasa - pasa, floor(x - 0.25) + 0.25) + 0.25;\n   //gait function \n}\n\n\n\nfloat lpnorm(vec3 p, float s) {\n\treturn pow(\n\t\t(\n\t\t\tpow(abs(p.x), s) +\n\t\t\tpow(abs(p.y), s) +\n\t\t\tpow(abs(p.z), s)),\n\t\t1.0 / s);\n}\n\n \n//------------------------------------------------------------------\nvec2 opU(vec2 d1, vec2 d2) {\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp(.5 + .5*(a-b)/k, 0., 1.);\n\treturn mix(a, b, h) - k*h*(1.-h);\n}\nvec2 bodyPlan(vec3 pos) {\n\tfloat res;\n\tres =  sdSphere(pos - leftFoot, .07);\n\tres = min(res, sdSphere(pos - leftHand, .06));\n\tres = min(res, sdSphere(pos - leftH, .09));\n\tres = min(res, sdSphere(pos - leftK, .08));\n\tres = min(res, sdSphere(pos - leftE, .08));\n\tres = min(res, sdSphere(pos - leftS, .07));\t\n\n    \n\n    res = min(res, sdSphere(pos - rightFoot, .07));\n\tres = min(res, sdSphere(pos - rightHand, .06));\n\tres = min(res, sdSphere(pos - rightH, .09));\n\tres = min(res, sdSphere(pos - rightS, .07));\n\tres = min(res, sdSphere(pos - rightK, .08));\n\tres = min(res, sdSphere(pos - rightE, .08));\n    \n    \tres = min(res, sdSphere(pos - target, .2));\n\t//res = min(res, sdSphere(pos - head, .16));\n\n \t\n   \n\n    \n\n    \n    res = min(res, sdCapsule(pos ,rightToe,rightFoot, .06));\n    res = smin(res, sdRoundedCylinder(pos - rightToe, .04, .02, .03 ),0.06 );\n\n    res = min(res, sdCapsule(pos ,rightK,rightFoot, .06));\n    res = min(res, sdCapsule(pos ,rightK,rightH, .07));   \n    res = min(res, sdCapsule(pos ,rightE,rightHand, .05));\n    res = min(res, sdCapsule(pos ,rightE,rightS, .06));\n    res = min(res, sdCapsule(pos ,torso,rightS, .08));\n    \n    res = min(res, sdCapsule(pos ,leftToe,leftFoot, .06));\n    res = smin(res, sdRoundedCylinder(pos - leftToe, .04, .02, .03 ),0.06);// todo rotate to grund normal\n\n    res = min(res, sdCapsule(pos ,leftK,leftFoot, .06));\n    res = min(res, sdCapsule(pos ,leftK,leftH, .07));   \n    res = min(res, sdCapsule(pos ,leftE,leftHand, .05));\n    res = min(res, sdCapsule(pos ,leftE,leftS, .06));\n    res = min(res, sdCapsule(pos ,torso,leftS, .08));\n    \n    res = smin(res, sdSphere(pos - torso, .14),0.025);\n    res = smin(res, sdSphere(pos - pelvis, .16),0.025);\n    \n    res = smin(res, sdCapsule(pos ,pelvis,torso, .13),0.025);\n\tres = min(res, sdCapsule(pos ,head,torso, .02)); \n    \n    \n    \n    if(PLOTPATH>0)for(int i=PLOTPATH;i>-PLOTPATH/2;i--)\n\n    {\n        res = min(res, sdSphere(pos- timefly(iTime+float(i)*0.5), .04));\n    \n       \n        \n}  \n  \n        \n \n    \n     //float x=iTime;\n\t // res= min(res, sdCapsule( pos, timefly(x),timefly(x+1.) , .06125));\n\t // res= min(res, sdCapsule( pos, timefly(x)-perpr*-0.25,timefly(x)-perpl*0.25 , .06125));\n\treturn vec2(res, 2.0);\n}\nvec2 map( in vec3 pos) {\n\tvec2 res = vec2(pos.y-pathterrain(pos.x,pos.z), 1.0);\n\tres = opU(res, bodyPlan(pos));\n\treturn res;\n}\nvec2 castRay( in vec3 ro, in vec3 rd) {\n\tfloat tmin = 1.0;\n\tfloat tmax = 30.0;\n\tfloat t = tmin;\n\tfloat m = -1.0;\n\tfor (int i = 0; i < 80; i++) {\n\t\tfloat precis = 0.0001 * t;\n\t\tvec2 res = map(ro + rd * t);\n\t\tif (res.x < precis || t > tmax) break;\n\t\tt += res.x * .7;\n\t\tm = res.y;\n\t}\n\tif (t > tmax) m = -1.0;\n\treturn vec2(t, m);\n}\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor (int i = 0; i < 32; i++) {\n\t\tfloat h = map(ro + rd * t).x;\n\t\tres = min(res, 8.0 * h / t);\n\t\tt += clamp(h, 0.02, 0.10);\n\t\tif (res < 0.005 || t > tmax) break;\n\t}\n\treturn clamp(res, 0.0, 1.0);\n}\nvec3 calcNormal( in vec3 pos) {\n\tvec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n\treturn normalize(e.xyy * map(pos + e.xyy).x +\n\t\te.yyx * map(pos + e.yyx).x +\n\t\te.yxy * map(pos + e.yxy).x +\n\t\te.xxx * map(pos + e.xxx).x);\n}\nfloat calcAO( in vec3 pos, in vec3 nor) {\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor (int i = 0; i < 5; i++) {\n\t\tfloat hr = 0.01 + 0.12 * float(i) / 4.0;\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = map(aopos).x;\n\t\tocc += -(dd - hr) * sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox2( in vec2 p) {\n\t// filter kernel\n\tvec2 w = fwidth(p) + 0.001;\n\t// analytical integral (box filter)\n\tvec2 i = 2.0 * (abs(fract((p - 0.5 * w) * 0.5) - 0.5) - abs(fract((p + 0.5 * w) * 0.5) - 0.5)) / w;\n\t// xor pattern\n\treturn 0.5 - 0.5 * i.x * i.y;\n}\nfloat checkersGradBox( in vec2 p) {\n \n\treturn  checkersGradBox2(p) -checkersGradBox2(p-0.03 )*0.4 ;\n}\nvec3 render( in vec3 ro, in vec3 rd) {\n\tvec3 col = vec3(0.7, 0.9, 1.0) + rd.y * 0.8;\n\tvec2 res = castRay(ro, rd);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\tif (m > -0.5) {\n\t\tvec3 pos = ro + t * rd;\n\t\tvec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect(rd, nor);\n\t\t// material        \n\t\tcol = 0.45 + 0.35 * sin(vec3(0.05, 0.08, 0.10) * (m - 1.0));\n\t\tif (m < 1.5) {\n\t\t\tfloat f = checkersGradBox(1.2 * pos.xz);\n\t\t\tcol = 0.3 + f * vec3(0.3);\n\t\t}\n\t\tif (m >= 2.0) {\n\t\t\tcol = vec3(0.6);\n\t\t}\n\t\tif (m >= 3.0) {\n\t\t\tcol = vec3(0.07);\n\t\t}\n\t\t// lighting        \n\t\tfloat occ = calcAO(pos, nor);\n\t\tvec3 lig = normalize(vec3(0.2, 0.7, 0.6));\n\t\tvec3 hal = normalize(lig - rd);\n\t\tfloat amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n\t\tfloat dif = clamp(dot(nor, lig), 0.0, 1.0);\n\t\tfloat bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0);\n\t\tfloat dom = smoothstep(-0.1, 0.1, ref.y);\n\t\tfloat fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0);\n\t\tdif *= calcSoftshadow(pos, lig, 0.02, 2.5);\n\t\tdom *= calcSoftshadow(pos, ref, 0.02, 2.5);\n\t\tfloat spe = pow(clamp(dot(nor, hal), 0.0, 1.0), 16.0) *\n\t\t\tdif *\n\t\t\t(0.04 + 0.96 * pow(clamp(1.0 + dot(hal, rd), 0.0, 1.0), 5.0));\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 1.30 * dif * vec3(1.00, 0.80, 0.55);\n\t\tlin += 0.20 * amb * vec3(0.40, 0.60, 1.00) * occ;\n\t\tlin += 0.20 * dom * vec3(0.40, 0.60, 1.00) * occ;\n\t\tlin += 0.30 * bac * vec3(0.25, 0.25, 0.25) * occ;\n\t\tlin += 0.35 * fre * vec3(1.00, 1.00, 1.00) * occ;\n\t\tcol = col * lin;\n\t\tcol += 10.00 * spe * vec3(1.00, 0.90, 0.70);\n\t\tcol = mix(col, vec3(0.8, 0.9, 1.0), 1.0 - exp(-0.0002 * t * t * t));\n\t}\n\treturn vec3(clamp(col, 0.0, 1.0));\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr) {\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr), 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\treturn mat3(cu, cv, cw);\n}\n\n\n\n\n\nvoid setup() {\n\tfloat x = iTime   ;//Time manipulations moved to timefly\n      \n    \n    // filter gait slightly for less stabby foot placement, too much generates skating\n    float filt=18.;\n\tfloat left = 0.025+ mix(pasaR(floor(x*filt)/filt) ,pasaR(ceil(x*filt)/filt), ( fract(x*filt)));\n\tfloat right =0.025+ mix(pasaL(floor(x*filt)/filt) ,pasaL(ceil(x*filt)/filt), ( fract(x*filt)));\n\t\n    \n    float ahead=1.1;\n    vec3 dif = (timefly(x + ahead) - timefly(x))/ahead; //delta x+1\n\tfloat speed = length(dif); \n     ahead = clamp(0.8,1.1,1.3-speed);\n     dif = (timefly(x + ahead) - timefly(x))/ahead; //delta x+1\n\t speed = length(dif); \n    \n    \n    \n    vec3 nextdif = (timefly(x + ahead+.5) - timefly(x + .5))/ahead; \n\tvec3 lean = (nextdif - dif*2.); // bank into turns\n\n    //\n      ahead=speed;\n      dif = (timefly(x + ahead) - timefly(x))/ahead; //delta x+1\n\t  nextdif = (timefly(x + ahead+.5) - timefly(x + .5))/ahead; \n\t  lean = (nextdif - dif*2.); // bank into turns\n\n     \n    \n\tfloat nextSpeed = length(timefly(x + 1.2) - timefly(x + .2));\n   \n\n\n    vec3 dir = normalize(dif); //Path direction \n    vec3 nextdir = normalize(nextdif); //Path direction \n\tvec3 dirr = normalize(timefly(right + 1.) - timefly(right)); //Path direction Foot specific\n\tvec3 dirl = normalize(timefly(left + 1.) - timefly(left));\n    \n\tvec3 perp = cross(dir,vec3(0,-1,0));// perpendicular to main path\n\tvec3 perpl = cross(dirl,vec3(0,-1,0));// perpendicular to intervalled step path\n\tvec3 perpr = cross(dirr,vec3(0,-1,0));\n    \n    target =(timefly(x+1.5))\n               \n            +(vec3(0,.4,0)+lean*1.6+dir*0.25 )*(.09/clamp(speed , 0.05, 4.5));// rolling head\n\n       \n    target.y=pathterrain(target.x,target.z);// fix for rolling head collision \n    \n    target +=\n        +( vec3(0,0.14+abs(sin(x*7.)*0.3),0)) ;\n  \n      \n    vec3 tfx= timefly(x)  ; // Pelvis   path\n    vec3 tfr= timefly(right) ;//intervalled step path\n    vec3 tfl= timefly(left) ; //intervalled step path\n    \n    // foot lift component\n\tvec3 leftlift = vec3(0, min(0., sin(x * TAU + 1.57) * footlift * clamp(speed, 0.05, 1.5)), 0);\n\tvec3 rightlift = vec3(0, min(0., sin(x * TAU - 1.57) * footlift * clamp(speed, 0.05, 1.5)), 0);\n \n    \n    // setup targets\n\trightFootT = tfr + perpr * -0.16 - rightlift;\n\tleftFootT = tfl + perpl * 0.16 - leftlift;\n    rightToeT = tfr  + perpr * -0.19  +dir*0.172 - rightlift*0.6;\n\tleftToeT = tfl  + perpl * 0.19  +dir*0.172- leftlift*0.7;\n    // ground collision feet and toes\n    rightFootT.y=max(pathterrain(rightFootT.x,rightFootT.z),    rightFootT.y);\n    leftFootT.y=max(pathterrain(leftFootT.x,leftFootT.z),    leftFootT.y);\n    rightToeT.y=max(pathterrain(rightToeT.x,rightToeT.z),    rightToeT.y);\n    leftToeT.y=max(pathterrain(leftToeT.x,leftToeT.z),    leftToeT.y);\n    \n    \n\n    \n    \n\tpelvis = tfx \n        + (lean  ) * clamp(nextSpeed, 0.01, .5) * 0.1 // lean into turn\n        + vec3(0, .9 + cos(x * TAU * 2.) * 0.02 * speed, 0) // bob u/d with step\n\t\t+ dir * 0.1 * (-0.45 + speed) // lean in to run\n\t\t+ perpr * sin(x * TAU) * 0.025 * speed // bob l/R with step\n \t\t+ (vec3(0,-1.,0) )*(.02/clamp(speed , 0.15, 4.5))// bend when head is close\n;\n    // spine component\n\tvec3 spine = normalize(\n\t\t (lean  ) * clamp(nextSpeed, 0.2, .5) * 0.1 // lean into turn\n\t\t+ vec3(0, 0.3 + cos(x * TAU * 2.) * 0.0125 * speed, 0)// bob u/d with step\n\t\t+ dir * 0.05 * (-0.25 + nextSpeed)  // lean in to run\n        +(vec3(0,-1.,0)+dir)*(.05/clamp(speed , 0.15, 4.5))// bend when head is close\n        + perpr * cos(x * TAU) * 0.025 * speed// bob l/R with step\n\t);\n     \n    torso = pelvis + spine * 0.3;\n    \n    \n\n\t// Hips\n    rightH = pelvis + perp * -0.11 - rightlift * 0.1 - spine * 0.08 + dir * -0.025;\n\tleftH = pelvis + perp * 0.11 - leftlift * 0.1 - spine * 0.08 + dir * -0.025;\n    \n    // Feet\n\trightFoot = rightH + normalize(rightFootT - rightH) * min(legmax, length(rightFootT - rightH));\n\tleftFoot = leftH + normalize(leftFootT - leftH) * min(legmax, length(leftFootT - leftH));\n\t\n    rightToe = rightH + normalize(rightToeT - rightH) * min(toemax, length(rightToeT - rightH));\n\tleftToe = leftH + normalize(leftToeT - leftH) * min(toemax, length(leftToeT - leftH));\n    \n    // Shoulder\n\trightS = torso + perp * -0.2   + spine * 0.05;\n\tleftS = torso + perp * 0.2  + spine * 0.05;\n    \n    // Hand Target\n    rightHandT=(rightS +  normalize(\n\t\t\t+perpr * -0.06 \n\t\t\t+vec3(0, -0.4, 0) \n\t\t\t+dir * 0.3 * cos(.25 + x * TAU) * (clamp(speed, 0.0, 2.) * 0.25)\n \t\t\t) \n            * armmax \n\t\t\t+vec3(0, 0.2, 0) * clamp(speed - 0.6, 0., 1.) )// lift alittle with speed\n        \t+( target -rightS)*(1.-smoothstep(0.,1.2,(1.+sin(x*1. ))))*0.3;// reach for head \n    \n     leftHandT= (leftS + normalize(\n\t\t\tperpl * 0.06 +\n\t\t\tvec3(0, -0.4, 0) +\n\t\t\tdir * 0.3 * cos(.25 + PI + x * TAU) * (clamp(speed, 0.0, 2.) * 0.25)\n \t\t) * armmax +\n\t\tvec3(0, 0.2, 0) * clamp(speed - 0.6, 0., 1.))\n       +( target -leftS)*(1.-smoothstep(0.,1.2,(1.+sin(x*1.+PI))))*0.3;\n    \n       rightHand = rightS + normalize(rightHandT - rightS) * min(armmax, length(rightHandT - rightS));\n       leftHand = leftS + normalize(leftHandT - leftS) * min(armmax, length(leftHandT - leftS));\n \t\n     \n        rightHand.y=max(pathterrain(rightHand.x,rightHand.z)+.2,    rightHand.y);\n    leftHand.y=max(pathterrain(leftHand.x,leftHand.z)+.2,    leftHand.y);\n \n    \n    \n\thead = torso +normalize(\n\t\tvec3(0, .27, 0) \n\t\t+ normalize(lean) * clamp(nextSpeed, 0.2, 1.) * 0.05 // lean into torn\n\t\t+dir * 0.1 * (-0.35 + clamp(speed, 0.5, 2.)) // lean into run\n\t\t+perpr * cos(x * TAU) * 0.025 * clamp(speed, 0.5, 2.)\n        +(vec3(0,-1.,0)+dir)*(.07/clamp(speed , 0.05, 4.5))// bend when head is close\n\n       )*0.27;// sway with step\n    \n    // bendy lims IK\n    \n\trightE = mix(rightS, rightHand, 0.5) - cross(rightS - rightHand, -normalize(perp - dir * 0.5)) *\n\t\tsqrt(max(0.0001, arm * arm - length(rightS - rightHand) * length(rightS - rightHand))) * 0.5;\n\tleftE = mix(leftS, leftHand, 0.5) - cross(leftS - leftHand, -normalize(perp + dir * 0.5)) *\n\t\tsqrt(max(0.0001, arm * arm - length(leftS - leftHand) * length(leftS - leftHand))) * 0.5;\n\trightK = mix(rightH, rightFoot, 0.5) - cross(rightH - rightFoot, normalize(perp + dir * 0.25)) *\n\t\tsqrt(max(0.0001, leg * leg - length(rightH - rightFoot) * length(rightH - rightFoot))) * 0.5;\n\tleftK = mix(leftH, leftFoot, 0.5) - cross(leftH - leftFoot, normalize(perp - dir * 0.25)) *\n\t\tsqrt(max(0.0001, leg * leg - length(leftH - leftFoot) * length(leftH - leftFoot))) * 0.5;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tsetup();\n\tvec2 mo = iMouse.xy / iResolution.xy;\n\tfloat time = .0 + iTime;\n\tvec3 tot = vec3(0.0);\n #\tif AA > 1\n\tfor (int m = 0; m < AA; m++)\n\t\tfor (int n = 0; n < AA; n++) {\n\t\t\t// pixel coordinates\n\t\t\tvec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n\t\t\tvec2 p = (-iResolution.xy + 2.0 * (fragCoord + o)) / iResolution.y;\n # else\n\t\t\t\tvec2 p = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n # endif\n\t\t\t// camera\t\n\t\t\tvec3 ta = timefly(time) + vec3(0, 0.7, 0);\n\t\t\tvec3 ro = ta + vec3(-0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x),\n\t\t\t\t2.0 + 2.0 * mo.y,\n\t\t\t\t0.5 + 4.0 * sin(0.1 * time + 6.0 * mo.x));\n\t\t\t// camera-to-world transformation\n\t\t\tmat3 ca = setCamera(ro, ta, 0.0);\n\t\t\t// ray direction\n\t\t\tvec3 rd = ca * normalize(vec3(p.xy, 2.5));\n\t\t\t// render\t\n\t\t\tvec3 col = render(ro, rd);\n\t\t\t// gamma\n\t\t\tcol = pow(col, vec3(0.4545));\n\t\t\ttot += col;\n # if AA > 1\n\t\t}\n\ttot /= float(AA * AA);\n #\tendif\n\tfragColor = vec4(tot, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3tXSD7",
    "date": "0",
    "viewed": 0,
    "name": "Raymarching rocks",
    "description": "Fragmented rocks",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "procedural",
     "3d",
     "raymarching",
     "distancefields",
     "primitives"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Raymarching - Primitives\" by iq. https://shadertoy.com/view/Xds3zN\n// 2019-07-14 16:26:22\n\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    \n\n// A list of useful distance function to simple primitives. More info here:\n//\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#define AA 2   // make this 2 or 3 for antialiasing\n\n#define ZERO= 0*int(iTime)\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n \nvec2 map( in vec3 x )\n{\n     \n   x= vec3(x.x+sin(x.x)*0.5,x.y ,x.z); \n   x= vec3(x.x+sin(x.y)*0.15,x.y ,x.z); \n   x= vec3(x.x+sin(x.z)*0.15,x.y ,x.z); \n \n\n    vec3 p = floor( x );\n    vec3 c = p+0.5;\n    vec3 f = fract( x ) -vec3(.5);\n\n     float d=sdSphere(x,2.2);\n    \n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n \n        if( sdCapsule(c+b,vec3(-2.),vec3(2.),0.) < 3.)\n        { d=min(d, sdBox(f-b, vec3 (0.49) ) );\t\t\t\n        }\n        \n    }\n\n    return vec2(  ( d ),  (26.) );\n}\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 0.0;\n    float tmax = 200.0;\n\n    // raytrace floor plane\n    //float tp1 = (0.0-ro.y)/rd.y;\n    //if( tp1>0.0 )\n    //{\n     //   tmax = min( tmax, tp1 );\n      //  res = vec2( tp1, 1.0 );\n   // }\n    //else return res;\n    \n    // raymarch primitives   \n   // vec2 tb = iBox( ro-vec3(0.5,0.4,-0.5), rd, vec3(8.0,8.41,8.0) );\n   // if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n      //  tmin = max(tb.x,tmin);\n      //  tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<170 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.00001*t) )\n            { \n                res = vec2(t,h.y); \n                 break;\n            }\n            t += h.x*0.5;\n        }\n    }\n    \n    return res;\n}\n\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0 ; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 1\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    vec2 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n\t\tcol = 0.2 + 0.18*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n        //col = vec3(0.2);\n        col = 0.2 + 0.18*sin( m*2.0 + vec3(0.0,0.5,1.0) );\n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 5.0*pos.xz, 5.0*dpdx.xz, 5.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n\t\tvec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n        vec3  hal = normalize( lig-rd );\n\t\tfloat amb = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n        float dom = smoothstep( -0.2, 0.2, ref.y );\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        \n        //dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n        //dom *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n\n\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)*\n                    dif *\n                    (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));\n\n\t\tvec3 lin = vec3(0.0);\n        lin += 3.80*dif*vec3(1.30,1.00,0.70);\n        lin += 0.55*amb*vec3(0.40,0.60,1.15)*occ;\n        lin += 0.85*dom*vec3(0.40,0.60,1.30)*occ;\n        lin += 0.55*bac*vec3(0.25,0.25,0.25)*occ;\n        lin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n\t\tcol += 7.00*spe*vec3(1.10,0.90,0.70);\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ro = vec3( 0.5+8.5*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, -0.5+8.5*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0.5, -0.4, -0.5 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.0) );\n\n         // ray differentials\n        vec2 px = (-iResolution.xy+2.0*(fragCoord.xy+vec2(1.0,0.0)))/iResolution.y;\n        vec2 py = (-iResolution.xy+2.0*(fragCoord.xy+vec2(0.0,1.0)))/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,2.0) );\n        vec3 rdy = ca * normalize( vec3(py,2.0) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    \n    fragColor = vec4( tot, 1.0 );\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tdV3Dd",
    "date": "1571250748",
    "viewed": 84,
    "name": "Root branching pattern",
    "description": "couldn't find it so i made it",
    "likes": 7,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "fork",
     "branch"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": " \nfloat fu2(vec2 uv) {\n    uv.y = max(uv.y, (abs(pow(uv.y, 1.68))));\n    float y = fract(uv.y);\n    float ym = mod(floor(uv.y), 2.);\n    float o = pow(2., floor(uv.y));\n    float x = fract(ym + (uv.x * o) + o) - 0.5;\n    float p = (1. - abs(abs(x) - smoothstep(0., 1., y) * 0.25));\n    p = mix(p, p * p, y * 1.333);\n    return ((p));\n}\nvec3 fu(vec2 uv) {\n    return (vec3((fu2(uv) + abs(.15 / (uv.y - 0.5)))));\n}\nvec2 pR(inout vec2 p, float a) {\n    return cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.x - vec2(0.5, 0.15);\n    uv *= 13. + sin(iTime) * 5.;\n    uv += vec2(sin(iTime * .17) * 2., cos(iTime * .13) * 2.);\n    vec3 col;\n    if (mod(iTime, 30.) < 25.) {\n            uv = pR(uv, sin(iTime * 0.1) * 4.);\n\n        col = vec3(\n            fu(vec2(atan(uv.y, uv.x) / 6.28 * (floor(5.+sin(iTime*0.4)*3.)),\n                0.6 * length(uv) + .65\n            ))\n        );\n        col=col/ max(1., length(uv * .28));\n    } else {\n        col = fu(uv);\n              \n\n    }\n    col*=0.75;\n    col = smoothstep(0., 1., col * col* col) ;\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3ttXWf",
    "date": "0",
    "viewed": 0,
    "name": "Snake scales3",
    "description": "visual experiment",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "circles",
     "lines",
     "vector"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Snake scales\" by avin. https://shadertoy.com/view/tt3SDf\n// 2020-02-16 15:22:23\n\n#define SIZE 15.0\n#define COL1 vec3(32, 43, 51) / 255.0\n#define COL2 vec3(235, 241, 245) / 255.0\n\n#define SF 1. / min(iResolution.x, iResolution.y) * SIZE * .5\n#define SS(l, s) smoothstep(SF, -SF, l - s)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;\n    float ssf = SF * iResolution.y * .004;\n\n    uv *= SIZE;\n    vec2 id = floor(uv);\n    uv = fract(uv) - 0.5;\n\n    float mask = 0.0;\n    float rmask = 0.0;\n\n    for (int k = 0; k < 9; k++) {\n        vec2 P = vec2(k % 3, k / 3) - 1.;\n        vec2 rid = id - P;\n        vec2 ruv = uv + P + vec2(0, mod(rid, 2.) * .5) ;\n\n        float l = length(ruv);\n\n        float d = SS(l, .75) * (ruv.y + 1.);\n\n        mask = max(mask, d);\n        if (d >= mask) {\n            mask = d;\n            rmask = SS(abs(l - .65), SF * iResolution.y * .007);\n        }\n    }\n\n    vec3 col = mix(COL1, COL2, rmask);\n\n    fragColor = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WdX3Wn",
    "date": "1545846691",
    "viewed": 108,
    "name": "Swirly Gabor and more",
    "description": "Fascinated with Gabor noise i wondered what i would look like with swirly patches.\nsome results were lovely but far too expensive.\nwork in progress.",
    "likes": 2,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "noise",
     "gabor",
     "patches"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "Xtl3zN",
       "filepath": "https://soundcloud.com/mindpersuasion/sub-delta-with-underwater-sounds-perfect-for-meditation?in=bill-shannon-1/sets/hypnosis-binaural-nature",
       "type": "musicstream",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 0
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define OCTAVES 2\n#define PI 3.14159265359\n \n \n\nvec2 hash2( vec2 p ) \n{  \t\t\t\t\t\t\n\tp = vec2(dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)));\n    \n\treturn -1.0 + 2.0 * fract(sin(p + 20.0) * 53758.5453123);\n}\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)), \n\t\t\t\t   dot(p,vec2(419.2,371.9)) );\n\t\t\t\t   \n\treturn fract(sin(q)*43758.5453);\n}\n\n\n\nfloat PerlinGradientNoise(in vec2 p)\n{\n\tvec2 i = floor(p);\n\tvec2 f = fract(p);\n    \n    //grid points\n    vec2 p0 = vec2(0.0, 0.0);\n    vec2 p1 = vec2(1.0, 0.0);\n    vec2 p2 = vec2(0.0, 1.0);\n    vec2 p3 = vec2(1.0, 1.0);\n    \n    //distance vectors to each grid point\n    vec2 s0 = f - p0;\n    vec2 s1 = f - p1;\n    vec2 s2 = f - p2;\n    vec2 s3 = f - p3;\n    \n    //random gradient vectors on each grid point\n    vec2 g0 = hash2(i + p0);\n    vec2 g1 = hash2(i + p1);\n    vec2 g2 = hash2(i + p2);\n    vec2 g3 = hash2(i + p3);\n    \n    //gradient values\n    float q0 = dot(s0, g0);\n    float q1 = dot(s1, g1);\n    float q2 = dot(s2, g2);\n    float q3 = dot(s3, g3);\n    \n    //interpolant weights\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    \n    //bilinear interpolation\n    float l0 = mix(q0, q1, u.x);\n    float l1 = mix(q2, q3, u.x);\n    float l2 = mix(l0, l1, u.y);\n    \n    return l2;\n}\n\nfloat SimplexNoise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\n\tvec3 n = h*h*h*h*vec3( dot(a,hash2(i+0.0)), dot(b,hash2(i+o)), dot(c,hash2(i+1.0)));\n\n    return dot( n, vec3(70.0) );\n\t\n}\n\n\nfloat Voronoise( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\t\n\tfloat k = 1.0+63.0*pow(1.0-v,4.0);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.414,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return va/wt;\n}\n\nfloat gauss(float x, float s) {\n    return exp(-.5*(x*x)/(s*s)); \n}\nfloat gauss(float x) {\n    return exp(-.5*x*x); \n}\nfloat gauss(float s,vec2 D) {\n\tfloat d = dot(D,D)/(s*s);\n\treturn exp(-.5*d); \n}\n\n#define SQR(x) ((x)*(x))\n\n\nfloat gabor(vec2 pos, vec2 k, float gaussF, float phi) {\n\tfloat g = gauss(length(pos), 1./gaussF);\n    float s = clamp ( -1.,1.,.5* sin(2.*PI*dot(pos,k) - phi));\n \n\treturn  (g* s);\n}\nfloat swirlgabor(vec2 pos, vec2 k, float gaussF, float phi) {\n    float p=  length(pos) ;\n    float g = gauss(p, 1./gaussF);\n  float a=  atan(k.y,k.x)+( sin(0.35*phi))*6.28*min(gaussF*0.5, p) ;\n  //        float a=  atan(k.y,k.x)+ sin(0.35*phi)*3.5*6.28/ (max(.01, p)*174.) ;\n\n    vec2 k2=vec2(sin(a),cos(a))*length(k);\n    float s = clamp ( -1.,1.,.5* sin(2.*PI*dot(pos,k2) - phi));\n \n\n\treturn  (g* s);\n}\n\nfloat polargabor(vec2 pos, vec2 k, float gaussF, float phi) {\n\tfloat g = gauss(length(pos), 1./gaussF);\n    float s = clamp ( -1.,1., sin( length(pos)*2.*PI*  max(k.x,k.y) - phi) );\n \n\treturn  (g* s);\n}\n\nfloat Gabornoise( in vec2 point, float Freq, float GAUSS_F ,float SCALE,float ANGLE,float Phi, float Spread)\n{\n    \n\t\t \n    \n    vec2 p = floor(point);\n    vec2 f = fract(point);\n\t\t\n \tfloat vS;\n\tfloat vF;\n   int area=2;// kernel size. min 2 more the better\n    for( int j=-area; j<=area; j++ )\n    for( int i=-area; i<=area; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n\t\tvec3 o = hash3( p + g ) + hash3( vec2(1000) +p + g ) ;\n\t\tvec3 co =  hash3( vec2(100) +p + g )  + hash3( vec2(553) +p + g ) ;\n\t\tvec3 oa = vec3(fract(PerlinGradientNoise(vec2(p+g) *0.1))*2.*PI,Voronoise(vec2(p+g)*.2 ,1.,1.),PerlinGradientNoise(vec2(p+g)*.2) );\n   // adding a second hash paches some ugly holes along x==y line\n        vec3 on=normalize(o);\n\t\tvec2 pos = p+g+ vec2(.5)  + (o.xy-0.5)*2.*(0.5-0.5/GAUSS_F);// paches within cell is restricted by its size\n\t\tvec2 cpos = p+g+ vec2(.5)  + (co.xy-0.5)*2.*(0.5-0.5/GAUSS_F);// paches within cell is restricted by its size\n\t\tvec2 Rk =  (o.xy-0.5)*PI*2.*Spread ;\n \n    \t\t// random sample within angular spread\n\t  float suma=(floor( ((ANGLE+Rk.x)/(2.*PI))*12.)/12.)*(2.*PI);\n\n\t\t// signal space:  white := Poisson point distrib -> sum random pos\n \t//\t   vS +=    gabor( SCALE*(point-pos), vec2(sin(ANGLE+oa.x+Rk.x),cos(ANGLE+oa.x+Rk.x))*Freq  , GAUSS_F,Phi);\n \t\t  //  vS +=    gabor( SCALE*(point-(p+g )), vec2(sin(suma),cos(suma))*Freq  , GAUSS_F,0.);\n \t\t vS +=    swirlgabor(   SCALE*(point-cpos), vec2(sin(ANGLE+oa.x+Rk.x),cos(ANGLE+oa.x+Rk.x))*(Freq+oa.y*3.5) , GAUSS_F,-Rk.x+Phi*oa.z);\n \t\t //  vS += 0.25 *  polargabor( SCALE*(point-cpos), vec2(sin(ANGLE+Rk.x),cos(ANGLE+Rk.x))*(Freq+oa.y*10.5)*0.125  ,  GAUSS_F,Phi*oa.z);\n \n    \n    \n    \n    }\n    //\tvF *= max(1., length(k)*2.*A/(PI*GAUSS_F)) /float(NB); // normalization\n\tvS =  (vS*sqrt(1.*GAUSS_F)+1.)/2.;\n\t\n    return vS;\n}\n\n\nfloat Spotnoise( in vec2 point,float R,float Phase)\n{\n    \n\t\t \n    \n    vec2 p = floor(point);\n    vec2 f = fract(point);\n\t\t\n \tfloat vS=0.;\n    int area=1;// kernael size. min 2 more the better\n    for( int j=-area; j<=area; j++ )\n    for( int i=-area; i<=area; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) );\n        vec3 id = + hash3( vec2(1000) +p + g  )+ hash3(  p + g  );\n        float fid=   (id.x*id.z*id.y);\n\t  vec3 o=vec3(sin(Phase+fid*4787.),cos(Phase+fid*9239.),sin(Phase+fid*2533.))*1.*sin(Phase+fid*2903.);\n   // adding a second hash paches some ugly holes along x==y line\n        vec3 on=normalize(o);\n\t\tvec2 pos = p+g+ vec2(.5)  + (o.xy-0.5)*2.*0.25 ;// paches within cell is restricted by its size\n  \n    \t\t// random sample within angular spread\n\t \n\n\t\t// signal space:  white := Poisson point distrib -> sum random pos\n \t\tvS =max(vS,   abs(length( point-pos)) <R?smoothstep(0.51,.0,length( point-pos)/R):0.  ); \n \n    \n    \n    \n    }\n    //\tvF *= max(1., length(k)*2.*A/(PI*GAUSS_F)) /float(NB); // normalization\n    //\tvS =  (vS*sqrt(1.*3.)+1.)/2.;\n\t\n    return vS  ;\n}\n\nfloat Remap( float _f, float _min, float _max )\n{\n    return (_f - _min)/ (_max - _min);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \tvec2 uv = (fragCoord.xy-iResolution.xy*0.5) / iResolution.xx;\n\n   // vec2 p = 0.5 - 0.5*sin( iTime*vec2(1.01,1.71) );\n\n float  freq = 37.+(sin(iTime*.8397))*.5  ;\n      // float  freq = (sin(10.)+1.1)/2.*100.  ;\n    \n    float s;\n\tfloat f = 0.0;\n\n    #if OCTAVES == 1\n    \tfloat amplitude = 1.0;\n\t#else\n    \tfloat amplitude = 0.5;\n    #endif\n    \n   \n    for( int i=0 ; i < OCTAVES ; ++i )\n    {\nfloat o=float(i)*10.;\n     \n       /* if( int(floor( mod(float(i),3.)) ) ==10 )\n    \n        {\n            s = PerlinGradientNoise( uv * freq );\n            s = Remap( s, -0.6, 0.6 );\n        }\n        else   if(   int(floor( mod(float(i),13.)) )==20)\n\n        {\n            s = SimplexNoise( uv * freq   );\n             s = Remap( s, -0.9, 0.9 );\n        }\n        else if(   int(floor( mod(float(i),13.)) )==11)\n        {\n            s = Voronoise( uv * freq  , 1.0, 1.0 );\n       \n        }\n \n        \n        else  if(   int(floor( mod(float(i),13.)) )==10)\n        {\n\n \n            s = Spotnoise( uv * freq  ,  \n                            .75  \n                          ,iTime+o) ;\n        \n         //   \t s =  smoothstep(-1.,1.,((s*s*s)-.5)*1.) ;\n         //\t  s =  smoothstep(-1.,1.,((s)-.5)*1.) ;\n         \n        }\n              else  */\n        {\n\n//float Gabornoise( in vec2 point, float Freq, float GAUSS_F ,float SCALE,float ANGLE,float Phi, float Spread)\n\n            s = Gabornoise( uv * freq  , \n                           6.+ sin(0.517*iTime+o)*.9,      //Freq\n                          5. + sin(iTime+o)*.5,        //Gauss   \n                           (.3950+ (sin(1.33*iTime+o )+1.)*0.25*.325) , //SCALE\n                           fract((0.035*iTime+o )*0.1)*PI*2. ,  //ANGLE\n                           iTime+o*2.  ,                              //Phase?\n                            (sin(1.17*iTime*.41+o)+1.)*0.5    // Spread\n                          );\n            \t//s =  smoothstep(-1.,1.,(s-.5)*6.) ;\n\n        }\n        \n        f += s * amplitude;\n        \n        freq *=  1.61803398875;\n        amplitude *=   0.61803398875;\n    } \n    f=f+sin(1.57+iTime*2.*.897)*+.06125;\n                 f =  smoothstep(-1.,1.,(f-.5)*(2.+sin(iTime*.534)*1.5)) ;\n    vec3 tint=  (vec3(\n                    SimplexNoise(vec2(iTime*0.14,-iTime*0.23)+ uv*freq/164. )*0.3,\n                    SimplexNoise(vec2(iTime*0.37,iTime*0.47)+uv.yx*freq/143. )*0.1,\n                    SimplexNoise(vec2(-iTime*0.23,iTime*0.33)+uv*freq/134.) *1.));\n    vec3 c=  (vec3(f)+tint *.2)*smoothstep(0.,1.,1./max(.2,  length(uv*freq*0.03) ));\n\tfragColor = vec4( c, 1.0 );\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WlfSDl",
    "date": "0",
    "viewed": 0,
    "name": "Texture composer",
    "description": "texture, synthesis",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "texture",
     "synthesis"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Fuzzy scratches\" by Daedelus. https://shadertoy.com/view/4syXRD\n// 2019-07-31 06:44:43\n\n// uniform float uWavyness;\n// uniform vec2 uScale;\n// uniform vec2 uOffset;\n// uniform int uLayers;\n// uniform vec2 uBaseFrequency;\n// uniform vec2 uFrequencyStep;\n#define uWavyness 0.0\n#define uScale vec2(3.0, 3.0)\n#define uOffset vec2(iTime, 0.0)\n#define uLayers 7\n#define uBaseFrequency vec2(0.5, 0.5)\n#define uFrequencyStep vec2(0.1, 0.1)\n\nvoid pR(inout vec2 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    p *= mat2(ca, sa, -sa, ca);\n}\n\nfloat scratch(vec2 uv, vec2 seed)\n{\n    seed.x = floor(sin(seed.x * 51024.0) * 3104.0);\n    seed.y = floor(sin(seed.y * 1324.0) * 554.0);\n \n    uv = uv * 2.0 - 1.0;\n    pR(uv, seed.x + seed.y);\n    uv += sin(seed.x - seed.y)*.25;\n    //uv =  (clamp(uv * 0.5 + 0.5, 0.0, 1.0) )  ;\n        uv+= (vec2(snoise(uv*3.),snoise(2.*uv+100.))-0.25)*0.2;\n\n     \n    \n    float x = sign(0.03 - abs(length(uv) - snoise(seed )*0.9 ));\n    return clamp(   x, 0.0, 1.0);\n}\n\nfloat layer(vec2 uv, vec2 frequency, vec2 offset, float angle)\n{\n    pR(uv, angle);\n    uv = uv * frequency + offset;\n    return scratch(fract(uv), floor(uv));\n}\n\nfloat scratches(vec2 uv)\n{\n    uv *= uScale;\n    uv += uOffset;\n    vec2 frequency = uBaseFrequency;\n    float scratches = 0.0;\n    for(int i = 0; i < uLayers; ++i)\n    {\n        float fi = float(i);\n    \tscratches  =max(scratches, layer(uv, frequency, vec2(fi, fi), fi * 3145.0));\n        frequency += uFrequencyStep;\n    }\n    return  ( scratches);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    \n    // using AA by Shane:\n    // https://www.shadertoy.com/view/4d3SWf\n    const float AA = 4.; // Antialias level. Set to 1 for a standard, aliased scene.\n    const int AA2 = int(AA*AA);\n    float col = 0.0;\n    vec2 pix = 2.0/iResolution.yy/AA; // or iResolution.xy\n    for (int i=0; i<AA2; i++){ \n\n        float k = float(i);\n        vec2 uvOffs = uv + vec2(floor(k/AA), mod(k, AA)) * pix;\n        col += scratches(uvOffs);\n    }\n    col /= (AA*AA);\n\t\n\tfragColor = vec4(col);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "vec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "3tlSDs",
    "date": "0",
    "viewed": 0,
    "name": "Texture synth",
    "description": "pattern play",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "2d",
     "texture",
     "pattern",
     "material"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "void pR(inout vec2 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    p *= mat2(ca, sa, -sa, ca);\n}\nvec2 pRr( vec2 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    p *= mat2(ca, sa, -sa, ca);\n    return p;\n}\n\nfloat band(vec2 uv){\nreturn  fract(   uv.y);\n\n}\n\nfloat spot(vec2 uv){\nreturn  length(fract(   uv)-0.5)*.7;\n\n}\n\nfloat sdArc( in vec2 p, in vec2 sca, in vec2 scb, in float ra, float rb )\n    \n{\n    p=fract( p) -0.5;\n    \n    p *= mat2(sca.x,sca.y,-sca.y,sca.x);\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n\nfloat xor(float a,float b){\nreturn 1. - (1. - a*(1.-b))*(1. - b*(1.-a)) ;\n    }\n\nfloat check(vec2 uv){\n    float sum=   (round(band(uv)*2.)/2.+round(band(uv.yx)*2. )/2. ) ;\nreturn       sum   ;\n\n}\n\nvec2 fold(vec2 uv )\n{\nuv-=0.5;\n    return(abs(uv));\n\n}\n\nfloat chevron(vec2 uv){\n    uv.y+=(abs(fract(uv.x)-0.5) );\n    uv.y=fract(uv.y);\nreturn band (uv);\n}\n\nfloat wave(vec2 uv){\n    uv.y+=((sin(uv.x*6.2831)*0.3) );\n    uv.y=fract(uv.y);\nreturn band (uv);\n}\n\n\nfloat arc(vec2 uv){\n    uv.y*=0.5;\n    float select=step(0.5,fract(uv.y));\n    uv.x+=select*.5;\n    uv.y*=2. ;\n    uv.y-=(abs(sin(.5*uv.x*6.2831)*0.3) );\n    uv.y=fract(uv.y -0.5);\nreturn band (uv*2.+vec2(0,.25)*select);\n}\n\nfloat spots(vec2 uv){\n    float select=step(0.5,fract(uv.y));\n    uv.x+=0.25*select; \n     uv*=2.;\n\nreturn spot (uv );\n}\n\nfloat lspots(vec2 uv){\n    //uv=fold(fract(uv ))+uv.y*-0.1+uv.x*-0.1;\n    float select=step(0.5,fract(uv.y));\n    uv.x+=0.25*select; \n     uv*=2.;\n    float r=(round(uv.x-0.5)+round(uv.y-0.5))*6.28*12.14;\n\n return sdArc (uv,vec2(sin(r),cos(r)), normalize(vec2(1.,-1)), 0.3,0.2 )/1.57;\n ;\n}\nvec2 disp(vec2 uv){\nreturn uv\n    + (fbm22(uv*3.)-0.5)*0.3\n    + (fbm22(uv*0.251)-0.5)*1.5\n     ;\n}\nstruct palette\n{ \n  vec3 a;\n  vec3 b;\n  vec3 c;\n  vec3 d;\n      };\npalette Sarcoline=  palette( vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\npalette Coquelicot= palette(   vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\npalette Smaragdine= palette(  vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\npalette Amaranth=   palette(  vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\npalette Glaucous=   palette(  vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\npalette Eburnean=   palette(   vec3( 0.5,0.1,0.2),vec3(1.,0.75,0.8),vec3(2.0,1.0,.90),vec3(0.2,0.20,0.25) );\npalette Fulvous=    palette(  vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    \n\nvec3 pal( in float t, palette p )\n{\n    return p.a + p.b*cos( 6.28318*(p.c*t+p.d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x -0.5; \n    \n \n      uv=    pRr(uv,iTime);\n     // Time varying pixel color\n    vec3 col = pal(lspots(disp(uv  *(sin(iTime)+2.)*7.)),Eburnean);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n vec3 hash31( vec2 p ){return hash33( vec3 (p,0) ); }\nfloat hash12( vec2 p ){return hash33( vec3 (p,0) ).x; }\n\n\n\n \n\nvec3 noise33(  vec3 p )\n{\n    p=p+10000.;\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u;\n    u.x = f.x*f.x*(3.0-2.0*f.x);\n    u.y = f.y*f.y*(3.0-2.0*f.y);\n    u.z = f.z*f.z*(3.0-2.0*f.z);\n\n    return mix( \n        mix(\n                mix( hash33( i + vec3(0.0,0.0,0.0) ), \n                     hash33( i + vec3(1.0,0.0,0.0) ), u.x),\n                mix( hash33( i + vec3(0.0,1.0,0.0) ), \n                     hash33( i + vec3(1.0,1.0,0.0) ), u.x)\n               , u.y),\n              mix(\n                mix( hash33( i + vec3(0.0,0.0,1.0) ), \n                     hash33( i + vec3(1.0,0.0,1.0) ), u.x),\n                mix( hash33( i + vec3(0.0,1.0,1.0) ), \n                     hash33( i + vec3(1.0,1.0,1.0) ), u.x)\n               , u.y)\n        \n         , u.z)\n        ;\n}\n\nvec2 noise22( vec2 p ){return noise33( vec3 (p,0) ).xy; }\nfloat noise12( vec2 p ){return noise33( vec3 (p,0) ).x; }\n\n\n\n\nvec3 fbm33( vec3 p )\n{\n   \n     mat3 m = mat3(vec3(0.80,  0.60, -0.6).xyz,\n                    vec3(0.80,  0.60, -0.6).yzx,\n                    vec3(0.80,  0.60, -0.6).zxy);\n    vec3 f = vec3(0.0);\n    f += 0.5000*noise33( p ); p = m*p*2.02;\n    f += 0.2500*noise33( p ); p = m*p*2.03;\n    f += 0.1250*noise33( p ); p = m*p*2.01;\n    f += 0.0625*noise33( p );\n    return f/0.9375;\n}\nvec2 fbm22( vec2 p ){return fbm33( vec3 (p,p.x*.348-p.y*0.213) ).xy; }\nfloat fbm12( vec2 p ){return fbm33( vec3 (p,0) ).x; }\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wsjyDD",
    "date": "0",
    "viewed": 0,
    "name": "Tileable tiles",
    "description": "A tileable cell texture creator for games, or anything else that needs tiling.\nSnazzy water caustic animations left out for clarity! ;)\n",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "voronoi",
     "worley",
     "tiling",
     "cell",
     "tileablecells"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "Xsf3zn",
       "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [],
     "code": "// Fork of \"Tileable Cells\" by Dave_Hoskins. https://shadertoy.com/view/4djGRh\n// 2020-04-12 15:38:19\n\n// Tileable Cells. By David Hoskins. 2013.\n\n#define NUM_CELLS\t8.0\t// Needs to be a multiple of TILES!\n#define TILES \t\t1.0\t\t// Normally set to 1.0 for a creating a tileable texture.\n\n//#define SHOW_TILING\t\t\t// Display yellow lines at tiling locations.\n#define ANIMATE\t\t\t// Basic movement using texture values.\n\n//------------------------------------------------------------------------\nvec2 Hash2(vec2 p)\n{\n\t#ifdef ANIMATE\n\t\n\tfloat t = fract(.0003);\n\treturn texture(iChannel0, p*vec2(.135+t, .2325-t), -100.0).xy;\n\t\n\t#else\n\t\n\tfloat r = 523.0*sin(dot(p, vec2(53.3158, 43.6143)));\n\treturn vec2(fract(15.32354 * r), fract(17.25865 * r));\n\t\n\t#endif\n}\n\n//------------------------------------------------------------------------\nfloat Cells(in vec2 p, in float numCells)\n{\n\tp *= numCells;\n\tfloat d = 1.0e10;\n\t\t\tvec2 tp = floor(p) ;\n\t\t\ttp = fract(p )- Hash2(tp)*0.8 ;\n\t\t\td = length(tp);\n\treturn  (d);\n\t//return 1.0 - d;// ...Bubbles.\n}\n\n//------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t#ifdef ANIMATE\n\tfloat c = Cells(uv+iTime*.025, NUM_CELLS);\n\t#else\n\tfloat c = Cells(uv, NUM_CELLS);\n\t#endif\n\n\tvec3 col = round(vec3(1.-((1.-c)*(1.-c)*(1.-c)*(1.-c)*(1.-c)*(1.-c)*(1.-c))));\n\t\n\t#ifdef SHOW_TILING\n\t// Flash tile borders...\n\tvec2 pixel = TILES / iResolution.xy;\n\tuv *= TILES;\n\n\tfloat f = floor(mod(iTime*.5, 2.0)); \t// Flash value.\n\tvec2 first = step(pixel, uv) * f;\t\t   \t// Rule out first screen pixels and flash.\n\tuv  = step(fract(uv), pixel);\t\t\t\t// Add one line of pixels per tile.\n\tcol = mix(col, vec3(1.0, 1.0, 0.0), (uv.x + uv.y) * first.x * first.y); // Yellow line\n\t\n\t#endif\n\n\tfragColor = vec4(col, 1.0);\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wlBSRD",
    "date": "1569272315",
    "viewed": 47,
    "name": "W Tile",
    "description": "procedural texture",
    "likes": 5,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "procedural",
     "texturesynth"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "//  1 out, 2 in...\nfloat hash12(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * .1031);\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n///  2 out, 2 in...\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n\treturn fract((p3.xx + p3.yz) * p3.zy);\n\n}\n\nvec3 pal( in float t) {\n\tvec3 pa = vec3(0.5, 0.5, 0.5);\n\tvec3 pb = vec3(0.5, 0.5, 0.5);\n\tvec3 pc = vec3(1.0, 1.0, 1.0);\n\tvec3 pd = vec3(0.3, 0.20, 0.20);\n\treturn pa + pb * cos(6.28318 * (pc * t + pd));\n}\n\nvec3 getTileData(vec2 uv) {\n\tvec2 cornerUV = floor(uv);\n\tfloat id = (hash12(cornerUV));\n\tvec2 tileCore = 0.5 + ((hash22(cornerUV)) - 0.5) * 0.95;\n\treturn vec3(tileCore, id);\n}\n\nbool insideBox(vec2 v, vec2 b, vec2 t) {\n\n\treturn\n\tv.x < max(t.x, b.x) && v.x > min(t.x, b.x) &&\n\n\tv.y < max(t.y, b.y) && v.y > min(t.y, b.y)\n\n\t;\n\n}\n\nvec3 tile(vec2 uv) {\n\tvec2 tileUV = uv - floor(uv);\n\n\tvec2 o = vec2(1., 0.);\n\tvec3 res1 = getTileData(uv + o.yy);\n\tvec3 res2 = getTileData(uv + o.xy);\n\tvec3 res3 = getTileData(uv + o.yx);\n\tvec3 res4 = getTileData(uv + o.xx);\n\tfloat id = 0.;\n\n\tif (insideBox(tileUV, vec2(0., res1.y), res3.xy + o.yx)) id = res3.z;\n\tif (insideBox(tileUV, vec2(res3.x, res2.y), res4.xy + o.xx)) id = res4.z;\n\tif (insideBox(tileUV, vec2(res1.x, 0.), res2.xy + o.xy)) id = res2.z;\n\tif (insideBox(tileUV, vec2(0.), res1.xy)) id = res1.z;\n\n\tvec2 cornerUV = floor(uv);\n\tfloat rnd = hash12(cornerUV);\n\tif (rnd < 0.25 && insideBox(tileUV, vec2(res1.x, 0.), res2.xy + o.xy)) id = res2.z;\n\tif (rnd < 0.50 && insideBox(tileUV, vec2(res3.x, res2.y), res4.xy + o.xx)) id = res4.z;\n\tif (rnd < 0.75 && insideBox(tileUV, vec2(0., res1.y), res3.xy + o.yx)) id = res3.z;\n\n\t//if (length((res1.xy) - tileUV) < 0.05) id = .5;\n\n\treturn pal(id);\n}\n\nvec3 difftile(vec2 uv) {\n\nreturn tile(  uv).yxy-tile(  uv+.05).zyz;\n\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 uv = fragCoord / iResolution.x - 0.5;\n\tpR(uv, iTime);\n\t// Time varying pixel color\n\tuv = uv * (cos(iTime) + 1.2) * 30. + vec2(sin(iTime * .6), cos(iTime * .6)) * 17.;\n\tvec3 col = difftile(uv) * 0.2 + 0.5;\n\t// Output to screen\n\tfragColor = vec4(col, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tdK3z1",
    "date": "0",
    "viewed": 0,
    "name": "backgrouns10",
    "description": "This melody is just made of constant tunes interfering with each others (see fullscreen). It is paradoxical in that you perceive low frequency variation and windowed spectrum variations despite the spectrum is still and without low frequency.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "sound",
     "illusion"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Constant spectrum melody\" by FabriceNeyret2. https://shadertoy.com/view/XdsXDf\n// 2019-09-29 12:40:33\n\n#define N      10.\n#define harmon 10.\n#define df     0.1\n#define base   55.\n\nfloat message(vec2 uv) { // to alert in the icon : click too see\n    uv-=vec2(1.,16.); if ((uv.x<0.)||(uv.x>=32.)||(uv.y<0.)||(uv.y>=3.)) return -1.; \n    int i=1, bit=int(pow(2.,floor(32.-uv.x)));\n    if (int(uv.y)==2) i=  928473456/bit; // 00110111 01010111 01100001 01110000\n    if (int(uv.y)==1) i=  626348112/bit; // 00100101 01010101 01010000 01010000\n    if (int(uv.y)==0) i= 1735745872/bit; // 01100111 01110101 01100001 01010000\n \treturn float(i-2*(i/2));\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if (iResolution.y<200.) {float c=message(O.xy/8.);if(c>=0.){O=vec4(c);return;}} // msg for icon view\n    // the real shader:\n\n    U /= iResolution.xy;\n    O -= O;     \n\n    // temporal signal \n    float v = 0., f; \n    \n\tfor (float i = 0.; i <= N; i++) \n        for (float j=1.; j <= harmon; j++)\n            f = ( base + i*df ) * j,\n\t\t    v += sin(2.*3.1415927*f*(.1*U.x-iTime)); \n    \n    O.g = smoothstep(.05,0.,abs(2.*U.y-1. -v/(N*harmon)));    \n\n    // spectrum\n    v = 0.; \n\tfor (float i = 0.; i <= N; i++) \n        for (float j=1.; j <= harmon; j++) {\n            float freq = ( base + i*df ) * j,\n                     p = (freq - U.x*600.) / .2;\n\t\t    v += exp(-.5*p*p);\n        }\n\n    O += v*smoothstep(.8,.1,U.y);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [
      {
       "id": "XsfGRr",
       "channel": 0
      }
     ],
     "code": "// see http://en.wikipedia.org/wiki/Constant_spectrum_melody\n\n#define N      13.\n#define harmon 7.\n#define df     0.08488\n#define base   125.\n\nvec2 synth(float ptime){\nfloat v = 0., f; \n    \n\tfor (float i = 0.; i <= N; i++) \n        for (float j=1.; j <= harmon; j++)\n            f = ( base + i*df ) * j,\n\t\t    v += sin(2.*3.1415927*f*ptime); \n        return vec2(v / (N*harmon));\n        }\nvec2 mainSound( in int samp,float time)\n{\n    float ptime=-time*1.;\n    vec2  y;\n\t\n      y=  synth(-0.7*ptime);\n     y+=  synth(-.3*ptime+1090.);\n        \n    \n    return vec2( y);  \n}",
     "name": "Sound",
     "description": "",
     "type": "sound"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tsK3R1",
    "date": "0",
    "viewed": 0,
    "name": "bgr3",
    "description": "i tried to rebuild the technique that creates the ambience sounds in my game project. it's based on additive synthesis. go ahead and \"listen\" to various textures :)",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "sound",
     "additive",
     "synthesis",
     "creepy"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [],
     "code": "// Fork of \"sound - digital ambience\" by srtuss. https://shadertoy.com/view/MdXXW2\n// 2019-09-29 11:25:25\n\n// srtuss 2014\n\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\n#define ITS 8\n\nvec2 circuit(vec3 p)\n{\n\tp = mod(p, 2.0) - 1.0;\n\tfloat w = 1e38;\n\tvec3 cut = vec3(1.0, 0.0, 0.0);\n\tvec3 e1 = vec3(-1.0);\n\tvec3 e2 = vec3(1.0);\n\tfloat rnd = 0.23;\n\tfloat pos, plane, cur;\n\tfloat fact = 0.9;\n\tfloat j = 0.0;\n\tfor(int i = 0; i < ITS; i ++)\n\t{\n\t\tpos = mix(dot(e1, cut), dot(e2, cut), (rnd - 0.5) * fact + 0.5);\n\t\tplane = dot(p, cut) - pos;\n\t\tif(plane > 0.0)\n\t\t{\n\t\t\te1 = mix(e1, vec3(pos), cut);\n\t\t\trnd = fract(rnd * 9827.5719);\n\t\t\tcut = cut.yzx;\n\t\t}\n\t\telse\n\t\t{\n\t\t\te2 = mix(e2, vec3(pos), cut);\n\t\t\trnd = fract(rnd * 15827.5719);\n\t\t\tcut = cut.zxy;\n\t\t}\n\t\tj += step(rnd, 0.2);\n\t\tw = min(w, abs(plane));\n\t}\n\treturn vec2(j / float(ITS - 1), w);\n}\n\nfloat scene(vec3 p)\n{\n\tvec2 cir = circuit(p);\n\treturn exp(-100.0 * cir.y) + pow(cir.x * 1.8 * (sin(p.z * 10.0 + iTime * -5.0 + cir.x * 10.0) * 0.5 + 0.5), 8.0);\n}\n\nfloat nse(float x)\n{\n    return fract(sin(x * 297.9712) * 90872.2961);\n}\n\nfloat nseI(float x)\n{\n    float fl = floor(x);\n    return mix(nse(fl), nse(fl + 1.0), smoothstep(0.0, 1.0, fract(x)));\n}\n\nfloat fbm(float x)\n{\n    return nseI(x) * 0.5 + nseI(x * 2.0) * 0.25 + nseI(x * 4.0) * 0.125;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 suv = uv;\n\tuv = 2.0 * uv - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\tvec3 ro = vec3(0.0, iTime * 0.2, 0.1);\n\tvec3 rd = normalize(vec3(uv, 0.9));\n\tro.xz = rotate(ro.xz, iTime * 0.1);\n\tro.xy = rotate(ro.xy, 0.2);\n\trd.xz = rotate(rd.xz, iTime * 0.2);\n\trd.xy = rotate(rd.xy, 0.2);\n\tfloat acc = 0.0;\n\tvec3 r = ro + rd * 0.5;\n\tfor(int i = 0; i < 50; i ++)\n\t{\n\t\tacc += scene(r + nse(r.x) * 0.03);\n\t\tr += rd * 0.015;\n\t}\n\tvec3 col = pow(vec3(acc * 0.04), vec3(0.2, 0.6, 2.0) * 8.0) * 2.0;\n\t//col -= exp(length(suv - 0.5) * -2.5 - 0.2);\n    col = clamp(col, vec3(0.0), vec3(1.0));\n    col *= fbm(iTime * 6.0) * 2.0;\n\tcol = pow(col, vec3(1.0 / 2.2));\n\t//col = clamp(col, vec3(0.0), vec3(1.0));\n\tfragColor = vec4(col, 1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4dX3Rn",
       "filepath": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [],
     "code": "#define NSPC 256\n#define pi2 6.283185307179586476925286766559\n\nvec2 synth(float t)\n{\n\tvec2 v = vec2(0.0);\n\tfloat base = 50.0 + sin(t * 0.1) * 20.0;\n\tfloat flt = cos(t * 1.0) * 6.0 + 10.0;\n\tfloat fmd = smoothstep(-0.1, 0.1, sin(t * 1.0)) * 100.0;\n\tfor(int i = 0; i < NSPC; i ++)\n\t{\n\t\tfloat h = float(i + 1);\n\t\tfloat inten = 1.0 / h;\n\t\tinten *= sin((pow(h, sin(t) * 0.5 + 0.5) + t * 0.5) * pi2) * 0.9 + 0.1;\n\t\tvec2 ti = texture(iChannel0, vec2(h / 256.0, t * 0.1)).xy;\n\t\tfloat f = ti.y * fmd;\n\t\tinten *= pow(ti.x, 6.0);\n\t\tinten *= exp(-max(4.0 - h * 2.0, 0.0));\n\t\tinten *= mod(h, 2.0);\n\t\tv.x += inten * sin(h + pi2 * (t * base * h) + f);\n\t\tv.y += inten * sin(pi2 * (t * base * h) + f);\n\t}\n\treturn v;\n}\n\nvec2 mainSound( in int samp,float otime)\n    \n{\n    float time=400.+otime*.16;\n\tvec2 m;\n\tm = synth(time);\n\tfloat ec = 0.5, fb = 0.8, et = 0.3, tm = 0.3;\n\tm += synth(time - et) * ec * vec2(1.0, 0.2); ec *= fb; et += tm;\n\tm += synth(time - et).yx * ec * vec2(0.2, 1.0); ec *= fb; et += tm;\n\tm += synth(time - et) * ec * vec2(1.0, 0.2); ec *= fb; et += tm;\n\tm += synth(time - et).yx * ec * vec2(0.2, 1.0); ec *= fb; et += tm;\n\tm *= 8.8;\n\treturn m;\n}",
     "name": "Sound",
     "description": "",
     "type": "sound"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wsK3R1",
    "date": "0",
    "viewed": 0,
    "name": "bgr4",
    "description": "The secrets of the universe, hidden away for centuries, long forgotten.\n\nThe name \"Sanctuary\" is already used for a shader by user Cabbibo :octopus:",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "sound",
     "music",
     "art",
     "temple",
     "meditation",
     "ambiance"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGRn",
       "filepath": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Sanctuary (2)\" by srtuss. https://shadertoy.com/view/4ddfWX\n// 2019-09-29 11:29:56\n\n// srtuss, 2018\n//\n// This began as an elaborate soundshader-experiment. I tried to create very clear-sounding\n// instruments and mix them nicely, with a feel of depth and dark atmosphere to it. I added\n// visuals based the images this music spawns in my head. Hope you enjoy it. :)\n//\n// Here is a recording of how the shader sounds, on the computers i created/tested it on:\n// http://srtuss.thrill-project.com/art/sanctuary_soundtrack.ogg\n//\n// Music production with a soundshader: :)\n// http://srtuss.thrill-project.com/music/shader.ogg\n//\n\nvec2 rotate(vec2 p, float a)\n{\n    float co = cos(a), si = sin(a);\n    return p * mat2(co, si, -si, co);\n}\n\nvec2 scene(vec3 p, bool details)\n{\n    float v = 1e38;\n    \n    float wall = 3. - dot(vec2(abs(p.x), p.y), normalize(vec2(1., .3)));\n    float floorr = p.y;\n    v = min(v, wall);\n    float srs = .8;\n    float strut = max(wall - .5, abs(fract(p.z * srs) - .5) / srs - .1);\n    v = min(v, strut);\n    v = min(v, max(strut, floorr) - .1);\n    \n    v = min(v, max(strut - .1, abs(floorr - 2.) - .5));\n    \n    float hole = 1.2 - length(p.xz);\n    v = min(v, max(floorr, hole));\n    v = min(v, max(abs(floorr), abs(hole)) - .2);\n    \n    vec3 q = p + vec3(0., sin(iTime) * .1 - 1., 0.);\n    float sphere = length(q) - .4;\n    \n    v = min(v, sphere);\n    \n    return vec2(v, step(sphere, v));\n}\n\nvec3 normal(vec3 p)\n{\n    float c = scene(p, true).x;\n    vec2 h = vec2(.005, 0.);\n    return normalize(vec3(scene(p + h.xyy, true).x - c, scene(p + h.yxy, true).x - c, scene(p + h.yyx, true).x - c));\n}\n\nvec4 trip(sampler2D sampler, vec3 nml, vec3 pos)\n{\n    vec3 b = abs(nml);\n    b = pow(b, vec3(50.));\n    b /= dot(b, vec3(1.));\n    return texture(iChannel0, pos.yz) * b.x + texture(iChannel0, pos.xz) * b.y + texture(iChannel0, pos.xy) * b.z;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n\tfloat res = 1.0;\n    float t = mint;\n\tfor(int i = 0; i < 32; ++i)\n\t{\n\t\tfloat h = scene(ro + rd * t, false).x;\n\t\tif(h < 0.001)\n\t\t\treturn 0.0;\n\t\tres = min(res, k * h / t);\n\t\tt += h;\n\t}\n\treturn res;\n}\n\nfloat amb_occ(vec3 p, float h)\n{\n\tfloat acc = 0.0;\n\tacc += scene(p + vec3(-h, -h, -h), false).x;\n\tacc += scene(p + vec3(-h, -h, +h), false).x;\n\tacc += scene(p + vec3(-h, +h, -h), false).x;\n\tacc += scene(p + vec3(-h, +h, +h), false).x;\n\tacc += scene(p + vec3(+h, -h, -h), false).x;\n\tacc += scene(p + vec3(+h, -h, +h), false).x;\n\tacc += scene(p + vec3(+h, +h, -h), false).x;\n\tacc += scene(p + vec3(+h ,+h, +h), false).x;\n\treturn acc / h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv = uv * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 rd = normalize(vec3(uv, 1.66));\n    vec3 ro = vec3(0., 1., -2.);\n    float tilt = sin(iTime * .1 + 1.5) * .2 + .2;\n    ro.yz = rotate(ro.yz, tilt);\n    rd.yz = rotate(rd.yz, tilt);\n    \n    ro.xz = rotate(ro.xz, sin(iTime * .1) * .5);\n    rd.xz = rotate(rd.xz, sin(iTime * .1) * .5);\n    \n    float d = 0.;\n    for(int i = 0; i < 60; ++i)\n    {\n        d += scene(ro + rd * d, false).x;\n    }\n    \n    vec3 hit = ro + rd * d;\n    vec3 nml = normal(hit);\n    \n    vec3 lpos1 = vec3(0.5, 2., 4.);\n    \n    float mtl = scene(hit, false).y;\n    vec3 diffMap = vec3(0.);\n    if(mtl < .5)\n    {\n        float k = .001;\n        diffMap = trip(iChannel0, nml, hit * 1.111).xyz;\n        vec3 diffMap2 = trip(iChannel0, nml, hit * 1.111 + vec3(.005)).xyz;\n        nml = normalize(nml + (diffMap.x - diffMap2.x) * .7);\n    }\n    else\n    {\n        vec3 mov = hit + vec3(0., sin(iTime) * .1 - 1., 0.);\n        //nml = normalize(nml + sin(hit * 200.) * .03);\n        \n        float k = .001;\n        diffMap = trip(iChannel0, nml, mov * 1.111).xyz;\n        vec3 diffMap2 = trip(iChannel0, nml, mov * 1.111 + vec3(.005)).xyz;\n        nml = normalize(nml + (diffMap.x - diffMap2.x) * .7);\n    }\n    \n\tvec3 col = vec3(0.);// * exp(length(hit.xy - vec2(0., 1.)) * -1.) * exp(d * -.3);\n    \n    for(int i = 0; i < 2; ++i)\n    {\n        vec3 light = i == 1 ? lpos1 : vec3(cos(iTime * .4), 2., sin(iTime) + 1.);\n        vec3 vLight = light - hit;\n        vec3 lcol = i == 1 ? vec3(1, 1., .7) : vec3(.3, .7, 1.);\n        float lfade = exp(length(vLight) * -1.3);\n        vec3 diff = max(dot(nml, normalize(vLight)), 0.) * lfade * lcol;\n        vec3 ref = reflect(rd, nml);\n        float spec = pow(max(0., dot(normalize(vLight), ref)), 32.);\n\n        vec3 ccol = vec3(1.);\n        ccol *= pow(diffMap, vec3(2.));\n\n        ccol *= diff;\n        ccol += vec3(.4) * spec * lfade;\n        \n        col += ccol;\n    }\n    \n    col *= smoothstep(-5., 1., amb_occ(hit, .15));\n    \n    //col = nml * .5 + .5;\n    \n    col += exp((7. - dot(rd, lpos1 - ro)) * -6.);// * softshadow(ro, normalize(lpos1 - ro), .1, 128.);\n    \n    float pt = iTime * .2;\n    for(int i = 0; i < 20; ++i)\n    {\n        float pd = 2.;\n        hit = ro + rd * pd;\n        float h = float(i);\n        if(d > pd)\n        {\n            col += exp(length(hit.xy - vec2(sin(h) * .4 + sin(pt + h) * .1, cos(pt + h) * .1 + fract(pt * .1 + cos(h)))) * -400.) * .05 * (1.1 + sin(h * 10.));\n        }\n    }\n    \n    col = sqrt(col);\n    col *= 2.9;\n    \n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// srtuss, 2018\n\n#define PI 3.1415926535897932384626433832795\n\nfloat tempo = 1.;\n\nfloat hash(float x)\n{\n    return fract(sin(x) * 897612.531);\n}\nfloat hsh(float x)\n{\n    return fract(sin(x * 237.234234) * 982734.1235);\n}\nfloat rnd(float x, float mn, float mx)\n{\n    return mn + floor((mx - mn) * hash(floor(x)));\n}\n\n// perlin noise\nfloat nse(float x)\n{\n    float y = floor(x);\n    x -= y;\n    x = x * x * (3. - 2. * x);\n    return mix(hash(y), hash(y + 1.), x) - .5;\n}\n\n// FM-bell\nvec2 inst0(float t, float f)\n{\n    vec2 v;\n    v.x = sin(t * f * PI * 2. + sin(t * f * 80.) * exp(t * -50.)) * min(t * 800., 1.) * exp(t * -5.) * .25;\n    v.y = cos(t * f * PI * 2. + sin(t * f * 80.) * exp(t * -50.)) * min(t * 800., 1.) * exp(t * -5.) * .25;\n    return v;\n}\n\n// crude vowel-\"A\" instrument\nfloat voc(float t, float f, float formant)\n{\n    float x = fract(t * f) / f;\n    return (sin(x * 6. * formant) * .4 + sin(x * 12. * formant) + sin(x * 26. * formant) * .2) * min(x * 1000., 1.) * exp(x * -200.);\n}\n\n// a swarm of voc()'s\nvec2 inst2(float t, float f)\n{\n    vec2 v = vec2(0., 0.);\n    float formant = 300. * exp2(sin(t * .1));\n    for(int i = 0; i < 16; ++i)\n    {\n        float h = float(i);\n       \tfloat m = voc(t + h / 3., f + pow(2.01, (h - 8.) * .2), formant);\n        float pan = hash(h);\n        v.x += m * pan;\n        v.y += m * (1. - pan);\n    }\n    return v * .1;\n}\n\nfloat tri(float x)\n{\n    return abs(fract(x) * 2. - 1.);\n}\n\n// squarewave-ish instrument\nvec2 inst4(float t, float f)\n{\n    vec2 v = vec2(0., 0.);\n    for(int i = 0; i < 8; ++i)\n    {\n        float h = float(i) * 2. + 1.;\n        float x = h;\n       \tfloat m = sin(t * f * 2. * PI * x) * (1. + nse(h * 41. + t * 10.)) / h;\n        float pan = hash(h);\n        v.x += m * pan;\n        v.y += m * (1. - pan);\n    }\n    return v * .25;\n}\n\n// pentatonic scale\nfloat penta(float x)\n{\n    x /= 5.;\n    float y = floor(x);\n    x = fract(x);\n    x *= 5.;\n    return step(1., x) * 2. + step(2., x) * 3. + step(3., x) * 2. + step(4., x) * 2. + y * 12.;\n}\n\n// 2 octaves of choir + playing harmonics, which gives some symphonic qualities\nvec2 choir(float time, float n)\n{\n    vec2 v = inst2(time, 140. * pow(2., n / 12.));\n    v += inst2(-time, 140. * pow(2., n / 12. - 1.));\n    if(time > 128. / tempo)\n    {\n        v += inst4(time, 140. * 5. * pow(2., (n + 12.) / 12.)) * .2 * smoothstep(0., .1, nse(time * .44 + 10.));\n        v += inst4(time, 140. * 4. * pow(2., (n + 12.) / 12.)) * .2 * smoothstep(0., .1, nse(time * .33));\n        v += inst4(time, 140. * 3. * pow(2., (n + 12.) / 12.)) * .2 * smoothstep(0., .1, nse(time * .12));\n        v += inst4(time, 140. * 5. / 2. * pow(2., (n + 12.) / 12.)) * .2 * smoothstep(0., .1, nse(time * .32 + 4.));\n    }\n    return v;\n}\n\n// a snaredrum with fake reverb tail\nvec2 snare(float t)\n{\n    if(t < 0.)\n        return vec2(0.);\n    t *= 3.;\n    float env = exp(t * -10.) + exp(t * -1.) * .07;\n    vec2 w = vec2(hsh(t), hsh(t + .1)) * env * .4;\n    w += sin(t * 400.) * exp(t * -10.) * min(1., t * 5000.) * .1;\n    return w * (max(exp(-1. * fract(t * 20.)), min(t * 9., 1.)) + 3. * clamp(1. - abs(t - .4) * 10., 0., 1.));\n}\n\n// channel to be echo-ed\nvec2 echomix(float time)\n{\n    vec2 v = vec2(0.);\n    \n    float x = mod(time, 8. / tempo);\n    v += vec2(.5) * sin(pow(x, .9) * 300.) * min(1., x * 200.) * exp(x * -5.);\n    \n    float rate = tempo * 2.;\n    if(time > 32. / tempo)\n\t    v += inst0(fract(time * rate) / rate, 140. * 2. * pow(2., penta(rnd(time * rate, 0., 10.)) / 12.)) * .4;\n    return v;\n}\n\n// tempo-synced echo effect\nvec2 echo(float t)\n{\n    vec2 s = vec2(0, 0);\n    float k = 3. / 4. / tempo;\n    float a = 1.;\n    float damp = .5;\n    vec2 sep = vec2(.3, 1.);\n    s += echomix(t); a *= damp; sep = sep.yx;\n    s += echomix(t - k).yx * a * sep; a *= damp; sep = sep.yx;\n    s += echomix(t - k * 2.) * a * sep; a *= damp; sep = sep.yx;\n    s += echomix(t - k * 3.).yx * a * sep;\n    return s;\n}\n\n// putting everything together + postprocessing\nvec2 mainSound( in int samp, float time )\n{\n    vec2 v = echo(time);\n    \n    float x;\n    x = mod(time, 32. / tempo);\n    v += choir(time, -5.) * clamp(x * tempo * .5, 0., 1.) * smoothstep(16. + 4., 15., x * tempo);\n    v += choir(time, -7.) * (clamp((x * tempo - 16.) * .5, 0., 1.) * smoothstep(32. + 4., 31., x * tempo + 1.) + smoothstep(5., 0., x * tempo));\n    \n    if(time >= 0. / tempo)\n    {\n        v += snare(mod(time - 1. / tempo, 2. / tempo));\n        x = mod(time, 16. / tempo);\n        v += snare(x - tempo * (7. + 16.) / 16.);\n    }\n        \n    vec2 ms = vec2(v.x + v.y, v.y - v.x);\n    \n    v = vec2(ms.x * .5 + ms.y, ms.x * .5 - ms.y);\n    \n    \n    return v;\n}",
     "name": "Sound",
     "description": "",
     "type": "sound"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tdKGz1",
    "date": "0",
    "viewed": 0,
    "name": "bgr5",
    "description": "This shader shows how to use the Common tab in Shadertoy. All tabs inherit the code of the Common tab. Here, that's used to get the Image and the Sound shader to conveniently share the music pattern generator, so they can display and play it respectively.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "2d",
     "shadertoy",
     "common"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4dXGR8",
       "filepath": "/media/previz/buffer00.png",
       "type": "buffer",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\n    vec2  p = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n    \n \n\n    fragColor = vec4(p,p);\n    \n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": " \nconst float speed = .125;\n\nfloat patternFrac( float x )\n{\n    return fract(speed*x);\n}\n\nconst int wholeNotes[] = int[](0,2,4,5,7,9,11);\n\nfloat patternNote( float x )\n{\n    int noteID = int( 7.0+7.0*sin( floor( speed*x) ) );\n    return float( wholeNotes[noteID%7] + 12*(noteID/7) );\n}\n\nfloat patternFreq( float x )\n{\n    float f = patternNote(x);\n    return 55.0*pow(2.0,f/12.0);\n}\n\nfloat tone( in float freq, in float deca, in float time )\n    \n{\n    freq*=0.53;\n    // fm sound\n    float y = sin(6.2831*freq*time + 5.0*sin(6.2831*freq*time) );\n    // add some harmonics\n    //y *= 0.5*(1.0+y*y);\n    // attenaute\n    y *= exp(-(1.0+freq/20.0)*deca);\n    // attack\n    y *= clamp(12.0*deca,0.0,1.0);\n\treturn y;    \n}\n\nvec2 mainSound( in int samp, float time )\n{\n    // reverb\n    float y = 0.0;\n    float a = 0.7;\n    float timeoffset= 0.3*(round(0.125*( \n            sin(time*.24)*1.25 + \n            sin(time*.74)*2.5 + \n            sin(time*1.4)*5. +\n            sin(time)*10.) ));\n\n    for( int i=0; i<5; i++ )\n    {       \n        float hime = timeoffset+time\n            - 1.4*float(i)/5.0;\n        float freq = patternFreq( hime)  ;\n        float deca = patternFrac( hime   );\n        y += a*tone( freq, deca, hime*2. );\n        \n        \n            hime = -timeoffset+ time            - 1.4*float(i)/5.0;\n          freq = patternFreq( hime)  ;\n          deca = patternFrac( hime   );\n        y += a*tone( freq*2., deca*2., hime );\n        \n          hime =   1700.+time            - 1.4*float(i*2)/5.0;\n          freq = patternFreq( hime*3.)  ;\n          deca = patternFrac( hime   );\n        y += a*tone( freq*2., deca*.4, hime );\n     \n        a *= 0.6;\n    } \n    \n    \n \n    \n    return vec2( y );\n}",
     "name": "Sound",
     "description": "",
     "type": "sound"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "tdK3R1",
    "date": "0",
    "viewed": 0,
    "name": "bgrmusiq",
    "description": "time to waste",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "sound",
     "blackhole",
     "ambient",
     "drone",
     "riff"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "4sf3zn",
       "filepath": "/presets/webcam.png",
       "type": "webcam",
       "channel": 0,
       "sampler": {
        "filter": "linear",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"black star\" by nabr. https://shadertoy.com/view/wt2XD3\n// 2019-09-29 11:17:46\n\n// nabr\n// https://www.shadertoy.com/view/wt2XD3\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n\n\n\n// modified \n// fbm by iq https://www.shadertoy.com/view/MdX3Rr\n// noise by sphinx http://glslsandbox.com/e#31401.0\n\nfloat fbm(in vec2 p)\n{\n  \n    float f = 0.0;\n    for (float i = .5; i > 0.; i -= .154)\n    {\tif (i != .5)\n            p *= mat2(.314, -1, 1, .314) * (2.01 + i) / 1.115625;\n        float u = floor(p).x + floor(p).y * 257.;\n        vec4 v = vec4(u, u + 1., u + 257., u + 257.+ 1.);\n        v = fract(fract(1.23456789 * v) * v / .987654321);\n        f += (i * mix(mix(v.x, v.y, fract(p.x)), mix(v.z, v.w, fract(p.x)), fract(p.y)));\n    }\n    return f;\n}\n\nvoid mainImage(out vec4 O, in vec2 U)\n{     \n    vec3 raw = vec3(1.);\n \n    \n     U = (U + U - iResolution.xy) / min(iResolution.x, iResolution.y);\n    \n    float rt = iTime * .1;\n    float size = 2.6, dist = 2.5, rdist = 2. + sin(.5 * iTime);\n    vec3 rd = normalize(vec3(16. * vec2(U.x - cos(rt), 1.2 * U.y + sin(rt)), rdist));\n    rd.xy = (cos(rt) * U + sin(rt) * vec2(U.y, -U.x));\n\n    float t = dist / -rd.z + size;\n    \n    float dist2t = 1.4;\n    \n   \n    vec2 b = vec2(1.); //(atan(t) / dist2t * rd.xy) * 2.+ .5;\n\n    vec3 c = vec3(.1, .5, .2);\n  \t//webcam\n    //c += (.5 * fbm(vec2(raw.x*b.x, -raw.x*b.y) + .5) * fbm(1.1*raw.yx+4. * b) * fbm(vec2(1.1*raw.yz+b - .5 * iTime)));\n    c += (.5 * fbm(vec2(b.x, -b.y) + .5) * fbm(4. * b) * fbm(vec2(b - .5 * iTime)));\n    c = reflect(-rd.xyy, normalize(vec3(b, 5.))) + c * 1.4 + vec3(-.1, -.06, 0);\n    O.xyz =  ((.333 * (c.r + c.y + c.z)) + .45 * c.zxy) ;\n\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "// nabr\n// https://www.shadertoy.com/view/wt2XD3\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n\n#define tau (2. * acos(-1.))\n#define rndp(rng, maxval) ((1315313u % (rng + 1u)) % maxval)\n\n\nfloat synth(in float rt, in int chc)\n{\n\n    float sn = 1., sna = 1., m0 = 20., m1 = 1., m0vt = 2.;\n\n    int smp = 5;\n\n    if (chc == 2)\n    {\n        m1 = 2600.;\n        smp = 6;\n    }\n\n    if (chc == 1)\n    {\n        m0 = float[](10., 50., 80., 40., 60.)[int((2. * rt)) % 5];\n        m0vt = 3.;\n    }\n    \n    float bss = 1.7;\n    for(int n = 0; n < smp; n++)\n    {\n        sn += (.5 + 2. * sin(m0 * tau * rt));\n        sn += (1. - length((sn - bss) - cos(m0 * tau * rt)));\n\n        m0 *= m0vt;\n\n        (mod(5. * rt, 4.) <= 1. && chc == 2) ? \n            (sna += .5 * abs(1. - 2. * sin(m0 * tau * rt)) + (.2 * sin(m1 * tau * rt)),\n             sn = .7 * floor(.5 * sna) * pow(4., 1. - 6. * fract(rt)))\n             : sn *= min(1., 2. * fract(6. * rt)) * max(0., 1. - fract(6. * rt));\n    }\n\n    sn *= min(1., 2. * fract(2. * rt)) * max(0., 1. - fract(2. * rt));\n\n    return sn;\n}\n\n \n\nvec2 mainSound( in int samp,float otime)\n{\nfloat time=otime+4000.;\n    vec2 snd = vec2(1), uni = vec2(1), rev = vec2(1);\n\n    float sum = 0., amp = 1.;\n    float tick = (mod(time, 22.888) / 60.), bpm = 38.88 * tick;\n\n   \n    \n    float ivr = 0.125;\n    \n     \n    \tfor(float _ii = 0.; (_ii <= 1.); _ii += ivr)\n    \t{\n        \tamp = exp2(-_ii * (_ii + .5));\n        \tuni += vec2(synth(bpm + 1.01 * amp, 2), synth(bpm + 1. * amp, 2));\n        \tsum += amp;\n    \t}\n\t\t\n        uni /= sum;\n    \n    \n    sum = 0.;\n    ivr = 0.0606;\n    \n    // https://www.shadertoy.com/view/XldcRr\n    // by TekF\n    for(float _jj = 0.; (_jj <= 1.); _jj += ivr)\n    {\n        bpm = 7.776 * tick;\n        float rand = fract(120. * sin(_jj * 1000.));\n        float t2 = (ivr + _jj) + (3. * rand);\n        amp = exp2(-_jj * t2);\n         (rev += (amp * uni * .5) \n               + vec2(synth(bpm + 1.025 * amp, 1), synth(bpm + 1.01 * amp, 1)));\n\n        sum += amp;\n    }\n\n    rev /= sum;\n\n    return .707 * rev;\n}",
     "name": "Sound",
     "description": "",
     "type": "sound"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wdK3R1",
    "date": "0",
    "viewed": 0,
    "name": "bgrnd2",
    "description": "Venturing beyond the boundaries of space, time and consciousness.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "ambient",
     "meditative"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XsfGzn",
       "filepath": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg",
       "type": "cubemap",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "Xdf3zn",
       "filepath": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png",
       "type": "texture",
       "channel": 1,
       "sampler": {
        "filter": "nearest",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      },
      {
       "id": "Xsf3zn",
       "filepath": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png",
       "type": "texture",
       "channel": 2,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [],
     "code": "// Fork of \"Genesis (sound)\" by srtuss. https://shadertoy.com/view/lscGDX\n// 2019-09-29 11:20:04\n\n// srtuss, 2016\n\nfloat time;\n\nvec2 rotate(vec2 p, float a)\n{\n\treturn vec2(p.x * cos(a) - p.y * sin(a), p.x * sin(a) + p.y * cos(a));\n}\n\nfloat hermite(float x)\n{\n\treturn x * x * (3.0 - 2.0 * x);\n}\n\n// iq's fast 3d noise\nfloat noise3d(in vec3 x)\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\tvec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n\tvec2 rg = texture(iChannel1, (uv + 0.5) / 256.0, -100.0).yx;\n\treturn mix(rg.x, rg.y, f.z);\n}\n\n\n// animated 3d fbm\nfloat fbm3a(vec3 p)\n{\n\tvec2 t = vec2(time * 2.8, 0.0);\n\treturn noise3d(p + t.xyy) * 0.5 + noise3d(p * 2.02 - t.xyy) * 0.25 + noise3d(p * 4.01 + t.yxy) * 0.125;\n}\n\n// more animated 3d fbm\nfloat fbm3a_(vec3 p)\n{\n\tvec2 t = vec2(time * 2.8, 0.0);\n\treturn noise3d(p + t.xyy) * 0.5 + noise3d(p * 2.02 - t.xyy) * 0.25 + noise3d(p * 4.01 + t.yxy) * 0.125 + noise3d(p * 8.03 + t.yxy) * 0.0625;\n}\n\nvec3 sky(vec3 p)\n{\n\tvec3 col;\n\tfloat v = 1.0 - abs(fbm3a(p * 4.0) * 2.0 - 1.0);\n\tfloat n = fbm3a_(p * 7.0 - 104.042);\n\tv = mix(v, pow(n, 0.3), 0.5);\n\t\n\tcol = vec3(pow(vec3(v), vec3(13.0, 7.0, 6.0))) * 0.8;\n\treturn col;\n}\n\n\n\n\n// 3d fbm\nfloat fbm3(vec3 p)\n{\n\treturn noise3d(p) * 0.5 + noise3d(p * 2.02) * 0.25 + noise3d(p * 4.01) * 0.125;\n}\n\nvec3 stuff(vec2 p)\n{\n\tvec2 fr = fract(p);\n\tvec2 fl = floor(p);\n\tfr = fr * fr * (3.0 - 2.0 * fr);\n\treturn texture(iChannel2, (fl + 0.5 + fr) / 256.0).xyz;\n}\n\nvec3 stuff_fbm(vec2 p)\n{\n\treturn stuff(p) * 0.5 + stuff(p * 2.02) * 0.25 + stuff(p * 4.01) * 0.125;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat BALL_SIZE = 0.9999;\n\tfloat BLEND_DEPTH = 200.0;\n\tfloat BLEND_BALL = 0.004;\n\t\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = 2.0 * uv - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n    float pan = sin(iTime * 0.3)*0.5 + iMouse.x * 0.01;\n\ttime = iTime * 0.1;\n\t\n\t//time = iTime * 1.0 + 1.0;\n\t// playing with time\n\tfloat seg = 10.0;\n\tfloat tfl = floor(time / seg) * seg;\n\tfloat tfr = mod(time, seg);\n\t//time = tfl + tfr - pow(clamp(tfr - 8.0, 0.0, 1.0), 4.0) * (tfr - 9.0) * 0.95 + sin(time * 20.0) * 0.5 * pow(2.0 * clamp(tfr - 9.5, 0.0, 1.0), 2.0);\n\t\n\t\n\tvec3 rd = -normalize(vec3(uv, 1.66));\n    vec3 ro = vec3(0.0, -1000.0, 7000.0);\n\trd.xz = rotate(rd.xz, time);\n\tro.xz = rotate(ro.xz, time);\n\t\n\tfloat t = cos(time) * 0.3;\n\tro.yz = rotate(ro.yz, t);\n\trd.yz = rotate(rd.yz, t);\n\t\n\tvec3 blobpos = vec3(0.0);\n\t\n    float cl = 0.0;\n\tfloat ca = 0.0;\n    vec3  cp = vec3(0.0);\n\tfloat cd = 99999.9;\n\n    for(int i = 0; i < 40; i ++)\n\t{\n\t\tfloat id = float(i) * 0.4 + 0.1;\n\t\t//blobpos = vec3(sin(id * 2.0 + iTime) * 500.0 - 2000.0, sin(id + iTime) * 500.0 - 2000.0, cos(id + iTime) * 500.0);//blob(ii);\n\t\t\n\t\tvec3 ns = stuff_fbm(vec2(time + id * 0.1, id * 0.4)).xyz * 2.0 - 1.0;\n\t\tblobpos = ns;\n\t\t//blobpos = vec3((float(i) - 50.0) * 0.03, ns.x * 0.4, ns.y * 0.4);\n\t\t\n\t\t/*vec3 dd = normalize(blobpos);\n\t\tfloat l = length(blobpos);\n\t\t\n\t\tblobpos = pow(l, 1.0) * 3000.0 * dd;*/\n\t\t\n\t\tblobpos *= 3000.0;\n\t\t\n\t\t\n\t\t//blobpos = pow(blobpos * 2.0 - 1.0, vec3(3.0)) * 5000.0;\n\t\t\n\t\t\n        vec3  vect  = blobpos - ro;\n        float vectm = length(vect);     \n        vec3  vectn = vect/vectm;\n\t\t\n        float d = dot(rd, vectn);\n\t\tfloat c = BALL_SIZE / d;\n\t\tfloat w = (smoothstep(-BLEND_DEPTH, 0.0, cd - vectm) * smoothstep(c - BLEND_BALL, c, d));\n\t\t\n\t\tcd = mix(cd, vectm, w);\n\t\tcp = mix(cp, blobpos, w);\n\t\tcl = mix(cl, d, w);\n\n\t\t\n\t};\n\n\tfloat a = dot(rd, cp - ro);\n\tvec3  contact = ro + rd * a;\n\tvec3  norm = normalize(cp - contact);\t\n\tfloat dist = length(cp - contact);\t\n\n\tfloat cen = pow(smoothstep(400.0, 0.0, dist), 1.0);\n\tfloat cut   = clamp(smoothstep(0.80, 0.99, cl) - cen, 0.0, 1.0);\n\tfloat angle = dot(norm,vec3(0.0,0.8,0.2));\n\t\n\tfloat sha  = smoothstep(-0.3, -0.5, angle) * 0.5;\n\tfloat hil  = smoothstep(0.75, 0.8, angle);\n\tfloat sha2 = 0.0;//smoothstep(1.0, 0.0, max(0.0, -contact.y)) * smoothstep(0.40, 0.98, cl);\n\t\n\tvec3 backcol = vec3(0.25,0.35,0.4)-sha2*0.15+smoothstep(0.0,0.4,rd.y-0.1)*0.4;\n\t\n\tvec3 tc = rd + norm * pow(cen, 0.05) * 0.04;\n\tbackcol = sky(tc);\n\tbackcol = /*texture(iChannel0, tc).xyz*/backcol * (1.0 - cen * 0.99);\n\t\n\tvec3 blobcol = vec3(0.0, 0.0, 0.0);//vec3(0.3,0.4,0.45);\n\t\t blobcol = mix(blobcol,vec3(0.0,0.0,0.3),sha); \n\t\t blobcol = mix(blobcol,vec3(1.0),hil);\n\t//blobcol = texture(iChannel0, norm).xyz;\n\n\tvec3 col = mix(backcol, blobcol, cut);\n\t\n\tcol = pow(col, vec3(3.0)) * 8.2;\n\t\n    col = pow(col, vec3(1.0 / 2.2));\n    \n\t//col = mix(col, vec3(1.0), smoothstep(0.0, 0.01, 0.02 - abs(length(uv) - 0.7)));\n\t\n\tfragColor = vec4(col, 1.0);\n    \n    \n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [
      {
       "id": "4sf3Rr",
       "filepath": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png",
       "type": "texture",
       "channel": 0,
       "sampler": {
        "filter": "mipmap",
        "wrap": "repeat",
        "vflip": "true",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [],
     "code": "// srtuss, 2016\n\n#define pi2 6.283185307179586476925286766559\n\nfloat xsine(float x)\n{\n    return sin(x * pi2);\n}\nfloat xnotem(float note)\n{\n    return pow(2.0, note / 12.0);\n}\nfloat xnotef(float note)\n{\n    return 440.0 * pow(2.0, (note - 69.0) / 12.0);\n}\nfloat xvolmul(float vol)\n{\n    return exp((vol - 1.0) * 4.0);\n}\n\n#define xC\t0.0\n#define xCS\t1.0\n#define xD\t2.0\n#define xDS\t3.0\n#define xE\t4.0\n#define xF\t5.0\n#define xFS\t6.0\n#define xG\t7.0\n#define xGS\t8.0\n#define xA\t9.0\n#define xAS\t10.0\n#define xB\t11.0\n\nfloat a(float x, float t)\n{\n    return (xsine(x * 0.5 + t * 1.0) + 1.0) * 0.1;\n}\n\nfloat addsyn(float t, float bf)\n{\n    float v = 0.0;\n    for(int i = 0; i < 32; ++i)\n    {\n        float harm = float(i + 1);\n        float a = texture(iChannel0, vec2(harm / 512.0, t * 0.1)).x;\n        float b = texture(iChannel0, vec2(harm / 512.0, t * 0.1 + 0.5)).x;\n        //a *= exp(max(10.0 - harm, 0.0) * -0.05);\n        v += a * xsine(harm * t * bf + b * 0.01) / harm;\n    }\n    return sin(v * (1.0 + sin(t * 0.5) * 20.0));\n}\n\nvec2 mega(float time, float bf, vec2 vcs)\n{\n    vec2 v = vec2(0.0, 0.0);\n    /*v += xsine(time * bf * xnotem(0.0 + xC));\n    v += xsine(time * bf * xnotem(12.0 + xC));\n    v += xsine(time * bf * xnotem(24.0 + xE));\n    v += xsine(time * bf * xnotem(36.0 + xB));*/\n    \n    #ifdef A\n    for(int i = 0; i < 32; ++i)\n    {\n        float tn = float(i);\n    \tv += vec2(\n            addsyn(time * (1.0 + tn * 0.001) + sin(tn * 28971.04124), 50.0),\n            addsyn(time * (1.0 + tn * 0.001) + sin(tn * 22971.04124), 50.0));\n    }\n    #endif\n    for(int i = 0; i < 32; ++i)\n    {\n        float tn = float(i);\n        float det = 0.001;//pow(10.0, -1.0 + (sin(time) + 1.0) * -1.0);\n        vec2 rnd = vec2(sin(tn * 28971.04124), sin(tn * 22971.04124));// * 0.01;\n        \n        float f = bf;\n    \tv += vec2(\n            addsyn(time + rnd.x, f * (1.0 + tn * det)),\n            addsyn(time + rnd.y, f * (1.0 + tn * det)));\n        \n        f = f * xnotem(16.0);\n        v += vec2(\n            addsyn(time + rnd.x * 2.0, f * (1.0 + tn * det)),\n            addsyn(time + rnd.y * 2.0, f * (1.0 + tn * det))) * 0.9 * vcs.x;\n        \n        f = f * xnotem(19.0);\n        v += vec2(\n            addsyn(time + rnd.x * 2.0, f * (1.0 + tn * det)),\n            addsyn(time + rnd.y * 2.0, f * (1.0 + tn * det))) * 0.3 * vcs.y;\n    }\n    v *= 0.03;\n    return v;\n}\n\nfloat tmul = 100.0 / 60.0;\n\nfloat perc(float t)\n{\n    float v = 0.0;\n    \n    t *= tmul;\n    float id = floor(t * 4.0);\n    /*t = mod(t, 8.0);\n    t = mod(t, 3.0);\n    t = mod(t, 2.5);\n    t = mod(t, 1.0);*/\n    t = mod(t, 0.25);\n    \n    t /= tmul;\n    //v += xsine(t * 120.0 + xsine(t * 50.0) * 0.7) * exp(max(t, 0.0) * -30.0);\n    //v += fract(sin(t * 10000.0) * 182412.41232) * exp(max(0.0, t) * -10.0) * 0.2;\n    //v += xsine(t * 60.0) * 0.5 * smoothstep(0.0, 0.05, t) * exp(max(0.0, t) * -2.0);\n    //v += xsine(sqrt(t) * 2000.0) * smoothstep(0.0, 0.01, t) * exp(max(0.0, t) * -10.0);\n    \n    float f = fract(sin(id * 192.4124) * 287235.023452);\n    v += xsine(t * xnotef(80.0 + floor(f * 24.0))) * smoothstep(0.0, 0.05, t) * exp(max(0.0, t) * -4.0);\n    \n    return v * 0.4;\n}\n\nvec2 echo(float t, float fbTm)\n{\n    vec2 v = vec2(0.0, 0.0);\n    vec2 amp = vec2(1.0, 0.5);\n    vec2 toff = vec2(0.01, 0.0);\n    for(int i = 0; i < 10; ++i)\n    {\n        t -= fbTm;\n        v += vec2(perc(t - toff.x), perc(t - toff.y)) * amp;\n        toff = toff.yx * 1.01;\n        amp = amp.yx * 0.5;\n    }\n    return v;\n}\n\nfloat fdin(float t, float tstart, float tdur)\n{\n    return clamp((t - tstart) / tdur, 0.0, 1.0);\n}\n\nfloat fdout(float t, float tstart, float tdur)\n{\n    return 1.0 - clamp((t - tstart) / tdur, 0.0, 1.0);\n}\n\nfloat fx(float t)\n{\n    float s;\n    float vibI = 100.0;\n    float vibF = sin(t * 0.8) + 1.5;\n    float phs = 440.0 * t - vibI * cos(vibF * t * pi2) / vibF;\n    float v = sin(pi2 * phs) * 0.1;\n    return v;\n}\n\nvec2 mainSound( in int samp, float time )\n{\n    vec2 mx;\n    float tb = time * tmul;\n    tb = mod(tb, 32.0);\n    mx.x = fdin(tb, 0.0, 4.0) * fdout(tb, 16.0, 4.0);\n    tb += 16.0;\n    tb = mod(tb, 32.0);\n    mx.y = fdin(tb, 0.0, 4.0) * fdout(tb, 16.0, 4.0);\n    \n    mx.y *= min(time * 0.1, 1.0);\n\n    vec2 v = vec2(0.0);\n    vec2 vcs = vec2(sin(time * 0.2) * 0.5 + 0.5, sin(time * 0.3) * 0.5 + 0.5);\n    \n    v = mega(time, 40.0, vcs) * mx.x;\n    v += mega(time, 40.0 * xnotem(9.0), vcs) * mx.x;\n    \n    v += mega(time, 40.0 * xnotem(-4.0), vcs) * mx.y;\n    v += mega(time, 40.0 * xnotem(0.0 + 12.0), vcs) * mx.y;\n    \n    //v += mega(time, 33.0) * mx.y;\n    \n    //v += echo(time, tmul / 6.0) * 0.5;\n    \n    return v;\n}",
     "name": "Sound",
     "description": "",
     "type": "sound"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wdScR3",
    "date": "0",
    "viewed": 0,
    "name": "landscape rocks",
    "description": "  ",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "raymarching",
     "time",
     "shadow",
     "light",
     "animation",
     "normal"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"raymarching - step by step\" by Cewein. https://shadertoy.com/view/ts2yzK\n// 2020-04-16 13:48:25\n\nfloat speed = 1.5;\n\nfloat hash11(float p) {\n    return fract(sin(p * 727.1)*435.545);\n}\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*437.545);\n}\nvec3 hash31(float p) {\n\tvec3 h = vec3(127.231,491.7,718.423) * p;\t\n    return fract(sin(h)*435.543);\n}\n\n// 3d noise\nfloat noise_3(in vec3 p) {\n    vec3 i = floor(p);\n    vec3 f = fract(p);\t\n\tvec3 u = f*f*(3.0-2.0*f);\n    \n    vec2 ii = i.xy + i.z * vec2(5.0);\n    float a = hash12( ii + vec2(0.0,0.0) );\n\tfloat b = hash12( ii + vec2(1.0,0.0) );    \n    float c = hash12( ii + vec2(0.0,1.0) );\n\tfloat d = hash12( ii + vec2(1.0,1.0) ); \n    float v1 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n    \n    ii += vec2(5.0);\n    a = hash12( ii + vec2(0.0,0.0) );\n\tb = hash12( ii + vec2(1.0,0.0) );    \n    c = hash12( ii + vec2(0.0,1.0) );\n\td = hash12( ii + vec2(1.0,1.0) );\n    float v2 = mix(mix(a,b,u.x), mix(c,d,u.x), u.y);\n        \n    return max(mix(v1,v2,u.z),0.0);\n}\n\n// fBm\nfloat fbm3(vec3 p, float a, float f) {\n    return noise_3(p);\n}\n\nfloat fbm3_high(vec3 p, float a, float f) {\n    float ret = 0.0;    \n    float amp = 1.0;\n    float frq = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float n = pow(noise_3(p * frq),2.0);\n        ret += n * amp;\n        frq *= f;\n        amp *= a * (pow(n,0.2));\n    }\n    return ret;\n} \n\nfloat random(in vec2 uv)\n{\n    return fract(sin(dot(uv.xy, \n                         vec2(12.9898, 78.233))) * \n                 43758.5453123);\n}\n\nfloat noise(in vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n    \n    float a = random(i + vec2(0., 0.));\n    float b = random(i + vec2(1., 0.));\n    float c = random(i + vec2(0., 1.));\n    float d = random(i + vec2(1., 1.));\n    \n    vec2 u = smoothstep(0., 1., f);\n    \n    return mix(mix(a, b, u.x), \n               mix(c, d, u.x), u.y);\n}\n\n#define OCTAVES 8\nfloat fbm(in vec2 uv)\n{\n    float value = 0.;\n    float amplitude = 1.;\n    float freq = 0.8;\n    \n    for (int i = 0; i < OCTAVES; i++)\n    {\n        // value += noise(uv * freq) * amplitude;\n        \n        // From Dave_Hoskins https://www.shadertoy.com/user/Dave_Hoskins\n        value += (.25-\n                  mix(\n                  abs(noise(uv * freq)-.3)\n                  ,(noise(uv * freq)-.3)\n                  ,noise(uv * freq*0.1)\n                  \n                  )\n                  \n                  \n                  * amplitude);\n        \n        amplitude *= .37;\n        \n        freq *= 2.;\n    }\n    \n    return value;\n}\n\n// distance functions\nfloat plane(vec3 gp, vec4 p) {\n\treturn dot(p.xyz,gp+p.xyz*p.w);\n}\nfloat rbox(vec3 p,vec3 s) {\n\tp = abs(p)-s;\n    return length(p-min(p,0.0));\n}\nfloat sphere(vec3 p,float r) {\n\treturn length(p)-r;\n}\n\n// smooth operations. thanks to iq\nfloat boolSmoothIntersect(float a, float b, float k ) {\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(a,b,h) + k*h*(1.0-h);\n}\nfloat boolSmoothSub(float a, float b, float k ) {\n    return boolSmoothIntersect(a,-b,k);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n// world\n\n\nfloat terrain(vec3 wp){\n   float h=max(1.,(length(wp.xz)*length(wp.xz))/50000.);\nreturn \n    (fbm(vec2(wp.x,wp.z)*.020)*25.5+5.)*h\n  \n    \n    ;\n    }\n\nfloat rock(vec3 p,vec3 wp) {  \n    wp.y=0.;\n        vec3 seed= floor((wp)/10.)*10.;\n           seed.y=  0.;\n    seed.x*=1387.9483;\n\n    float d;\n\n    \n    \n    float size=    hash11(  2.2+   seed.x+seed.y+seed.z)*5.+1.;\n    if (hash11(     seed.x-seed.z)*1.2<fbm3(seed*.20,0.4,2.96))\n    {       \n    vec3 offs=  (  hash31( 1.+    seed.x -seed.z)-.5)*2.*(4.-size);\nfloat terrain= terrain(wp);\n    vec3 movep= vec3( offs.x,-size/4.+terrain,offs.z);\n    \n    p=p+ fbm3((wp)*1.0,0.4,2.96)*.2;\n    float d = rbox(p-movep,vec3(.6*size))-.2*size; \n    \n    for(int i = 0; i < 12; i++) {\n        float ii = float(i)+seed.x +seed.z;\n        float r =  (.5+hash11(ii)*0.5)*size;\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0-vec3(0,0.7,0) );\n           \n      \n        d = boolSmoothSub(d, (plane(p-movep,vec4(v,r ))), 0.03);\n              \n    }\n    \n    for(int i = 0; i < 4; i++) {\n        float ii = float(i)+.1+seed.x+seed.y+seed.z;\n        float r =  (.7+hash11(ii)*.5)*size;\n        vec3 v = normalize(hash31(ii) * 2.0 - 1.0-vec3(0,0.2,0))*1.6*size ;\n           \n      \n        d = boolSmoothSub(d, (sphere(p-movep+v,r  )), 0.03);\n              \n    }\n    \n        if(d<.05){\n            return d  - fbm3_high(wp*4.0,0.4,2.96)*.025;}\n        else{\n           return d  - fbm3(wp*4.0,0.4,2.96)*.025;\n               }\n        \n        ;\n}\nelse\n    return length(p);\n}          \n    \n\nfloat map(in vec3 pos)\n{\n    float time = mod(iTime * speed,30.);\n     vec3 cellp=mod(pos,10.)-5.;\n    cellp.y=pos.y;\n    float rocks=  rock(  cellp-vec3(0,.5,0),pos-vec3(0,-.5,0));\n    \n    float flr = pos.y - (-0.30)\n- terrain(pos)\n        \n        ;\n    \n    if(flr<1.){flr+=- fbm3_high(pos*4.0,0.4,2.96)*.02  \n        ;}\n    \n    return opSmoothUnion(rocks,flr, clamp(fbm3(pos*.5,0.4,2.96)*0.7,0.1,.6)\n                        );\n    \n\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001,0.);\n    return normalize(vec3(map(pos + e.xyy)-map(pos-e.xyy),\n                          map(pos + e.yxy)-map(pos-e.yxy),\n                          map(pos + e.yyx)-map(pos-e.yyx))\n                    );\n}\n\nfloat castRay(in vec3 ro, in vec3 rd)\n{\n    float t = 0.;\n    for(int i = 0; i<220; i++)\n    {\n        vec3 pos = ro + t*rd;\n        \n        float h = map(pos);\n        \n        if(h < 0.001) break;\n        \n        t += h;\n        \n        if(t > 200.)\n        {\n            t = -1.; //set for the shadow\n            break;\n        }\n    }\n        \n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    //uv+=(vec2( hash11( uv.y*12.+uv.x)  , hash11( uv.x*12.-uv.y)     )-.5)*0.0125;    \n    float time = mod(iTime * speed,30.);\n\t\n    float angle = 10.0*iMouse.x/iResolution.x;\n    float travel=iTime*0.1;\n   \n    vec3 ro = vec3(42.5 * sin(travel*1.13),0,34.5 * cos(travel*2.))\n             +vec3(33.5 * sin(travel*.3),2.,23.5 * cos(travel*.53))\n        ;\n    float trr=terrain(  ro)+14.+13.*sin(travel*1.5);\n    ro.y=trr;\n    vec3 ta = ro+ vec3(2.5 * sin(5.+travel*1.13),2.,4.5 * cos(travel*2.))*20.\n             +vec3(3.5 * sin(travel),2.,1.5 * cos(3.+travel*.3))*10.\n        ;\n    float trry=terrain(  ta)-4.+7.*sin(5.+travel*.5);\n    ta.y=trry;\n    vec3 ww = normalize(ta-ro); //front\n    vec3 uu = normalize(cross(ww,vec3(0.,1.,0.))); //right\n    vec3 vv = normalize(cross(uu,ww)); //up\n    \n    vec3 rd = normalize(uv.x*uu + uv.y*vv + 1.5*ww);\n    \n    vec3 col = vec3(0.5, 0.7, 1.) - max(rd.y,0.0)*0.5;\n    \n    float t = castRay(ro,rd);\n    vec3 mate = vec3(0.2);\n    \n    if(t > 0.)\n    {\n        vec3 pos = ro + t*rd;\n        vec3 norm = calcNormal(pos);\n        \n        vec3 sunDir = normalize(vec3( 1.0,0.4,.2));\n       \tfloat sunDif = clamp( dot(norm, sunDir),0.,1.);\n        float skyDif = clamp( 0.5 + 0.5*dot(norm, vec3(0.,1.,0.)),0.,1.);\n        float sunSha = step(castRay(pos + norm * 0.001, sunDir),0.);\n        float bouceDif = clamp( 0.5 + 0.5*dot(norm, vec3(0.,-1.,0.)),0.,1.);\n        \n      \n        {\n            col =  mate*vec3(7.0,5.0,3.) * sunDif * sunSha;\n            col += mate*vec3(0.5,0.8,0.9) * skyDif;        \n            col += mate*vec3(0.7,0.5,0.3) * bouceDif;   \n            col=mix(vec3(0.5, 0.7, 1.)- max(rd.y,0.0)*0.5,col,min(1.,40./t));\n\n        }\n\n    }\n    \n  \n\n\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WlXSD2",
    "date": "0",
    "viewed": 0,
    "name": "pano lens",
    "description": "Testing some glass material rendering. You can rotate the object with the mouse.",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "raymarching",
     "reflection",
     "refraction",
     "glass",
     "transparent"
    ]
   },
   "renderpass": [
    {
     "inputs": [
      {
       "id": "XdX3zn",
       "filepath": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg",
       "type": "cubemap",
       "channel": 1,
       "sampler": {
        "filter": "mipmap",
        "wrap": "clamp",
        "vflip": "false",
        "srgb": "false",
        "internal": "byte"
       },
       "published": 1
      }
     ],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"Empty Glass\" by mu6k. https://shadertoy.com/view/4s2GDV\n// 2019-07-27 16:18:27\n\n/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tTesting some glass material rendering.\n\tYou can rotate the object with the mouse.\n\n*/\n   struct raygo{ \n        vec3 pos;\n        vec3 drefl;\n\t\tvec3 drefr;\n        vec3 n ;\n       float fresnel;\n           \n            } ;\n\n//functions that build rotation matrixes\nmat2 rotate_2D(float a){float sa = sin(a); float ca = cos(a); return mat2(ca,sa,-sa,ca);}\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nfloat ior = .8;\n\n//2D texture based 3 component 1D, 2D, 3D noise\nvec3 noise(float p){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0)).xyz;}\nvec3 noise(vec2 p){return texture(iChannel0,p/iChannelResolution[0].xy).xyz;}\nvec3 noise(vec3 p){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev).yz).xyz,texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(s).yz).xyz,m);}\n\nvec3 noise(float p, float lod){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0),lod).xyz;}\nvec3 noise(vec2 p, float lod){return texture(iChannel0,p/iChannelResolution[0].xy,lod).xyz;}\nvec3 noise(vec3 p, float lod){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev,lod).yz,lod).xyz,texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(s,lod).yz,lod).xyz,m);}\n\n\n#define t iTime\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat o=.2;\n\n float l1(vec3 p){\n   p.y=abs(p.y);\n  float d= sdTorus(p,vec2(.26+o,1.)); \n  float a=     min(length(p.xz)-.7-o,\n  sdTorus(p,vec2(.55+o,0.6)) );  \n   d= max(-a,d);\n     d= max(d,  p.y-.83) ;  \n\n\treturn d;\n    \n}\n\n\n\n float l2(vec3 p){\n       p.y=abs(p.y);\n\n  float d= sdTorus(p,vec2(.0+o,.9)); \n  float a=     min(length(p.xz)-.45-o,\n  sdTorus(p,vec2(.35+o,0.3)) );  \n   d= max(-a,d);\n       d= max(d,  p.y-.58) ;  \n\n\treturn d;\n    \n} \nfloat l3(vec3 p){\n       p.y=abs(p.y);\n\n  float d= sdTorus(p,vec2(-.05+o,.55)); \n  float a=     min(length(p.xz)-.15-o,\n  sdTorus(p,vec2(.0725+o,0.2)) );  \n  d= max(-a,d);\n       d= max(d,  p.y-.3) ;  \n\n\treturn d;\n    \n}\n\nfloat l4(vec3 p){\n  \n  float d=    length(p.xz )-max(0.,p.y+.18);\n                      d= max(d,  p.y-.17) ;  \n\n\treturn d;\n    \n}\n\nfloat df_obj(vec3 p)\n{\n    \n    float d= l1(p); \n d=min(d,l2(p));\n d=min(d,l3(p));\n d=min(d,l4(p));\n    \n\t  d= max(d, max( -p.z, -p.z)) ;  \n\n\treturn d;\n    \n}\n\n\nfloat df(vec3 p)\n{\n\treturn df_obj(p);\n}\n\nvec3 nf(vec3 p)\n{\n\tfloat e = .02;\n\tfloat dfp = df(p);\n\treturn vec3(\n\t\t(dfp+df(p+vec3(e,.0,.0)))/e,\n\t\t(dfp+df(p+vec3(.0,e,.0)))/e,\n\t\t(dfp+df(p+vec3(.0,.0,e)))/e);\n}\n\nvec3 tex(vec3 d)\n{\n\treturn pow(texture(iChannel1,d).xyz*1.4,vec3(1.4));\n}\n\nraygo go(raygo  t){\n\t\t\n\t\tvec3 pos = t.pos+t.drefr*.05;\n\t\tfor (int i=0; i<140; i++)\n\t\t{\n\t\t\tfloat dist = df(pos);\n\t\t\tpos+=t.drefr*-dist;\n\t\t\tif (dist>-.0001) break;\n\t\t}\n\t\tvec3 n = nf(pos);\n\t\tvec3 drefl = reflect(t.drefr,-n);\n\t\tvec3 drefr = refract(t.drefr,-n,ior);\n\t\tfloat fresnel = dot(-drefr,n);\n\nreturn raygo(pos,drefl,drefr,n,fresnel);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tvec2 mouse = iMouse.xy/ iResolution.xy*2.0-1.0;\n\tmouse.x *= iResolution.x/iResolution.y*4.0;\n\t\n\tmat3 rotmat = rotate_x(mouse.y*4.0+sin(t*.1)*.3+4.2)*rotate_y(mouse.x+t*.125-1.0/t+sin(t*.35));\n\t\n\tvec3 pos = vec3(.0,.0,-3.30)*rotmat ;\n\tvec3 dir = normalize(vec3(uv,2.5))*rotmat;\n\t\n\tvec3 light_dir = normalize(vec3(.4,.5,.6));\n\tvec3 light_color = vec3(.6,.5,.4);\n\t\n\tfloat dist;\n\t\n\tfor (int i=0; i<180; i++)\n\t{\n\t\tdist = df(pos);\n\t\tpos+=dir*dist;\n\t\tif (dist<.00001) break;\n\t}\n\n\tvec3 color = vec3(1.0);\n\tvec3 n = nf(pos);\n\t\n\tvec3 dfdxn = dFdx(n);\n\tvec3 dfdyn = dFdy(n);\n\t\n\tfloat lines = length((abs(dfdxn)+abs(dfdyn))*3.0);\n\tlines = lines*3.75;\n\tlines = lines-1.0;\n\tlines = clamp(lines,.0,1.0);\n\tif (lines>1.0)lines = 1.0;\n\t\n\tcolor = tex(dir).xyz;\n\t\n\tif (length(pos)>5.0)\n\t{\n\t\t//color = vec3(1.0);\n\t}\n\telse\n\t{\n\t\tfloat oa = 0.5;//df(pos+n)*.5+.5;\n\t\tfloat od = 1.0;\n\n\t\tfloat ior = 1.52;\n\t\t\n\t\t//oa -= mod(oa,.33);\n\t\t\n\t\tvec3 drefl = reflect(dir,n);\n\t\tvec3 drefr = refract(dir,n,ior);\n\t\t\n\t\tfloat diffuse = max(.0,dot(n,light_dir)*.8+.2)*od*oa*1.5;\n\t\tfloat fresnel1 = dot(-dir,n);\n\t\t\n\t\t\n\t\tvec3 pos2 = pos+drefr*.05;\n\t\tfor (int i=0; i<140; i++)\n\t\t{\n\t\t\tfloat dist = df(pos2);\n\t\t\tpos2+=drefr*-dist;\n\t\t\tif (dist>-.0001) break;\n\t\t}\n\t\tvec3 n2 = nf(pos2);\n\t\tvec3 drefl2 = reflect(drefr,-n2);\n\t\tvec3 drefr2 = refract(drefr,-n2,ior);\n\t\tfloat fresnel2 = dot(-drefr,n2);\n\t\t\n\t\tvec3 pos3 = pos2+drefr2*.02;\n\t\tfor (int i=0; i<170; i++)\n\t\t{\n\t\t\tfloat dist = df(pos3);\n\t\t\tpos3+=drefr2 * dist;\n\t\t\tif (dist<.0001) break;\n\t\t}\n\t\tvec3 n3 = nf(pos3);\n\t\tvec3 drefl3 = reflect(drefr2,n3);\n\t\tvec3 drefr3 = refract(drefr2,n3,ior);\n\t\tfloat fresnel3 = dot(-drefr2,n3);\n\n        \n\t\tvec3 pos4 = pos3+drefr3*.02;\n\t\tfor (int i=0; i<140; i++)\n\t\t{\n\t\t\tfloat dist = df(pos4);\n\t\t\tpos4+=drefr3*-dist;\n\t\t\tif (dist>-.0001) break;\n\t\t}\n\t\tvec3 n4 = nf(pos4);\n\t\tvec3 drefl4 = normalize(reflect(drefr3,-n4));\n\t\tvec3 drefr4 = normalize(refract(drefr3,-n4,ior));\n        float fresnel4 = dot(-drefr3,n4);\n\t\t\n\t\t\n\t\tif (df(pos4)<0.1)\n\t\t{\n\t\t\tcolor.r = tex(normalize(refract(drefr3,-n4,ior*.99))).r*.7;\n\t\t\tcolor.g = tex(normalize(refract(drefr3,-n4,ior*1.0))).g*.7;\n\t\t\tcolor.b = tex(normalize(refract(drefr3,-n4,ior*1.01))).b*.7;\n\t\t\t//color = mix(color,texture(iChannel1,drefl3).xyz,1.0-fresnel3);\n\t\t\tcolor += vec3(.01);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcolor.r = tex(normalize(refract(drefr,-n2,ior*.99))).r;\n\t\t\tcolor.g = tex(normalize(refract(drefr,-n2,ior*1.0))).g;\n\t\t\tcolor.b = tex(normalize(refract(drefr,-n2,ior*1.01))).b;\n\t\t}\n\t\t\n\t\tcolor = mix(texture(iChannel1,drefl2).xyz,color,pow(-fresnel2,.2));\n\t\tcolor = mix(tex(drefl).xyz,color*.7,pow(fresnel1,.5));\n\t\tcolor += vec3(.01);\n\t\t//color = n2;\n\t}\n\t\n\tvec3 color0 = mix(color,vec3(.0),lines);\n\tvec3 color1 = n*.4+.4;\n\tvec3 color2 = dfdxn+dfdyn;\n\tvec3 color3 = vec3(lines);\n\t\n\tfloat mt = mod(t,32.0);\n\tfloat mti = mod(t,1.0);\n\t\n\tcolor += noise(vec3(fragCoord.xy,t*60.0))*0.01;\n\t\n\tfragColor = vec4(pow(color,vec3(.5)),1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wdsBzX",
    "date": "0",
    "viewed": 0,
    "name": "radiladisptest",
    "description": "test noise",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "noise"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "#define S 5. // Scale\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n vec3 noise33(  vec3 p )\n{\n    p=p+10000.;\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u;\n    u.x = f.x*f.x*(3.0-2.0*f.x);\n    u.y = f.y*f.y*(3.0-2.0*f.y);\n    u.z = f.z*f.z*(3.0-2.0*f.z);\n\n    return mix( \n        mix(\n                mix( hash33( i + vec3(0.0,0.0,0.0) ), \n                     hash33( i + vec3(1.0,0.0,0.0) ), u.x),\n                mix( hash33( i + vec3(0.0,1.0,0.0) ), \n                     hash33( i + vec3(1.0,1.0,0.0) ), u.x)\n               , u.y),\n              mix(\n                mix( hash33( i + vec3(0.0,0.0,1.0) ), \n                     hash33( i + vec3(1.0,0.0,1.0) ), u.x),\n                mix( hash33( i + vec3(0.0,1.0,1.0) ), \n                     hash33( i + vec3(1.0,1.0,1.0) ), u.x)\n               , u.y)\n        \n         , u.z)\n        ;\n}\n\n \n\nvec3 fbm33( vec3 p )\n{\n   \n     mat3 m = mat3(vec3(0.80,  0.60, -0.6).xyz,\n                    vec3(0.80,  0.60, -0.6).yzx,\n                    vec3(0.80,  0.60, -0.6).zxy);\n    vec3 f = vec3(0.0);\n    f += 0.5000*noise33( p ); p = m*p*2.02;\n    f += 0.2500*noise33( p ); p = m*p*2.03;\n    f += 0.1250*noise33( p ); p = m*p*2.01;\n    f += 0.0625*noise33( p );\n    return f/0.9375;\n}\nvec3 n33( vec3 p ) \n{\n    vec3 s=vec3(0.,0.,0.00001);\n    float b=fbm33(p).x;\n    vec3 n= vec3(\n        b-fbm33(p-s.zxx).x, \n        b-fbm33(p-s.xzx).x, \n        b-fbm33(p-s.xxz).x \n    \n    );\n     vec3 n2= -vec3(\n        b-fbm33(p+s.zxx).x, \n        b-fbm33(p+s.xzx).x, \n        b-fbm33(p+s.xxz).x \n    \n    );\n    \nn=normalize(n+n2);\nreturn vec3(-n.y,n.x,n.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p=fragCoord;\n    // Normalized pixel coordinates (from 0 to 1)\n \tvec2 uv ;\n    \n\t  uv = (S * p.xy * vec2(iResolution.x / iResolution.y, 1) / iResolution.xy);\n      uv -= n33(vec3(uv/3.,0.)).xy*.5 ; \n\n    vec4 col = vec4(vec3(mod(floor(uv.x) + floor(uv.y), 2.)), 1);\n   col= vec4(noise33(vec3(uv,0.)),0.); \n\n    // Output to screen\n    fragColor = vec4(col );\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "wlV3Wh",
    "date": "1578854385",
    "viewed": 30,
    "name": "sdCylinder Sponge x2",
    "description": "sdCylinder Sponge",
    "likes": 2,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "sdcylindersponge"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "// Fork of \"sdCylinder Sponge\" by jorge2017a1. https://shadertoy.com/view/3lK3D1\n// 2020-01-12 18:37:15\n\n//referencia 60442.0\nfloat smin(float a, float b, float k)\n{\n\tfloat h = clamp(.5 + .5*(a-b)/k, 0., 1.);\n\treturn mix(a, b, h) - k*h*(1.-h);\n}\n\nfloat maxcomp(vec2 p) {\n  return max(p.x, p.y);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  p = abs(p) - b;\n  return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\nfloat sdBox(vec2 p, vec2 b) {\n  p = abs(p) - b;\n  return length(max(p, 0.0)) + min(max(p.x, p.y), 0.0);\n}\n\n\nfloat dsCapsule(vec3 point_a, vec3 point_b, float r, vec3 point_p)//cylinder SDF\n{\n \tvec3 ap = point_p - point_a;\n    vec3 ab = point_b - point_a;\n    float ratio = dot(ap, ab) / dot(ab , ab);\n    ratio = clamp(ratio, 0.f, 1.f);\n    vec3 point_c = point_a + ratio * ab;\n    return length(point_c - point_p) - r;\n}\n\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\n/*\nfloat sdCross(vec3 p) {\n  float da = sdBox(p.xy, vec2(1.0));\n  float db = sdBox(p.yz, vec2(1.0));\n  float dc = sdBox(p.zx, vec2(1.0));\n  return min(da, min(db, dc));\n}\n*/\n\nfloat sdCross(vec3 p) {\n  float da = maxcomp(abs(p.xy));\n  float db = maxcomp(abs(p.yz));\n  float dc = maxcomp(abs(p.xz));\n  return min(da, min(db, dc)) - 1.0;\n}\n\n\nmat2 rotate(float r) {\n  float c = cos(r);\n  float s = sin(r);\n  return mat2(c, s, -s, c);\n}\n\nfloat map(vec3 p) {\n  p.zx *= rotate(iTime);\n  p.yx *= rotate(iTime * 0.5);\n\n  \n  \n  float d;\n   \n    float  distToCapsule =sdCylinder( p, vec2(.350,1.76) );\n    \n    d=distToCapsule;\n    \n    \n  float s = 1.4;\n  for (int m = 0; m < 3; m++) {\n    vec3 a = mod(p * s, 2.0) - 1.0;\n    s *= 3.0;\n    vec3 r = 1.0 - 3.01 * abs(a*1.01);\n    float c = sdCross(r) / s;\n    d = max(d, c);\n  }\n    \n      p.zx *= rotate(1.+iTime);\n  p.yx *= rotate(iTime * 0.5);\n\n  \n  \n  float d2;\n   \n    float  distToCapsule2 =sdCylinder( p, vec2(1.7,.12) );\n    \n    d2=distToCapsule2;\n    \n    \n  float s2 = 1.1;\n  for (int m2 = 0; m2 < 4; m2++) {\n    vec3 a2 = mod(p * s2, 2.0) - 1.0;\n    s2 *= 3.0;\n    vec3 r2 = 1.0 - 3.1 * abs(a2*1.05);\n    float c2 = sdCross(r2) / s2;\n    d2 = max(d2, c2);\n  }\n    \n  return smin(d,d2,.125);\n                               \n                               \n\n                               \n}\n\nvec3 normal(vec3 p) {\n  float d = 0.01;\n  return normalize(vec3(\n    map(p + vec3(d, 0.0, 0.0)) - map(p - vec3(d, 0.0, 0.0)),\n    map(p + vec3(0.0, d, 0.0)) - map(p - vec3(0.0, d, 0.0)),\n    map(p + vec3(0.0, 0.0, d)) - map(p - vec3(0.0, 0.0, d))\n  ));\n}\n\nvec3 raymarch(vec3 ro, vec3 rd) {\n  vec3 p = ro;\n  for (int i = 0; i < 64; i++) {\n    float d = map(p);\n    p += d * rd;\n    if (d < 0.01) {\n      vec3 n = normal(p);\n      return n * 0.5 + 0.5;\n      //return vec3(0.1) + vec3(0.95, 0.5, 0.5) * max(0.0, dot(n, normalize(vec3(1.0))));\n    }\n  }\n  return vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 st = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n  vec3 ro = vec3(0.0, 0.0, 3.0);\n  vec3 ta = vec3(0.0);\n  vec3 z = normalize(ta - ro);\n  vec3 x = normalize(cross(z, vec3(0.0, 1.0, 0.0)));\n  vec3 y = normalize(cross(x, z));\n  vec3 rd = normalize(st.x * x + st.y * y + 1.5 * z);\n\n  vec3 c = raymarch(ro, rd);\n\n  fragColor = vec4(c, 1.0);\n\n}\n",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WlBXRz",
    "date": "0",
    "viewed": 0,
    "name": "starfield fail",
    "description": "starfield fail",
    "likes": 0,
    "published": "Private",
    "usePreview": 0,
    "tags": [
     "starfield"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "float f(vec2 uv){return (abs(noise33(vec3(uv.xy*25.,uv.x+uv.y )).x-.5)*19.)+.4;}\nvec2 grad( in vec2 x ){\n    vec2 h = vec2( 0.01, 0.0 );\n    return vec2( f(x+h.xy) - f(x-h.xy),\n                 f(x+h.yx) - f(x-h.yx) )/(2.0*h.x);\n}\n \nfloat color( in vec2 x )\n{\n    float v = f( x );\n    vec2  g = grad( x );\n    float de = abs(v)/length(g);\n    float eps = 1.;\n    return smoothstep( 1.0*eps, 2.0*eps, de );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\nvec3 col=  vec3(color(uv));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    },
    {
     "inputs": [],
     "outputs": [],
     "code": "\n\n//----------------------------------------------------------------------------------------\n// Hash without Sine  https://www.shadertoy.com/view/4djSRW\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n//----------------------------------------------------------------------------------------\n//// Created by inigo quilez - iq/2014\n//----------------------------------------------------------------------------------------\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat noise13( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( \n        mix(\n                mix( hash13( i + vec3(0.0,0.0,0.0) ), \n                     hash13( i + vec3(1.0,0.0,0.0) ), u.x),\n                mix( hash13( i + vec3(0.0,1.0,0.0) ), \n                     hash13( i + vec3(1.0,1.0,0.0) ), u.x)\n               , u.y),\n              mix(\n                mix( hash13( i + vec3(0.0,0.0,1.0) ), \n                     hash13( i + vec3(1.0,0.0,1.0) ), u.x),\n                mix( hash13( i + vec3(0.0,1.0,1.0) ), \n                     hash13( i + vec3(1.0,1.0,1.0) ), u.x)\n               , u.y)\n        \n         , u.z)\n        ;\n}\n\nvec3 noise33(  vec3 p )\n{\n    p=p+10000.;\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u;\n    u.x = f.x*f.x*(3.0-2.0*f.x);\n    u.y = f.y*f.y*(3.0-2.0*f.y);\n    u.z = f.z*f.z*(3.0-2.0*f.z);\n\n    return mix( \n        mix(\n                mix( hash33( i + vec3(0.0,0.0,0.0) ), \n                     hash33( i + vec3(1.0,0.0,0.0) ), u.x),\n                mix( hash33( i + vec3(0.0,1.0,0.0) ), \n                     hash33( i + vec3(1.0,1.0,0.0) ), u.x)\n               , u.y),\n              mix(\n                mix( hash33( i + vec3(0.0,0.0,1.0) ), \n                     hash33( i + vec3(1.0,0.0,1.0) ), u.x),\n                mix( hash33( i + vec3(0.0,1.0,1.0) ), \n                     hash33( i + vec3(1.0,1.0,1.0) ), u.x)\n               , u.y)\n        \n         , u.z)\n        ;\n}\n\nfloat fbm( vec2 p )\n{\n      mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nvec3 fbm33( vec3 p )\n{\n   \n     mat3 m = mat3(vec3(0.80,  0.60, -0.6).xyz,\n                    vec3(0.80,  0.60, -0.6).yzx,\n                    vec3(0.80,  0.60, -0.6).zxy);\n    vec3 f = vec3(0.0);\n    f += 0.5000*noise33( p ); p = m*p*2.02;\n    f += 0.2500*noise33( p ); p = m*p*2.03;\n    f += 0.1250*noise33( p ); p = m*p*2.01;\n    f += 0.0625*noise33( p );\n    return f/0.9375;\n}\n\nfloat fbm13( vec3 p )\n{\n         float m =1.;\n\n\n    float f =  (0.0);\n    f += 0.5000*noise13( p ); p = m*p*2.02;\n    f += 0.2500*noise13( p ); p = m*p*2.03;\n    f += 0.1250*noise13( p ); p = m*p*2.01;\n    f += 0.0625*noise13( p );\n    return f/0.9375;\n}\n\nvec2 fbm2( in vec2 p )\n{\n    return vec2( fbm(p.xy), fbm(p.yx) );\n}\n\n\n",
     "name": "Common",
     "description": "",
     "type": "common"
    }
   ]
  },
  {
   "ver": "0.1",
   "info": {
    "id": "WdyGzG",
    "date": "1570393739",
    "viewed": 73,
    "name": "staticNoise",
    "description": "black and white  TV static",
    "likes": 0,
    "published": "Public",
    "usePreview": 0,
    "tags": [
     "noisefunction"
    ]
   },
   "renderpass": [
    {
     "inputs": [],
     "outputs": [
      {
       "id": "4dfGRr",
       "channel": 0
      }
     ],
     "code": "vec3 staticNoise (vec2 uv){\n    vec3 col  ;\n    //uv=mod(uv,1000.) ;\n    for (int i=0;i<10;i++)\n    {  \n     uv.xy *=.998;\n        uv.xy +=vec2(100.7*fract(uv.y),100.3*fract(uv.x));\n        uv= vec2(uv.x*.7-uv.y*.6,uv.y*.53+uv.x*1.1);\ncol.zxy +=    vec3(   mod( (floor(uv.x*uv.x -uv.y*uv.y)+floor(uv.y*uv.y+uv.x*uv.x)),2.)   );\n \n }\n   \n   col=mod(col,2.);\n      return col; \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     \n vec2 uv = fragCoord/iResolution.xy;\n vec3 col=staticNoise(uv  );\n \n    fragColor = vec4(col,1.0);\n}",
     "name": "Image",
     "description": "",
     "type": "image"
    }
   ]
  }
 ]
}